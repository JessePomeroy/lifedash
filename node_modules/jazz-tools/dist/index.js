import {
  Account,
  AnonymousJazzAgent,
  AuthSecretStorage,
  CoFeed,
  CoList,
  CoMap,
  CoPlainText,
  CoRichText,
  CoValueBase,
  Encoders,
  FileStream,
  Group,
  ImageDefinition,
  InMemoryKVStore,
  Inbox,
  InboxSender,
  JazzContextManager,
  KvStoreContext,
  Profile,
  SchemaUnion,
  SubscriptionScope,
  anySchemaToCoSchema,
  coExport_exports,
  coField,
  createAnonymousJazzContext,
  createCoValueObservable,
  createJazzContext,
  createJazzContextForNewAccount,
  createJazzContextFromExistingCredentials,
  isControlledAccount,
  loadCoValue,
  randomSessionProvider,
  subscribeToCoValue,
  zodReExport_exports,
  zodSchemaToCoSchema
} from "./chunk-AUQIX4E7.js";

// src/auth/DemoAuth.ts
var DemoAuth = class {
  constructor(authenticate, authSecretStorage) {
    this.authenticate = authenticate;
    this.authSecretStorage = authSecretStorage;
    this.logIn = async (username) => {
      const existingUsers = await this.getExisitingUsersWithData();
      const storageData = existingUsers[username];
      if (!storageData?.accountID) {
        throw new Error("User not found");
      }
      await this.authenticate({
        accountID: storageData.accountID,
        accountSecret: storageData.accountSecret
      });
      await this.authSecretStorage.set({
        accountID: storageData.accountID,
        accountSecret: storageData.accountSecret,
        secretSeed: storageData.secretSeed ? new Uint8Array(storageData.secretSeed) : void 0,
        provider: "demo"
      });
    };
    this.signUp = async (username) => {
      const existingUsers = await this.getExistingUsers();
      if (existingUsers.includes(username)) {
        throw new Error("User already registered");
      }
      const credentials = await this.authSecretStorage.get();
      if (!credentials) {
        throw new Error("No credentials found");
      }
      const currentAccount = await Account.getMe().ensureLoaded({
        resolve: {
          profile: true
        }
      });
      currentAccount.profile.name = username;
      await this.authSecretStorage.set({
        accountID: credentials.accountID,
        accountSecret: credentials.accountSecret,
        secretSeed: credentials.secretSeed ? new Uint8Array(credentials.secretSeed) : void 0,
        provider: "demo"
      });
      await this.addToExistingUsers(username, {
        accountID: credentials.accountID,
        accountSecret: credentials.accountSecret,
        secretSeed: credentials.secretSeed ? Array.from(credentials.secretSeed) : void 0
      });
    };
    this.getExistingUsers = async () => {
      return Object.keys(await this.getExisitingUsersWithData());
    };
  }
  async addToExistingUsers(username, data) {
    const existingUsers = await this.getExisitingUsersWithData();
    if (existingUsers[username]) {
      return;
    }
    existingUsers[username] = data;
    const kvStore = KvStoreContext.getInstance().getStorage();
    await kvStore.set("demo-auth-users", JSON.stringify(existingUsers));
  }
  async getExisitingUsersWithData() {
    const kvStore = KvStoreContext.getInstance().getStorage();
    await migrateExistingUsers(kvStore);
    const existingUsers = await kvStore.get("demo-auth-users");
    return existingUsers ? JSON.parse(existingUsers) : {};
  }
};
function encodeUsername(username) {
  return btoa(username).replace(/=/g, "-").replace(/\+/g, "_").replace(/\//g, ".");
}
async function getStorageVersion(kvStore) {
  try {
    const version = await kvStore.get("demo-auth-storage-version");
    return version ? parseInt(version) : 1;
  } catch (error) {
    return 1;
  }
}
async function setStorageVersion(kvStore, version) {
  await kvStore.set("demo-auth-storage-version", version.toString());
}
async function getExistingUsersList(kvStore) {
  const existingUsers = await kvStore.get("demo-auth-existing-users");
  return existingUsers ? existingUsers.split(",") : [];
}
async function migrateExistingUsers(kvStore) {
  if (await getStorageVersion(kvStore) < 2) {
    const existingUsers = await getExistingUsersList(kvStore);
    for (const username of existingUsers) {
      const legacyKey = `demo-auth-existing-users-${username}`;
      const storageData = await kvStore.get(legacyKey);
      if (storageData) {
        await kvStore.set(
          `demo-auth-existing-users-${encodeUsername(username)}`,
          storageData
        );
        await kvStore.delete(legacyKey);
      }
    }
    await setStorageVersion(kvStore, 2);
  }
  if (await getStorageVersion(kvStore) < 3) {
    const existingUsersList = await getExistingUsersList(kvStore);
    const existingUsers = {};
    const keysToDelete = ["demo-auth-existing-users"];
    for (const username of existingUsersList) {
      const key = `demo-auth-existing-users-${encodeUsername(username)}`;
      const storageData = await kvStore.get(key);
      if (storageData) {
        existingUsers[username] = JSON.parse(storageData);
        keysToDelete.push(key);
      }
    }
    await kvStore.set("demo-auth-users", JSON.stringify(existingUsers));
    for (const key of keysToDelete) {
      await kvStore.delete(key);
    }
    await setStorageVersion(kvStore, 3);
  }
}

// src/auth/PassphraseAuth.ts
import * as bip39 from "@scure/bip39";
import { entropyToMnemonic } from "@scure/bip39";
import { cojsonInternals } from "cojson";
var PassphraseAuth = class {
  constructor(crypto, authenticate, register, authSecretStorage, wordlist) {
    this.crypto = crypto;
    this.authenticate = authenticate;
    this.register = register;
    this.authSecretStorage = authSecretStorage;
    this.wordlist = wordlist;
    this.passphrase = "";
    this.logIn = async (passphrase) => {
      const { crypto, authenticate } = this;
      let secretSeed;
      try {
        secretSeed = bip39.mnemonicToEntropy(passphrase, this.wordlist);
      } catch (e) {
        throw new Error("Invalid passphrase");
      }
      const accountSecret = crypto.agentSecretFromSecretSeed(secretSeed);
      const accountID = cojsonInternals.idforHeader(
        cojsonInternals.accountHeaderForInitialAgentSecret(accountSecret, crypto),
        crypto
      );
      await authenticate({
        accountID,
        accountSecret
      });
      await this.authSecretStorage.set({
        accountID,
        secretSeed,
        accountSecret,
        provider: "passphrase"
      });
      this.passphrase = passphrase;
      this.notify();
    };
    this.signUp = async (name) => {
      const credentials = await this.authSecretStorage.get();
      if (!credentials || !credentials.secretSeed) {
        throw new Error("No credentials found");
      }
      const passphrase = entropyToMnemonic(credentials.secretSeed, this.wordlist);
      await this.authSecretStorage.set({
        accountID: credentials.accountID,
        secretSeed: credentials.secretSeed,
        accountSecret: credentials.accountSecret,
        provider: "passphrase"
      });
      if (name?.trim()) {
        const currentAccount = await Account.getMe().ensureLoaded({
          resolve: {
            profile: true
          }
        });
        currentAccount.profile.name = name;
      }
      return passphrase;
    };
    this.registerNewAccount = async (passphrase, name) => {
      const secretSeed = bip39.mnemonicToEntropy(passphrase, this.wordlist);
      const accountSecret = this.crypto.agentSecretFromSecretSeed(secretSeed);
      const accountID = await this.register(accountSecret, { name });
      await this.authSecretStorage.set({
        accountID,
        secretSeed,
        accountSecret,
        provider: "passphrase"
      });
      return accountID;
    };
    this.getCurrentAccountPassphrase = async () => {
      const credentials = await this.authSecretStorage.get();
      if (!credentials || !credentials.secretSeed) {
        throw new Error("No credentials found");
      }
      return entropyToMnemonic(credentials.secretSeed, this.wordlist);
    };
    this.generateRandomPassphrase = () => {
      return entropyToMnemonic(this.crypto.newRandomSecretSeed(), this.wordlist);
    };
    this.loadCurrentAccountPassphrase = async () => {
      const passphrase = await this.getCurrentAccountPassphrase();
      this.passphrase = passphrase;
      this.notify();
    };
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = (callback) => {
      this.listeners.add(callback);
      return () => {
        this.listeners.delete(callback);
      };
    };
  }
  notify() {
    for (const listener of this.listeners) {
      listener();
    }
  }
};

// src/implementation/invites.ts
import { cojsonInternals as cojsonInternals2 } from "cojson";
function createInviteLink(value, role, baseURL, valueHint) {
  const coValueCore = value._raw.core;
  let currentCoValue = coValueCore;
  while (currentCoValue.verified.header.ruleset.type === "ownedByGroup") {
    currentCoValue = currentCoValue.getGroup().core;
  }
  const { ruleset, meta } = currentCoValue.verified.header;
  if (ruleset.type !== "group" || meta?.type === "account") {
    throw new Error("Can't create invite link for object without group");
  }
  const group = cojsonInternals2.expectGroup(currentCoValue.getCurrentContent());
  const inviteSecret = group.createInvite(role);
  return `${baseURL}#/invite/${valueHint ? valueHint + "/" : ""}${value.id}/${inviteSecret}`;
}
function parseInviteLink(inviteURL) {
  const url = new URL(inviteURL);
  const parts = url.hash.split("/");
  let valueHint;
  let valueID;
  let inviteSecret;
  if (parts[0] === "#" && parts[1] === "invite") {
    if (parts.length === 5) {
      valueHint = parts[2];
      valueID = parts[3];
      inviteSecret = parts[4];
    } else if (parts.length === 4) {
      valueID = parts[2];
      inviteSecret = parts[3];
    }
    if (!valueID || !inviteSecret) {
      return void 0;
    }
    return { valueID, inviteSecret, valueHint };
  }
}
function consumeInviteLink({
  inviteURL,
  as = Account.getMe(),
  forValueHint,
  invitedObjectSchema
}) {
  return new Promise((resolve, reject) => {
    const result = parseInviteLink(inviteURL);
    if (result && result.valueHint === forValueHint) {
      as.acceptInvite(result.valueID, result.inviteSecret, invitedObjectSchema).then(() => {
        resolve(result);
      }).catch(reject);
    } else {
      resolve(void 0);
    }
  });
}

// src/index.ts
import { MAX_RECOMMENDED_TX_SIZE, cojsonInternals as cojsonInternals3 } from "cojson";
export {
  Account,
  AnonymousJazzAgent,
  AuthSecretStorage,
  FileStream as BinaryCoStream,
  CoFeed,
  CoList,
  CoMap,
  CoPlainText,
  CoRichText,
  CoFeed as CoStream,
  CoValueBase,
  DemoAuth,
  Encoders,
  FileStream,
  Group,
  ImageDefinition,
  InMemoryKVStore,
  Inbox,
  InboxSender,
  JazzContextManager,
  KvStoreContext,
  MAX_RECOMMENDED_TX_SIZE,
  PassphraseAuth,
  Profile,
  SchemaUnion,
  SubscriptionScope,
  anySchemaToCoSchema,
  coExport_exports as co,
  coField,
  cojsonInternals3 as cojsonInternals,
  consumeInviteLink,
  createAnonymousJazzContext,
  createCoValueObservable,
  createInviteLink,
  createJazzContext,
  createJazzContextForNewAccount,
  createJazzContextFromExistingCredentials,
  isControlledAccount,
  loadCoValue,
  parseInviteLink,
  randomSessionProvider,
  subscribeToCoValue,
  zodReExport_exports as z,
  zodSchemaToCoSchema
};
//# sourceMappingURL=index.js.map