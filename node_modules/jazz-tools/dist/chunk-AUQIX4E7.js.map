{"version":3,"sources":["../src/implementation/zodSchema/zodReExport.ts","../src/coValues/CoValueBase.ts","../src/implementation/inspect.ts","../src/implementation/symbols.ts","../src/coValues/registeredSchemas.ts","../src/coValues/coMap.ts","../src/coValues/coList.ts","../src/coValues/coFeed.ts","../src/coValues/account.ts","../src/coValues/group.ts","../src/coValues/profile.ts","../src/coValues/inbox.ts","../src/coValues/coPlainText.ts","../src/lib/cache.ts","../src/coValues/coRichText.ts","../src/coValues/schemaUnion.ts","../src/implementation/anonymousJazzAgent.ts","../src/implementation/activeAccountContext.ts","../src/implementation/refs.ts","../src/implementation/schema.ts","../src/lib/migration.ts","../src/subscribe/CoValueCoreSubscription.ts","../src/subscribe/JazzError.ts","../src/subscribe/utils.ts","../src/subscribe/SubscriptionScope.ts","../src/subscribe/index.ts","../src/implementation/createContext.ts","../src/implementation/zodSchema/zodSchema.ts","../src/implementation/zodSchema/zodCo.ts","../src/implementation/zodSchema/coExport.ts","../src/implementation/zodSchema/unionUtils.ts","../src/implementation/zodSchema/runtimeConverters/zodFieldToCoFieldDef.ts","../src/implementation/zodSchema/runtimeConverters/zodSchemaToCoSchema.ts","../src/coValues/extensions/imageDef.ts","../src/implementation/ContextManager.ts","../src/auth/KvStoreContext.ts","../src/auth/AuthSecretStorage.ts","../src/auth/InMemoryKVStore.ts","../src/implementation/devtoolsFormatters.ts","../src/coValues/interfaces.ts"],"sourcesContent":["export {\n  string,\n  number,\n  boolean,\n  union,\n  object,\n  array,\n  templateLiteral,\n  json,\n  tuple,\n  date,\n  emoji,\n  base64,\n  base64url,\n  nanoid,\n  cuid,\n  cuid2,\n  ulid,\n  ipv4,\n  ipv6,\n  email,\n  url,\n  uuid,\n  literal,\n  enum,\n  cidrv4,\n  cidrv6,\n  iso,\n  int32,\n  strictObject,\n  discriminatedUnion,\n  //   intersection,\n  //   record,\n  int,\n  optional,\n  type ZodOptional,\n  type ZodReadonly,\n  type ZodLazy,\n  type ZodDefault,\n  type ZodCatch,\n  type output as infer,\n  z,\n} from \"zod/v4\";\n","import { ControlledAccount, RawAccount, type RawCoValue } from \"cojson\";\nimport { z } from \"../implementation/zodSchema/zodReExport.js\";\nimport {\n  AnonymousJazzAgent,\n  CoValue,\n  CoValueClass,\n  CoValueFromRaw,\n  ID,\n  RegisteredSchemas,\n  accessChildById,\n  anySchemaToCoSchema,\n  coValuesCache,\n  inspect,\n} from \"../internal.js\";\nimport type {\n  Account,\n  CoValueClassFromZodSchema,\n  Group,\n  InstanceOfSchemaCoValuesNullable,\n} from \"../internal.js\";\n\n/** @internal */\n\nexport class CoValueBase implements CoValue {\n  declare id: ID<this>;\n  declare _type: string;\n  declare _raw: RawCoValue;\n  /** @category Internals */\n  declare _instanceID: string;\n\n  get _owner(): Account | Group {\n    const schema =\n      this._raw.group instanceof RawAccount\n        ? RegisteredSchemas[\"Account\"]\n        : RegisteredSchemas[\"Group\"];\n\n    return accessChildById(this, this._raw.group.id, {\n      ref: schema,\n      optional: false,\n    });\n  }\n\n  /** @private */\n  get _loadedAs() {\n    const agent = this._raw.core.node.getCurrentAgent();\n\n    if (agent instanceof ControlledAccount) {\n      return coValuesCache.get(agent.account, () =>\n        anySchemaToCoSchema(RegisteredSchemas[\"Account\"]).fromRaw(\n          agent.account,\n        ),\n      );\n    }\n\n    return new AnonymousJazzAgent(this._raw.core.node);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(..._args: any) {\n    Object.defineProperty(this, \"_instanceID\", {\n      value: `instance-${Math.random().toString(36).slice(2)}`,\n      enumerable: false,\n    });\n  }\n\n  /** @category Internals */\n  static fromRaw<V extends CoValue>(this: CoValueClass<V>, raw: RawCoValue): V {\n    return new this({ fromRaw: raw });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(): object | any[] | string {\n    return {\n      id: this.id,\n      type: this._type,\n      error: \"unknown CoValue class\",\n    };\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  /** @category Type Helpers */\n  castAs<\n    S extends\n      | CoValueClass\n      | z.core.$ZodType\n      | (z.core.$ZodObject<any, any> & {\n          builtin: \"Account\";\n          migration?: (account: any, creationProps?: { name: string }) => void;\n        })\n      | (z.core.$ZodCustom<any, any> & { builtin: \"FileStream\" })\n      | (z.core.$ZodCustom<any, any> & {\n          builtin: \"CoFeed\";\n          element: z.core.$ZodType;\n        }),\n  >(\n    schema: S,\n  ): S extends CoValueClass\n    ? InstanceType<S>\n    : S extends z.core.$ZodType\n      ? NonNullable<InstanceOfSchemaCoValuesNullable<S>>\n      : never {\n    const cl = \"getCoSchema\" in schema ? (schema as any).getCoSchema() : schema;\n\n    if (this.constructor === cl) {\n      return this as any;\n    }\n\n    return (cl as unknown as CoValueFromRaw<CoValue>).fromRaw(this._raw) as any;\n  }\n}\n","export const inspect = Symbol.for(\"nodejs.util.inspect.custom\");\nexport type inspect = typeof inspect;\n","export type JazzToolsSymbol = SchemaInit | ItemsSym | MembersSym;\n\nexport const SchemaInit = \"$SchemaInit$\";\nexport type SchemaInit = typeof SchemaInit;\n\nexport const ItemsSym = \"$items$\";\nexport type ItemsSym = typeof ItemsSym;\n\nexport const MembersSym = \"$members$\";\nexport type MembersSym = typeof MembersSym;\n","import type { Account, CoMap, Group } from \"../internal.js\";\n\n/**\n * Regisering schemas into this Record to avoid circular dependencies.\n */\nexport const RegisteredSchemas = {} as {\n  Account: typeof Account;\n  Group: typeof Group;\n  CoMap: typeof CoMap;\n};\n","import {\n  AgentID,\n  type CoValueUniqueness,\n  CojsonInternalTypes,\n  type JsonValue,\n  RawAccountID,\n  RawCoID,\n  type RawCoMap,\n  cojsonInternals,\n} from \"cojson\";\nimport type {\n  AnonymousJazzAgent,\n  AnyAccountSchema,\n  CoValue,\n  CoValueClass,\n  Group,\n  ID,\n  InstanceOfSchema,\n  RefEncoded,\n  RefIfCoValue,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Schema,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n} from \"../internal.js\";\nimport {\n  Account,\n  CoValueBase,\n  ItemsSym,\n  Ref,\n  RegisteredSchemas,\n  SchemaInit,\n  accessChildById,\n  accessChildByKey,\n  activeAccountContext,\n  ensureCoValueLoaded,\n  inspect,\n  isRefEncoded,\n  loadCoValueWithoutMe,\n  makeRefs,\n  parseCoValueCreateOptions,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n} from \"../internal.js\";\n\ntype CoMapEdit<V> = {\n  value?: V;\n  ref?: RefIfCoValue<V>;\n  by: Account | null;\n  madeAt: Date;\n  key?: string;\n};\n\ntype LastAndAllCoMapEdits<V> = CoMapEdit<V> & { all: CoMapEdit<V>[] };\n\nexport type Simplify<A> = {\n  [K in keyof A]: A[K];\n} extends infer B\n  ? B\n  : never;\n\n/**\n * CoMaps are collaborative versions of plain objects, mapping string-like keys to values.\n *\n * @categoryDescription Declaration\n * Declare your own CoMap schemas by subclassing `CoMap` and assigning field schemas with `co`.\n *\n * Optional `coField.ref(...)` fields must be marked with `{ optional: true }`.\n *\n * ```ts\n * import { coField, CoMap } from \"jazz-tools\";\n *\n * class Person extends CoMap {\n *   name = coField.string;\n *   age = coField.number;\n *   pet = coField.ref(Animal);\n *   car = coField.ref(Car, { optional: true });\n * }\n * ```\n *\n * @categoryDescription Content\n * You can access properties you declare on a `CoMap` (using `co`) as if they were normal properties on a plain object, using dot notation, `Object.keys()`, etc.\n *\n * ```ts\n * person.name;\n * person[\"age\"];\n * person.age = 42;\n * person.pet?.name;\n * Object.keys(person);\n * // => [\"name\", \"age\", \"pet\"]\n * ```\n *\n * @category CoValues\n *  */\nexport class CoMap extends CoValueBase implements CoValue {\n  /**\n   * The ID of this `CoMap`\n   * @category Content */\n  declare id: ID<this>;\n  /** @category Type Helpers */\n  declare _type: \"CoMap\";\n  static {\n    this.prototype._type = \"CoMap\";\n  }\n  /** @category Internals */\n  declare _raw: RawCoMap;\n\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  /** @internal */\n  get _schema() {\n    return (this.constructor as typeof CoMap)._schema as {\n      [key: string]: Schema;\n    } & { [ItemsSym]?: Schema };\n  }\n\n  /**\n   * The timestamp of the creation time of the CoMap\n   */\n  get _createdAt() {\n    return this._raw.earliestTxMadeAt ?? Number.MAX_SAFE_INTEGER;\n  }\n\n  /**\n   * The timestamp of the last updated time of the CoMap\n   */\n  get _lastUpdatedAt() {\n    return this._raw.latestTxMadeAt;\n  }\n\n  /**\n   * If property `prop` is a `coField.ref(...)`, you can use `coMaps._refs.prop` to access\n   * the `Ref` instead of the potentially loaded/null value.\n   *\n   * This allows you to always get the ID or load the value manually.\n   *\n   * @example\n   * ```ts\n   * person._refs.pet.id; // => ID<Animal>\n   * person._refs.pet.value;\n   * // => Animal | null\n   * const pet = await person._refs.pet.load();\n   * ```\n   *\n   * @category Content\n   **/\n  get _refs(): Simplify<\n    {\n      [Key in CoKeys<this> as NonNullable<this[Key]> extends CoValue\n        ? Key\n        : never]?: RefIfCoValue<this[Key]>;\n    } & {\n      [Key in CoKeys<this> as this[Key] extends undefined\n        ? never\n        : this[Key] extends CoValue\n          ? Key\n          : never]: RefIfCoValue<this[Key]>;\n    }\n  > {\n    return makeRefs<CoKeys<this>>(\n      this,\n      (key) => this._raw.get(key as string) as unknown as ID<CoValue>,\n      () => {\n        const keys = this._raw.keys().filter((key) => {\n          const descriptor = this.getDescriptor(key as string);\n          return (\n            descriptor && descriptor !== \"json\" && isRefEncoded(descriptor)\n          );\n        }) as CoKeys<this>[];\n\n        return keys;\n      },\n      this._loadedAs,\n      (key) => this.getDescriptor(key as string) as RefEncoded<CoValue>,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) as any;\n  }\n\n  /** @internal */\n  public getEditFromRaw(\n    target: CoMap,\n    rawEdit: {\n      by: RawAccountID | AgentID;\n      tx: CojsonInternalTypes.TransactionID;\n      at: Date;\n      value?: JsonValue | undefined;\n    },\n    descriptor: Schema,\n    key: string,\n  ) {\n    return {\n      value:\n        descriptor === \"json\"\n          ? rawEdit.value\n          : \"encoded\" in descriptor\n            ? rawEdit.value === null || rawEdit.value === undefined\n              ? rawEdit.value\n              : descriptor.encoded.decode(rawEdit.value)\n            : accessChildById(target, rawEdit.value as string, descriptor),\n      ref:\n        descriptor !== \"json\" && isRefEncoded(descriptor)\n          ? new Ref(\n              rawEdit.value as ID<CoValue>,\n              target._loadedAs,\n              descriptor,\n              target,\n            )\n          : undefined,\n      get by() {\n        return (\n          rawEdit.by &&\n          accessChildById(target, rawEdit.by, {\n            ref: Account,\n            optional: false,\n          })\n        );\n      },\n      madeAt: rawEdit.at,\n      key,\n    };\n  }\n\n  /** @category Collaboration */\n  get _edits() {\n    const map = this;\n    return new Proxy(\n      {},\n      {\n        get(_target, key) {\n          const rawEdit = map._raw.lastEditAt(key as string);\n          if (!rawEdit) return undefined;\n\n          const descriptor = map.getDescriptor(key as string);\n\n          if (!descriptor) return undefined;\n\n          return {\n            ...map.getEditFromRaw(map, rawEdit, descriptor, key as string),\n            get all() {\n              return [...map._raw.editsAt(key as string)].map((rawEdit) =>\n                map.getEditFromRaw(map, rawEdit, descriptor, key as string),\n              );\n            },\n          };\n        },\n        ownKeys(_target) {\n          return map._raw.keys();\n        },\n        getOwnPropertyDescriptor(target, key) {\n          return {\n            value: Reflect.get(target, key),\n            writable: false,\n            enumerable: true,\n            configurable: true,\n          };\n        },\n      },\n    ) as {\n      [Key in CoKeys<this>]?: LastAndAllCoMapEdits<this[Key]>;\n    };\n  }\n\n  /** @internal */\n  constructor(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    options: { fromRaw: RawCoMap } | undefined,\n  ) {\n    super();\n\n    if (options) {\n      if (\"fromRaw\" in options) {\n        Object.defineProperties(this, {\n          id: {\n            value: options.fromRaw.id as unknown as ID<this>,\n            enumerable: false,\n          },\n          _raw: { value: options.fromRaw, enumerable: false },\n        });\n      } else {\n        throw new Error(\"Invalid CoMap constructor arguments\");\n      }\n    }\n\n    return new Proxy(this, CoMapProxyHandler as ProxyHandler<this>);\n  }\n\n  /**\n   * Create a new CoMap with the given initial values and owner.\n   *\n   * The owner (a Group or Account) determines access rights to the CoMap.\n   *\n   * The CoMap will immediately be persisted and synced to connected peers.\n   *\n   * @example\n   * ```ts\n   * const person = Person.create({\n   *   name: \"Alice\",\n   *   age: 42,\n   *   pet: cat,\n   * }, { owner: friendGroup });\n   * ```\n   *\n   * @category Creation\n   **/\n  static create<M extends CoMap>(\n    this: CoValueClass<M>,\n    init: Simplify<CoMapInit<M>>,\n    options?:\n      | {\n          owner: Account | Group;\n          unique?: CoValueUniqueness[\"uniqueness\"];\n        }\n      | Account\n      | Group,\n  ) {\n    const instance = new this();\n\n    const { owner, uniqueness } = parseCoValueCreateOptions(options);\n    const raw = instance.rawFromInit(init, owner, uniqueness);\n\n    Object.defineProperties(instance, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _raw: { value: raw, enumerable: false },\n    });\n\n    return instance;\n  }\n\n  /**\n   * Return a JSON representation of the `CoMap`\n   * @category Content\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(_key?: string, processedValues?: ID<CoValue>[]): any {\n    const result = {\n      id: this.id,\n      _type: this._type,\n    } as Record<string, any>;\n\n    for (const key of this._raw.keys()) {\n      const tKey = key as CoKeys<this>;\n      const descriptor = this.getDescriptor(tKey);\n\n      if (!descriptor) {\n        continue;\n      }\n\n      if (descriptor == \"json\" || \"encoded\" in descriptor) {\n        result[key] = this._raw.get(key);\n      } else if (isRefEncoded(descriptor)) {\n        const id = this._raw.get(key) as ID<CoValue>;\n\n        if (processedValues?.includes(id) || id === this.id) {\n          result[key] = { _circular: id };\n          continue;\n        }\n\n        const ref = this[tKey];\n\n        if (\n          ref &&\n          typeof ref === \"object\" &&\n          \"toJSON\" in ref &&\n          typeof ref.toJSON === \"function\"\n        ) {\n          const jsonedRef = ref.toJSON(tKey, [\n            ...(processedValues || []),\n            this.id,\n          ]);\n          result[key] = jsonedRef;\n        }\n      } else {\n        result[key] = undefined;\n      }\n    }\n\n    return result;\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  /**\n   * Create a new `RawCoMap` from an initialization object\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawFromInit<Fields extends object = Record<string, any>>(\n    init: Simplify<CoMapInit<Fields>> | undefined,\n    owner: Account | Group,\n    uniqueness?: CoValueUniqueness,\n  ) {\n    const rawOwner = owner._raw;\n\n    const rawInit = {} as {\n      [key in keyof Fields]: JsonValue | undefined;\n    };\n\n    if (init)\n      for (const key of Object.keys(init) as (keyof Fields)[]) {\n        const initValue = init[key as keyof typeof init];\n\n        const descriptor = this.getDescriptor(key as string);\n\n        if (!descriptor) {\n          continue;\n        }\n\n        if (descriptor === \"json\") {\n          rawInit[key] = initValue as JsonValue;\n        } else if (isRefEncoded(descriptor)) {\n          if (initValue) {\n            rawInit[key] = (initValue as unknown as CoValue).id;\n          }\n        } else if (\"encoded\" in descriptor) {\n          rawInit[key] = descriptor.encoded.encode(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            initValue as any,\n          );\n        }\n      }\n\n    return rawOwner.createMap(rawInit, null, \"private\", uniqueness);\n  }\n\n  getDescriptor(key: string) {\n    return this._schema?.[key] || this._schema?.[ItemsSym];\n  }\n\n  /**\n   * Declare a Record-like CoMap schema, by extending `CoMap.Record(...)` and passing the value schema using `co`. Keys are always `string`.\n   *\n   * @example\n   * ```ts\n   * import { coField, CoMap } from \"jazz-tools\";\n   *\n   * class ColorToFruitMap extends CoMap.Record(\n   *  coField.ref(Fruit)\n   * ) {}\n   *\n   * // assume we have map: ColorToFruitMap\n   * // and strawberry: Fruit\n   * map[\"red\"] = strawberry;\n   * ```\n   *\n   * @category Declaration\n   */\n  static Record<Value>(value: Value) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n    class RecordLikeCoMap extends CoMap {\n      [ItemsSym] = value;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n    interface RecordLikeCoMap extends Record<string, Value> {}\n\n    return RecordLikeCoMap;\n  }\n\n  /**\n   * Load a `CoMap` with a given ID, as a given account.\n   *\n   * `depth` specifies which (if any) fields that reference other CoValues to load as well before resolving.\n   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.\n   *\n   * You can pass `[]` or `{}` for shallowly loading only this CoMap, or `{ fieldA: depthA, fieldB: depthB }` for recursively loading referenced CoValues.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * @example\n   * ```ts\n   * const person = await Person.load(\n   *   \"co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax\",\n   *   { pet: {} }\n   * );\n   * ```\n   *\n   * @category Subscription & Loading\n   */\n  static load<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: CoValueClass<M>,\n    id: ID<M>,\n    options?: {\n      resolve?: RefsToResolveStrict<M, R>;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Resolved<M, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /**\n   * Load and subscribe to a `CoMap` with a given ID, as a given account.\n   *\n   * Automatically also subscribes to updates to all referenced/nested CoValues as soon as they are accessed in the listener.\n   *\n   * `depth` specifies which (if any) fields that reference other CoValues to load as well before calling `listener` for the first time.\n   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.\n   *\n   * You can pass `[]` or `{}` for shallowly loading only this CoMap, or `{ fieldA: depthA, fieldB: depthB }` for recursively loading referenced CoValues.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * Also see the `useCoState` hook to reactively subscribe to a CoValue in a React component.\n   *\n   * @example\n   * ```ts\n   * const unsub = Person.subscribe(\n   *   \"co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax\",\n   *   { pet: {} },\n   *   (person) => console.log(person)\n   * );\n   * ```\n   *\n   * @category Subscription & Loading\n   */\n  static subscribe<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: CoValueClass<M>,\n    id: ID<M>,\n    listener: (value: Resolved<M, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: CoValueClass<M>,\n    id: ID<M>,\n    options: SubscribeListenerOptions<M, R>,\n    listener: (value: Resolved<M, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<M extends CoMap, const R extends RefsToResolve<M>>(\n    this: CoValueClass<M>,\n    id: ID<M>,\n    ...args: SubscribeRestArgs<M, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<M, R>(this, id, options, listener);\n  }\n\n  static findUnique<M extends CoMap>(\n    this: CoValueClass<M>,\n    unique: CoValueUniqueness[\"uniqueness\"],\n    ownerID: ID<Account> | ID<Group>,\n    as?: Account | Group | AnonymousJazzAgent,\n  ) {\n    as ||= activeAccountContext.get();\n\n    const header = {\n      type: \"comap\" as const,\n      ruleset: {\n        type: \"ownedByGroup\" as const,\n        group: ownerID as RawCoID,\n      },\n      meta: null,\n      uniqueness: unique,\n    };\n    const crypto =\n      as._type === \"Anonymous\" ? as.node.crypto : as._raw.core.node.crypto;\n    return cojsonInternals.idforHeader(header, crypto) as ID<M>;\n  }\n\n  /**\n   * Given an already loaded `CoMap`, ensure that the specified fields are loaded to the specified depth.\n   *\n   * Works like `CoMap.load()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * @category Subscription & Loading\n   */\n  ensureLoaded<M extends CoMap, const R extends RefsToResolve<M>>(\n    this: M,\n    options: { resolve: RefsToResolveStrict<M, R> },\n  ): Promise<Resolved<M, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /**\n   * Given an already loaded `CoMap`, subscribe to updates to the `CoMap` and ensure that the specified fields are loaded to the specified depth.\n   *\n   * Works like `CoMap.subscribe()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * @category Subscription & Loading\n   **/\n  subscribe<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: M,\n    listener: (value: Resolved<M, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<M extends CoMap, const R extends RefsToResolve<M> = true>(\n    this: M,\n    options: { resolve?: RefsToResolveStrict<M, R> },\n    listener: (value: Resolved<M, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<M extends CoMap, const R extends RefsToResolve<M>>(\n    this: M,\n    ...args: SubscribeRestArgs<M, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue<M, R>(this, options, listener);\n  }\n\n  applyDiff<N extends Partial<CoMapInit<this>>>(newValues: N) {\n    for (const key in newValues) {\n      if (Object.prototype.hasOwnProperty.call(newValues, key)) {\n        const tKey = key as keyof typeof newValues & keyof this;\n        const descriptor = this.getDescriptor(key);\n\n        if (!descriptor) continue;\n\n        const newValue = newValues[tKey];\n        const currentValue = (this as unknown as N)[tKey];\n\n        if (descriptor === \"json\" || \"encoded\" in descriptor) {\n          if (currentValue !== newValue) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (this as any)[tKey] = newValue;\n          }\n        } else if (isRefEncoded(descriptor)) {\n          const currentId = (currentValue as CoValue | undefined)?.id;\n          const newId = (newValue as CoValue | undefined)?.id;\n          if (currentId !== newId) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (this as any)[tKey] = newValue;\n          }\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Wait for the `CoMap` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: { timeout?: number }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n\nexport type CoKeys<Map extends object> = Exclude<\n  keyof Map & string,\n  keyof CoMap\n>;\n\n/**\n * Force required ref fields to be non nullable\n *\n * Considering that:\n * - Optional refs are typed as coField<InstanceType<CoValueClass> | null | undefined>\n * - Required refs are typed as coField<InstanceType<CoValueClass> | null>\n *\n * This type works in two steps:\n * - Remove the null from both types\n * - Then we check if the input type accepts undefined, if positive we put the null union back\n *\n * So the optional refs stays unchanged while we safely remove the null union\n * from required refs\n *\n * This way required refs can be marked as required in the CoMapInit while\n * staying a nullable property for value access.\n *\n * Example:\n *\n * const map = MyCoMap.create({\n *   requiredRef: NestedMap.create({}) // null is not valid here\n * })\n *\n * map.requiredRef // this value is still nullable\n */\ntype ForceRequiredRef<V> = V extends InstanceType<CoValueClass> | null\n  ? NonNullable<V>\n  : V extends InstanceType<CoValueClass> | undefined\n    ? V | null\n    : V;\n\nexport type CoMapInit<Map extends object> = {\n  [Key in CoKeys<Map> as undefined extends Map[Key]\n    ? never\n    : Key]: ForceRequiredRef<Map[Key]>;\n} & {\n  [Key in CoKeys<Map>]?: ForceRequiredRef<Map[Key]>;\n};\n\n// TODO: cache handlers per descriptor for performance?\nconst CoMapProxyHandler: ProxyHandler<CoMap> = {\n  get(target, key, receiver) {\n    if (key === \"_schema\") {\n      return Reflect.get(target, key);\n    } else if (key in target) {\n      return Reflect.get(target, key, receiver);\n    } else {\n      if (typeof key !== \"string\") {\n        return undefined;\n      }\n\n      const descriptor = target.getDescriptor(key as string);\n\n      if (!descriptor) {\n        return undefined;\n      }\n\n      const raw = target._raw.get(key);\n\n      if (descriptor === \"json\") {\n        return raw;\n      } else if (\"encoded\" in descriptor) {\n        return raw === undefined ? undefined : descriptor.encoded.decode(raw);\n      } else if (isRefEncoded(descriptor)) {\n        return raw === undefined || raw === null\n          ? undefined\n          : accessChildByKey(target, raw as string, key);\n      }\n    }\n  },\n  set(target, key, value, receiver) {\n    if (\n      (typeof key === \"string\" || ItemsSym) &&\n      typeof value === \"object\" &&\n      value !== null &&\n      SchemaInit in value\n    ) {\n      (target.constructor as typeof CoMap)._schema ||= {};\n      (target.constructor as typeof CoMap)._schema[key] = value[SchemaInit];\n      return true;\n    }\n\n    const descriptor = target.getDescriptor(key as string);\n\n    if (!descriptor) return false;\n\n    if (typeof key === \"string\") {\n      if (descriptor === \"json\") {\n        target._raw.set(key, value);\n      } else if (\"encoded\" in descriptor) {\n        target._raw.set(key, descriptor.encoded.encode(value));\n      } else if (isRefEncoded(descriptor)) {\n        if (value === undefined) {\n          if (descriptor.optional) {\n            target._raw.set(key, null);\n          } else {\n            throw new Error(\n              `Cannot set required reference ${key} to undefined`,\n            );\n          }\n        } else if (value?.id) {\n          target._raw.set(key, value.id);\n        } else {\n          throw new Error(\n            `Cannot set reference ${key} to a non-CoValue. Got ${value}`,\n          );\n        }\n      }\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n  defineProperty(target, key, attributes) {\n    if (\n      \"value\" in attributes &&\n      typeof attributes.value === \"object\" &&\n      SchemaInit in attributes.value\n    ) {\n      (target.constructor as typeof CoMap)._schema ||= {};\n      (target.constructor as typeof CoMap)._schema[key as string] =\n        attributes.value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.defineProperty(target, key, attributes);\n    }\n  },\n  ownKeys(target) {\n    const keys = Reflect.ownKeys(target).filter((k) => k !== ItemsSym);\n\n    for (const key of target._raw.keys()) {\n      if (!keys.includes(key)) {\n        keys.push(key);\n      }\n    }\n\n    return keys;\n  },\n  getOwnPropertyDescriptor(target, key) {\n    if (key in target) {\n      return Reflect.getOwnPropertyDescriptor(target, key);\n    } else {\n      const descriptor = target.getDescriptor(key as string);\n\n      if (descriptor || key in target._raw.latest) {\n        return {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n        };\n      }\n    }\n  },\n  has(target, key) {\n    const descriptor = target.getDescriptor(key as string);\n\n    if (target._raw && typeof key === \"string\" && descriptor) {\n      return target._raw.get(key) !== undefined;\n    } else {\n      return Reflect.has(target, key);\n    }\n  },\n  deleteProperty(target, key) {\n    const descriptor = target.getDescriptor(key as string);\n\n    if (typeof key === \"string\" && descriptor) {\n      target._raw.delete(key);\n      return true;\n    } else {\n      return Reflect.deleteProperty(target, key);\n    }\n  },\n};\n\nRegisteredSchemas[\"CoMap\"] = CoMap;\n","import type { JsonValue, RawCoList } from \"cojson\";\nimport { ControlledAccount, RawAccount } from \"cojson\";\nimport { calcPatch } from \"fast-myers-diff\";\nimport type {\n  Account,\n  AnyAccountSchema,\n  CoValue,\n  CoValueClass,\n  CoValueFromRaw,\n  Group,\n  ID,\n  InstanceOfSchema,\n  RefEncoded,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Schema,\n  SchemaFor,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n} from \"../internal.js\";\nimport {\n  AnonymousJazzAgent,\n  ItemsSym,\n  Ref,\n  RegisteredSchemas,\n  SchemaInit,\n  accessChildByKey,\n  anySchemaToCoSchema,\n  coField,\n  coValuesCache,\n  ensureCoValueLoaded,\n  inspect,\n  isRefEncoded,\n  loadCoValueWithoutMe,\n  makeRefs,\n  parseCoValueCreateOptions,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n} from \"../internal.js\";\n\n/**\n * CoLists are collaborative versions of plain arrays.\n *\n * @categoryDescription Content\n * You can access items on a `CoList` as if they were normal items on a plain array, using `[]` notation, etc.\n *\n * Since `CoList` is a subclass of `Array`, you can use all the normal array methods like `push`, `pop`, `splice`, etc.\n *\n * ```ts\n * colorList[0];\n * colorList[3] = \"yellow\";\n * colorList.push(\"Kawazaki Green\");\n * colorList.splice(1, 1);\n * ```\n *\n * @category CoValues\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class CoList<out Item = any> extends Array<Item> implements CoValue {\n  /**\n   * Declare a `CoList` by subclassing `CoList.Of(...)` and passing the item schema using `co`.\n   *\n   * @example\n   * ```ts\n   * class ColorList extends CoList.Of(\n   *   coField.string\n   * ) {}\n   * class AnimalList extends CoList.Of(\n   *   coField.ref(Animal)\n   * ) {}\n   * ```\n   *\n   * @category Declaration\n   */\n  static Of<Item>(item: Item): typeof CoList<Item> {\n    // TODO: cache superclass for item class\n    return class CoListOf extends CoList<Item> {\n      [coField.items] = item;\n    };\n  }\n\n  /**\n   * @ignore\n   * @deprecated Use UPPERCASE `CoList.Of` instead! */\n  static of(..._args: never): never {\n    throw new Error(\"Can't use Array.of with CoLists\");\n  }\n\n  /**\n   * The ID of this `CoList`\n   * @category Content */\n  declare id: ID<this>;\n  /** @category Type Helpers */\n  declare _type: \"CoList\";\n  static {\n    this.prototype._type = \"CoList\";\n  }\n  /** @category Internals */\n  declare _raw: RawCoList;\n  /** @category Internals */\n  declare _instanceID: string;\n\n  /** @internal This is only a marker type and doesn't exist at runtime */\n  [ItemsSym]!: Item;\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  /** @internal */\n  get _schema(): {\n    [ItemsSym]: SchemaFor<Item> | any;\n  } {\n    return (this.constructor as typeof CoList)._schema;\n  }\n\n  /** @category Collaboration */\n  get _owner(): Account | Group {\n    return this._raw.group instanceof RawAccount\n      ? anySchemaToCoSchema(RegisteredSchemas[\"Account\"]).fromRaw(\n          this._raw.group,\n        )\n      : RegisteredSchemas[\"Group\"].fromRaw(this._raw.group);\n  }\n\n  /**\n   * If a `CoList`'s items are a `coField.ref(...)`, you can use `coList._refs[i]` to access\n   * the `Ref` instead of the potentially loaded/null value.\n   *\n   * This allows you to always get the ID or load the value manually.\n   *\n   * @example\n   * ```ts\n   * animals._refs[0].id; // => ID<Animal>\n   * animals._refs[0].value;\n   * // => Animal | null\n   * const animal = await animals._refs[0].load();\n   * ```\n   *\n   * @category Content\n   **/\n  get _refs(): {\n    [idx: number]: Exclude<Item, null> extends CoValue\n      ? Ref<Exclude<Item, null>>\n      : never;\n  } & {\n    length: number;\n    [Symbol.iterator](): IterableIterator<\n      Exclude<Item, null> extends CoValue ? Ref<Exclude<Item, null>> : never\n    >;\n  } {\n    return makeRefs<number>(\n      this,\n      (idx) => this._raw.get(idx) as unknown as ID<CoValue>,\n      () => Array.from({ length: this._raw.entries().length }, (_, idx) => idx),\n      this._loadedAs,\n      (_idx) => this._schema[ItemsSym] as RefEncoded<CoValue>,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) as any;\n  }\n\n  get _edits(): {\n    [idx: number]: {\n      value?: Item;\n      ref?: Item extends CoValue ? Ref<Item> : never;\n      by: Account | null;\n      madeAt: Date;\n    };\n  } {\n    throw new Error(\"Not implemented\");\n  }\n\n  get _loadedAs() {\n    const agent = this._raw.core.node.getCurrentAgent();\n\n    if (agent instanceof ControlledAccount) {\n      return coValuesCache.get(agent.account, () =>\n        anySchemaToCoSchema(RegisteredSchemas[\"Account\"]).fromRaw(\n          agent.account,\n        ),\n      );\n    }\n\n    return new AnonymousJazzAgent(this._raw.core.node);\n  }\n\n  static get [Symbol.species]() {\n    return Array;\n  }\n\n  getItemsDescriptor() {\n    return this._schema?.[ItemsSym];\n  }\n\n  constructor(options: { fromRaw: RawCoList } | undefined) {\n    super();\n\n    Object.defineProperty(this, \"_instanceID\", {\n      value: `instance-${Math.random().toString(36).slice(2)}`,\n      enumerable: false,\n    });\n\n    if (options && \"fromRaw\" in options) {\n      Object.defineProperties(this, {\n        id: {\n          value: options.fromRaw.id,\n          enumerable: false,\n        },\n        _raw: { value: options.fromRaw, enumerable: false },\n      });\n    }\n\n    return new Proxy(this, CoListProxyHandler as ProxyHandler<this>);\n  }\n\n  /**\n   * Create a new CoList with the given initial values and owner.\n   *\n   * The owner (a Group or Account) determines access rights to the CoMap.\n   *\n   * The CoList will immediately be persisted and synced to connected peers.\n   *\n   * @example\n   * ```ts\n   * const colours = ColorList.create(\n   *   [\"red\", \"green\", \"blue\"],\n   *   { owner: me }\n   * );\n   * const animals = AnimalList.create(\n   *   [cat, dog, fish],\n   *   { owner: me }\n   * );\n   * ```\n   *\n   * @category Creation\n   **/\n  static create<L extends CoList>(\n    this: CoValueClass<L>,\n    items: L[number][],\n    options?: { owner: Account | Group } | Account | Group,\n  ) {\n    const { owner } = parseCoValueCreateOptions(options);\n    const instance = new this({ init: items, owner });\n    const raw = owner._raw.createList(\n      toRawItems(items, instance._schema[ItemsSym]),\n    );\n\n    Object.defineProperties(instance, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _raw: { value: raw, enumerable: false },\n    });\n\n    return instance;\n  }\n\n  push(...items: Item[]): number {\n    this._raw.appendItems(\n      toRawItems(items, this._schema[ItemsSym]),\n      undefined,\n      \"private\",\n    );\n\n    return this._raw.entries().length;\n  }\n\n  unshift(...items: Item[]): number {\n    for (const item of toRawItems(items as Item[], this._schema[ItemsSym])) {\n      this._raw.prepend(item);\n    }\n\n    return this._raw.entries().length;\n  }\n\n  pop(): Item | undefined {\n    const last = this[this.length - 1];\n\n    this._raw.delete(this.length - 1);\n\n    return last;\n  }\n\n  shift(): Item | undefined {\n    const first = this[0];\n\n    this._raw.delete(0);\n\n    return first;\n  }\n\n  /**\n   * Splice the `CoList` at a given index.\n   *\n   * @param start - The index to start the splice.\n   * @param deleteCount - The number of items to delete.\n   * @param items - The items to insert.\n   */\n  splice(start: number, deleteCount: number, ...items: Item[]): Item[] {\n    const deleted = this.slice(start, start + deleteCount);\n\n    for (\n      let idxToDelete = start + deleteCount - 1;\n      idxToDelete >= start;\n      idxToDelete--\n    ) {\n      this._raw.delete(idxToDelete);\n    }\n\n    const rawItems = toRawItems(items as Item[], this._schema[ItemsSym]);\n\n    // If there are no items to insert, return the deleted items\n    if (rawItems.length === 0) {\n      return deleted;\n    }\n\n    // Fast path for single item insertion\n    if (rawItems.length === 1) {\n      const item = rawItems[0];\n      if (item === undefined) return deleted;\n      if (start === 0) {\n        this._raw.prepend(item);\n      } else {\n        this._raw.append(item, Math.max(start - 1, 0));\n      }\n      return deleted;\n    }\n\n    // Handle multiple items\n    if (start === 0) {\n      // Iterate in reverse order without creating a new array\n      for (let i = rawItems.length - 1; i >= 0; i--) {\n        const item = rawItems[i];\n        if (item === undefined) continue;\n        this._raw.prepend(item);\n      }\n    } else {\n      let appendAfter = Math.max(start - 1, 0);\n      for (const item of rawItems) {\n        if (item === undefined) continue;\n        this._raw.append(item, appendAfter);\n        appendAfter++;\n      }\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Modify the `CoList` to match another list, where the changes are managed internally.\n   *\n   * @param result - The resolved list of items.\n   */\n  applyDiff(result: Item[]) {\n    const current = this._raw.asArray() as Item[];\n    const comparator = isRefEncoded(this._schema[ItemsSym])\n      ? (aIdx: number, bIdx: number) => {\n          return (\n            (current[aIdx] as CoValue)?.id === (result[bIdx] as CoValue)?.id\n          );\n        }\n      : undefined;\n\n    const patches = [...calcPatch(current, result, comparator)];\n    for (const [from, to, insert] of patches.reverse()) {\n      this.splice(from, to - from, ...insert);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(_key?: string, seenAbove?: ID<CoValue>[]): any[] {\n    const itemDescriptor = this._schema[ItemsSym] as Schema;\n    if (itemDescriptor === \"json\") {\n      return this._raw.asArray();\n    } else if (\"encoded\" in itemDescriptor) {\n      return this._raw.asArray().map((e) => itemDescriptor.encoded.encode(e));\n    } else if (isRefEncoded(itemDescriptor)) {\n      return this.map((item, idx) =>\n        seenAbove?.includes((item as CoValue)?.id)\n          ? { _circular: (item as CoValue).id }\n          : (item as unknown as CoValue)?.toJSON(idx + \"\", [\n              ...(seenAbove || []),\n              this.id,\n            ]),\n      );\n    } else {\n      return [];\n    }\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  /** @category Internals */\n  static fromRaw<V extends CoList>(\n    this: CoValueClass<V> & typeof CoList,\n    raw: RawCoList,\n  ) {\n    return new this({ fromRaw: raw });\n  }\n\n  /** @internal */\n  static schema<V extends CoList>(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this: { new (...args: any): V } & typeof CoList,\n    def: { [ItemsSym]: V[\"_schema\"][ItemsSym] },\n  ) {\n    this._schema ||= {};\n    Object.assign(this._schema, def);\n  }\n\n  /**\n   * Load a `CoList` with a given ID, as a given account.\n   *\n   * `depth` specifies if item CoValue references should be loaded as well before resolving.\n   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.\n   *\n   * You can pass `[]` or for shallowly loading only this CoList, or `[itemDepth]` for recursively loading referenced CoValues.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * @example\n   * ```ts\n   * const animalsWithVets =\n   *   await ListOfAnimals.load(\n   *     \"co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax\",\n   *     me,\n   *     [{ vet: {} }]\n   *   );\n   * ```\n   *\n   * @category Subscription & Loading\n   */\n  static load<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: CoValueClass<L>,\n    id: ID<L>,\n    options?: {\n      resolve?: RefsToResolveStrict<L, R>;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Resolved<L, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /**\n   * Load and subscribe to a `CoList` with a given ID, as a given account.\n   *\n   * Automatically also subscribes to updates to all referenced/nested CoValues as soon as they are accessed in the listener.\n   *\n   * `depth` specifies if item CoValue references should be loaded as well before calling `listener` for the first time.\n   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.\n   *\n   * You can pass `[]` or for shallowly loading only this CoList, or `[itemDepth]` for recursively loading referenced CoValues.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * Also see the `useCoState` hook to reactively subscribe to a CoValue in a React component.\n   *\n   * @example\n   * ```ts\n   * const unsub = ListOfAnimals.subscribe(\n   *   \"co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax\",\n   *   me,\n   *   { vet: {} },\n   *   (animalsWithVets) => console.log(animalsWithVets)\n   * );\n   * ```\n   *\n   * @category Subscription & Loading\n   */\n  static subscribe<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: CoValueClass<L>,\n    id: ID<L>,\n    listener: (value: Resolved<L, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: CoValueClass<L>,\n    id: ID<L>,\n    options: SubscribeListenerOptions<L, R>,\n    listener: (value: Resolved<L, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<L extends CoList, const R extends RefsToResolve<L>>(\n    this: CoValueClass<L>,\n    id: ID<L>,\n    ...args: SubscribeRestArgs<L, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<L, R>(this, id, options, listener);\n  }\n\n  /**\n   * Given an already loaded `CoList`, ensure that items are loaded to the specified depth.\n   *\n   * Works like `CoList.load()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * @category Subscription & Loading\n   */\n  ensureLoaded<L extends CoList, const R extends RefsToResolve<L>>(\n    this: L,\n    options: { resolve: RefsToResolveStrict<L, R> },\n  ): Promise<Resolved<L, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /**\n   * Given an already loaded `CoList`, subscribe to updates to the `CoList` and ensure that items are loaded to the specified depth.\n   *\n   * Works like `CoList.subscribe()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * @category Subscription & Loading\n   **/\n  subscribe<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: L,\n    listener: (value: Resolved<L, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<L extends CoList, const R extends RefsToResolve<L> = true>(\n    this: L,\n    options: { resolve?: RefsToResolveStrict<L, R> },\n    listener: (value: Resolved<L, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<L extends CoList, const R extends RefsToResolve<L>>(\n    this: L,\n    ...args: SubscribeRestArgs<L, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue(this, options, listener);\n  }\n\n  /** @category Type Helpers */\n  castAs<Cl extends CoValueClass & CoValueFromRaw<CoValue>>(\n    cl: Cl,\n  ): InstanceType<Cl> {\n    return cl.fromRaw(this._raw) as InstanceType<Cl>;\n  }\n\n  /**\n   * Wait for the `CoList` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: { timeout?: number }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n\n/**\n * Convert an array of items to a raw array of items.\n * @param items - The array of items to convert.\n * @param itemDescriptor - The descriptor of the items.\n * @returns The raw array of items.\n */\nfunction toRawItems<Item>(items: Item[], itemDescriptor: Schema) {\n  const rawItems =\n    itemDescriptor === \"json\"\n      ? (items as JsonValue[])\n      : \"encoded\" in itemDescriptor\n        ? items?.map((e) => itemDescriptor.encoded.encode(e))\n        : isRefEncoded(itemDescriptor)\n          ? items?.map((v) => {\n              if (!v) return null;\n\n              return (v as unknown as CoValue).id;\n            })\n          : (() => {\n              throw new Error(\"Invalid element descriptor\");\n            })();\n  return rawItems;\n}\n\nconst CoListProxyHandler: ProxyHandler<CoList> = {\n  get(target, key, receiver) {\n    if (typeof key === \"string\" && !isNaN(+key)) {\n      const itemDescriptor = target._schema[ItemsSym] as Schema;\n      const rawValue = target._raw.get(Number(key));\n      if (itemDescriptor === \"json\") {\n        return rawValue;\n      } else if (\"encoded\" in itemDescriptor) {\n        return rawValue === undefined\n          ? undefined\n          : itemDescriptor.encoded.decode(rawValue);\n      } else if (isRefEncoded(itemDescriptor)) {\n        return rawValue === undefined || rawValue === null\n          ? undefined\n          : accessChildByKey(target, rawValue as string, key);\n      }\n    } else if (key === \"length\") {\n      return target._raw.entries().length;\n    } else {\n      return Reflect.get(target, key, receiver);\n    }\n  },\n  set(target, key, value, receiver) {\n    if (key === ItemsSym && typeof value === \"object\" && SchemaInit in value) {\n      (target.constructor as typeof CoList)._schema ||= {};\n      (target.constructor as typeof CoList)._schema[ItemsSym] =\n        value[SchemaInit];\n      return true;\n    }\n    if (typeof key === \"string\" && !isNaN(+key)) {\n      const itemDescriptor = target._schema[ItemsSym] as Schema;\n      let rawValue;\n      if (itemDescriptor === \"json\") {\n        rawValue = value;\n      } else if (\"encoded\" in itemDescriptor) {\n        rawValue = itemDescriptor.encoded.encode(value);\n      } else if (isRefEncoded(itemDescriptor)) {\n        if (value === undefined) {\n          if (itemDescriptor.optional) {\n            rawValue = null;\n          } else {\n            throw new Error(\n              `Cannot set required reference ${key} to undefined`,\n            );\n          }\n        } else if (value?.id) {\n          rawValue = value.id;\n        } else {\n          throw new Error(\n            `Cannot set reference ${key} to a non-CoValue. Got ${value}`,\n          );\n        }\n      }\n      target._raw.replace(Number(key), rawValue);\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n  defineProperty(target, key, descriptor) {\n    if (\n      descriptor.value &&\n      key === ItemsSym &&\n      typeof descriptor.value === \"object\" &&\n      SchemaInit in descriptor.value\n    ) {\n      (target.constructor as typeof CoList)._schema ||= {};\n      (target.constructor as typeof CoList)._schema[ItemsSym] =\n        descriptor.value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.defineProperty(target, key, descriptor);\n    }\n  },\n  has(target, key) {\n    if (typeof key === \"string\" && !isNaN(+key)) {\n      return Number(key) < target._raw.entries().length;\n    } else {\n      return Reflect.has(target, key);\n    }\n  },\n};\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport type {\n  AgentID,\n  BinaryStreamInfo,\n  CojsonInternalTypes,\n  JsonValue,\n  RawAccountID,\n  RawBinaryCoStream,\n  RawCoStream,\n  SessionID,\n} from \"cojson\";\nimport { MAX_RECOMMENDED_TX_SIZE, cojsonInternals } from \"cojson\";\nimport type {\n  AnonymousJazzAgent,\n  AnyAccountSchema,\n  CoValue,\n  CoValueClass,\n  Group,\n  ID,\n  InstanceOfSchema,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Schema,\n  SchemaFor,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n} from \"../internal.js\";\nimport {\n  Account,\n  CoValueBase,\n  ItemsSym,\n  Ref,\n  RegisteredSchemas,\n  SchemaInit,\n  accessChildById,\n  anySchemaToCoSchema,\n  coField,\n  ensureCoValueLoaded,\n  inspect,\n  isRefEncoded,\n  loadCoValueWithoutMe,\n  parseCoValueCreateOptions,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n} from \"../internal.js\";\n\n/** @deprecated Use CoFeedEntry instead */\nexport type CoStreamEntry<Item> = CoFeedEntry<Item>;\n\nexport type CoFeedEntry<Item> = SingleCoFeedEntry<Item> & {\n  all: IterableIterator<SingleCoFeedEntry<Item>>;\n};\n\n/** @deprecated Use SingleCoFeedEntry instead */\nexport type SingleCoStreamEntry<Item> = SingleCoFeedEntry<Item>;\n\nexport type SingleCoFeedEntry<Item> = {\n  value: NonNullable<Item> extends CoValue ? NonNullable<Item> | null : Item;\n  ref: NonNullable<Item> extends CoValue ? Ref<NonNullable<Item>> : never;\n  by: Account | null;\n  madeAt: Date;\n  tx: CojsonInternalTypes.TransactionID;\n};\n\n/** @deprecated Use CoFeed instead */\nexport { CoFeed as CoStream };\n\n/**\n * CoFeeds are collaborative logs of data.\n *\n * @categoryDescription Content\n * They are similar to `CoList`s, but with a few key differences:\n * - They are append-only\n * - They consist of several internal append-only logs, one per account session (tab, device, app instance, etc.)\n * - They expose those as a per-account aggregated view (default) or a precise per-session view\n *\n * ```ts\n * favDog.push(\"Poodle\");\n * favDog.push(\"Schnowzer\");\n * ```\n *\n * @category CoValues\n */\nexport class CoFeed<out Item = any> extends CoValueBase implements CoValue {\n  /**\n   * Declare a `CoFeed` by subclassing `CoFeed.Of(...)` and passing the item schema using a `co` primitive or a `coField.ref`.\n   *\n   * @example\n   * ```ts\n   * class ColorFeed extends CoFeed.Of(coField.string) {}\n   * class AnimalFeed extends CoFeed.Of(coField.ref(Animal)) {}\n   * ```\n   *\n   * @category Declaration\n   */\n  static Of<Item>(item: Item): typeof CoFeed<Item> {\n    const cls = class CoFeedOf extends CoFeed<Item> {\n      [coField.items] = item;\n    };\n\n    cls._schema ||= {};\n    cls._schema[ItemsSym] = (item as any)[SchemaInit];\n\n    return cls;\n  }\n\n  /**\n   * The ID of this `CoFeed`\n   * @category Content */\n  declare id: ID<this>;\n  /** @category Type Helpers */\n  declare _type: \"CoStream\";\n  static {\n    this.prototype._type = \"CoStream\";\n  }\n  /** @category Internals */\n  declare _raw: RawCoStream;\n\n  /** @internal This is only a marker type and doesn't exist at runtime */\n  [ItemsSym]!: Item;\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  /** @internal */\n  get _schema(): {\n    [ItemsSym]: SchemaFor<Item> | any;\n  } {\n    return (this.constructor as typeof CoFeed)._schema;\n  }\n  /**\n   * The current account's view of this `CoFeed`\n   * @category Content\n   */\n  get byMe(): CoFeedEntry<Item> | undefined {\n    if (this._loadedAs._type === \"Account\") {\n      return this.perAccount[this._loadedAs.id];\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * The per-account view of this `CoFeed`\n   *\n   * @example\n   * ```ts\n   * // Access entries directly by account ID\n   * const aliceEntries = feed[aliceAccount.id];\n   * console.log(aliceEntries.value); // Latest value from Alice\n   *\n   * // Iterate through all accounts' entries\n   * for (const [accountId, entries] of Object.entries(feed)) {\n   *   console.log(`Latest entry from ${accountId}:`, entries.value);\n   *\n   *   // Access all entries from this account\n   *   for (const entry of entries.all) {\n   *     console.log(`Entry made at ${entry.madeAt}:`, entry.value);\n   *   }\n   * }\n   * ```\n   *\n   * @category Content\n   */\n  get perAccount(): {\n    [key: ID<Account>]: CoFeedEntry<Item>;\n  } {\n    return new Proxy({}, CoStreamPerAccountProxyHandler(this)) as any;\n  }\n\n  /**\n   * The per-session view of this `CoFeed`\n   * @category Content\n   */\n  get perSession(): {\n    [key: SessionID]: CoFeedEntry<Item>;\n  } {\n    return new Proxy(\n      {},\n      CoStreamPerSessionProxyHandler(this, this) as any,\n    ) as any;\n  }\n\n  /**\n   * The current session's view of this `CoFeed`\n   *\n   * This is a shortcut for `this.perSession` where the session ID is the current session ID.\n   *\n   * @category Content\n   */\n  get inCurrentSession(): CoFeedEntry<Item> | undefined {\n    if (this._loadedAs._type === \"Account\") {\n      return this.perSession[this._loadedAs.sessionID!];\n    } else {\n      return undefined;\n    }\n  }\n\n  constructor(\n    options:\n      | { init: Item[]; owner: Account | Group }\n      | { fromRaw: RawCoStream },\n  ) {\n    super();\n\n    if (options && \"fromRaw\" in options) {\n      Object.defineProperties(this, {\n        id: {\n          value: options.fromRaw.id,\n          enumerable: false,\n        },\n        _raw: { value: options.fromRaw, enumerable: false },\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Create a new `CoFeed`\n   * @category Creation\n   */\n  static create<S extends CoFeed>(\n    this: CoValueClass<S>,\n    init: S extends CoFeed<infer Item> ? Item[] : never,\n    options?: { owner: Account | Group } | Account | Group,\n  ) {\n    const { owner } = parseCoValueCreateOptions(options);\n    const instance = new this({ init, owner });\n    const raw = owner._raw.createStream();\n\n    Object.defineProperties(instance, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _raw: { value: raw, enumerable: false },\n    });\n\n    if (init) {\n      instance.push(...init);\n    }\n    return instance;\n  }\n\n  getItemsDescriptor() {\n    return this._schema?.[ItemsSym];\n  }\n\n  /**\n   * Push items to this `CoFeed`\n   *\n   * Items are appended to the current session's log. Each session (tab, device, app instance)\n   * maintains its own append-only log, which is then aggregated into the per-account view.\n   *\n   * @example\n   * ```ts\n   * // Adds items to current session's log\n   * feed.push(\"item1\", \"item2\");\n   *\n   * // View items from current session\n   * console.log(feed.inCurrentSession);\n   *\n   * // View aggregated items from all sessions for current account\n   * console.log(feed.byMe);\n   * ```\n   *\n   * @category Content\n   */\n  push(...items: Item[]) {\n    for (const item of items) {\n      this.pushItem(item);\n    }\n  }\n\n  private pushItem(item: Item) {\n    const itemDescriptor = this._schema[ItemsSym] as Schema;\n\n    if (itemDescriptor === \"json\") {\n      this._raw.push(item as JsonValue);\n    } else if (\"encoded\" in itemDescriptor) {\n      this._raw.push(itemDescriptor.encoded.encode(item));\n    } else if (isRefEncoded(itemDescriptor)) {\n      this._raw.push((item as unknown as CoValue).id);\n    }\n  }\n\n  /**\n   * Get a JSON representation of the `CoFeed`\n   * @category\n   */\n  toJSON(): {\n    id: string;\n    _type: \"CoStream\";\n    [key: string]: unknown;\n    in: { [key: string]: unknown };\n  } {\n    const itemDescriptor = this._schema[ItemsSym] as Schema;\n    const mapper =\n      itemDescriptor === \"json\"\n        ? (v: unknown) => v\n        : \"encoded\" in itemDescriptor\n          ? itemDescriptor.encoded.encode\n          : (v: unknown) => v && (v as CoValue).id;\n\n    return {\n      id: this.id,\n      _type: this._type,\n      ...Object.fromEntries(\n        Object.entries(this).map(([account, entry]) => [\n          account,\n          mapper(entry.value),\n        ]),\n      ),\n      in: Object.fromEntries(\n        Object.entries(this.perSession).map(([session, entry]) => [\n          session,\n          mapper(entry.value),\n        ]),\n      ),\n    };\n  }\n\n  /** @internal */\n  [inspect](): {\n    id: string;\n    _type: \"CoStream\";\n    [key: string]: unknown;\n    in: { [key: string]: unknown };\n  } {\n    return this.toJSON();\n  }\n\n  /** @internal */\n  static schema<V extends CoFeed>(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this: { new (...args: any): V } & typeof CoFeed,\n    def: { [ItemsSym]: V[\"_schema\"][ItemsSym] },\n  ) {\n    this._schema ||= {};\n    Object.assign(this._schema, def);\n  }\n\n  /**\n   * Load a `CoFeed`\n   * @category Subscription & Loading\n   */\n  static load<F extends CoFeed, const R extends RefsToResolve<F> = true>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    options: {\n      resolve?: RefsToResolveStrict<F, R>;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Resolved<F, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /**\n   * Subscribe to a `CoFeed`, when you have an ID but don't have a `CoFeed` instance yet\n   * @category Subscription & Loading\n   */\n  static subscribe<F extends CoFeed, const R extends RefsToResolve<F> = true>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<F extends CoFeed, const R extends RefsToResolve<F> = true>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    options: SubscribeListenerOptions<F, R>,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    ...args: SubscribeRestArgs<F, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<F, R>(this, id, options, listener);\n  }\n\n  /**\n   * Ensure a `CoFeed` is loaded to the specified depth\n   *\n   * @returns A new instance of the same CoFeed that's loaded to the specified depth\n   * @category Subscription & Loading\n   */\n  ensureLoaded<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: F,\n    options?: { resolve?: RefsToResolveStrict<F, R> },\n  ): Promise<Resolved<F, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /**\n   * An instance method to subscribe to an existing `CoFeed`\n   *\n   * No need to provide an ID or Account since they're already part of the instance.\n   * @category Subscription & Loading\n   */\n  subscribe<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: F,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: F,\n    options: { resolve?: RefsToResolveStrict<F, R> },\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<F extends CoFeed, const R extends RefsToResolve<F>>(\n    this: F,\n    ...args: SubscribeRestArgs<F, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue(this, options, listener);\n  }\n\n  /**\n   * Wait for the `CoFeed` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: {\n    timeout?: number;\n  }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n\n/**\n * Converts a raw stream entry into a formatted CoFeed entry with proper typing and accessors.\n * @internal\n */\nfunction entryFromRawEntry<Item>(\n  accessFrom: CoValue,\n  rawEntry: {\n    by: RawAccountID | AgentID;\n    tx: CojsonInternalTypes.TransactionID;\n    at: Date;\n    value: JsonValue;\n  },\n  loadedAs: Account | AnonymousJazzAgent,\n  accountID: ID<Account> | undefined,\n  itemField: Schema,\n): Omit<CoFeedEntry<Item>, \"all\"> {\n  return {\n    get value(): NonNullable<Item> extends CoValue\n      ? (CoValue & Item) | null\n      : Item {\n      if (itemField === \"json\") {\n        return rawEntry.value as NonNullable<Item> extends CoValue\n          ? (CoValue & Item) | null\n          : Item;\n      } else if (\"encoded\" in itemField) {\n        return itemField.encoded.decode(rawEntry.value);\n      } else if (isRefEncoded(itemField)) {\n        return accessChildById(\n          accessFrom,\n          rawEntry.value as string,\n          itemField,\n        ) as NonNullable<Item> extends CoValue ? (CoValue & Item) | null : Item;\n      } else {\n        throw new Error(\"Invalid item field schema\");\n      }\n    },\n    get ref(): NonNullable<Item> extends CoValue\n      ? Ref<NonNullable<Item>>\n      : never {\n      if (itemField !== \"json\" && isRefEncoded(itemField)) {\n        const rawId = rawEntry.value;\n        return new Ref(\n          rawId as unknown as ID<CoValue>,\n          loadedAs,\n          itemField,\n          accessFrom,\n        ) as NonNullable<Item> extends CoValue ? Ref<NonNullable<Item>> : never;\n      } else {\n        return undefined as never;\n      }\n    },\n    get by() {\n      return (\n        accountID &&\n        accessChildById(accessFrom, accountID, {\n          ref: Account,\n          optional: false,\n        })\n      );\n    },\n    madeAt: rawEntry.at,\n    tx: rawEntry.tx,\n  };\n}\n\n/**\n * The proxy handler for `CoFeed` instances\n * @internal\n */\nexport const CoStreamPerAccountProxyHandler = (\n  innerTarget: CoFeed,\n): ProxyHandler<{}> => ({\n  get(_target, key, receiver) {\n    if (typeof key === \"string\" && key.startsWith(\"co_\")) {\n      const rawEntry = innerTarget._raw.lastItemBy(key as RawAccountID);\n\n      if (!rawEntry) return;\n      const entry = entryFromRawEntry(\n        receiver,\n        rawEntry,\n        innerTarget._loadedAs,\n        key as unknown as ID<Account>,\n        innerTarget._schema[ItemsSym],\n      );\n\n      Object.defineProperty(entry, \"all\", {\n        get: () => {\n          const allRawEntries = innerTarget._raw.itemsBy(key as RawAccountID);\n          return (function* () {\n            while (true) {\n              const rawEntry = allRawEntries.next();\n              if (rawEntry.done) return;\n              yield entryFromRawEntry(\n                receiver,\n                rawEntry.value,\n                innerTarget._loadedAs,\n                key as unknown as ID<Account>,\n                innerTarget._schema[ItemsSym],\n              );\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          })() satisfies IterableIterator<SingleCoFeedEntry<any>>;\n        },\n      });\n\n      return entry;\n    } else {\n      return Reflect.get(innerTarget, key, receiver);\n    }\n  },\n  ownKeys(_target) {\n    return Array.from(innerTarget._raw.accounts());\n  },\n  getOwnPropertyDescriptor(_target, key) {\n    if (typeof key === \"string\" && key.startsWith(\"co_\")) {\n      return {\n        configurable: true,\n        enumerable: true,\n        writable: false,\n      };\n    } else {\n      return Reflect.getOwnPropertyDescriptor(innerTarget, key);\n    }\n  },\n});\n\n/**\n * The proxy handler for the per-session view of a `CoFeed`\n * @internal\n */\nconst CoStreamPerSessionProxyHandler = (\n  innerTarget: CoFeed,\n  accessFrom: CoFeed,\n): ProxyHandler<Record<string, never>> => ({\n  get(_target, key, receiver) {\n    if (typeof key === \"string\" && key.includes(\"session\")) {\n      const sessionID = key as SessionID;\n      const rawEntry = innerTarget._raw.lastItemIn(sessionID);\n\n      if (!rawEntry) return;\n      const by = cojsonInternals.accountOrAgentIDfromSessionID(sessionID);\n\n      const entry = entryFromRawEntry(\n        accessFrom,\n        rawEntry,\n        innerTarget._loadedAs,\n        cojsonInternals.isAccountID(by)\n          ? (by as unknown as ID<Account>)\n          : undefined,\n        innerTarget._schema[ItemsSym],\n      );\n\n      Object.defineProperty(entry, \"all\", {\n        get: () => {\n          const allRawEntries = innerTarget._raw.itemsIn(sessionID);\n          return (function* () {\n            while (true) {\n              const rawEntry = allRawEntries.next();\n              if (rawEntry.done) return;\n              yield entryFromRawEntry(\n                accessFrom,\n                rawEntry.value,\n                innerTarget._loadedAs,\n                cojsonInternals.isAccountID(by)\n                  ? (by as unknown as ID<Account>)\n                  : undefined,\n                innerTarget._schema[ItemsSym],\n              );\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          })() satisfies IterableIterator<SingleCoFeedEntry<any>>;\n        },\n      });\n\n      return entry;\n    } else {\n      return Reflect.get(innerTarget, key, receiver);\n    }\n  },\n  ownKeys() {\n    return innerTarget._raw.sessions();\n  },\n  getOwnPropertyDescriptor(target, key) {\n    if (typeof key === \"string\" && key.startsWith(\"co_\")) {\n      return {\n        configurable: true,\n        enumerable: true,\n        writable: false,\n      };\n    } else {\n      return Reflect.getOwnPropertyDescriptor(target, key);\n    }\n  },\n});\n\n/** @deprecated Use FileStream instead */\nexport { FileStream as BinaryCoStream };\n\n/**\n * FileStreams are `CoFeed`s that contain binary data, collaborative versions of `Blob`s.\n *\n * @categoryDescription Declaration\n * `FileStream` can be referenced in schemas.\n *\n * ```ts\n * import { coField, FileStream } from \"jazz-tools\";\n *\n * class MyCoMap extends CoMap {\n *   file = coField.ref(FileStream);\n * }\n * ```\n *\n * @category CoValues\n */\nexport class FileStream extends CoValueBase implements CoValue {\n  /**\n   * The ID of this `FileStream`\n   * @category Content\n   */\n  declare id: ID<this>;\n  /** @category Type Helpers */\n  declare _type: \"BinaryCoStream\";\n  /** @internal */\n  declare _raw: RawBinaryCoStream;\n\n  constructor(\n    options:\n      | {\n          owner: Account | Group;\n        }\n      | {\n          fromRaw: RawBinaryCoStream;\n        },\n  ) {\n    super();\n\n    let raw: RawBinaryCoStream;\n\n    if (\"fromRaw\" in options) {\n      raw = options.fromRaw;\n    } else {\n      const rawOwner = options.owner._raw;\n      raw = rawOwner.createBinaryStream();\n    }\n\n    Object.defineProperties(this, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _type: { value: \"BinaryCoStream\", enumerable: false },\n      _raw: { value: raw, enumerable: false },\n    });\n  }\n\n  /**\n   * Create a new empty `FileStream` instance.\n   *\n   * @param options - Configuration options for the new FileStream\n   * @param options.owner - The Account or Group that will own this FileStream and control access rights\n   *\n   * @example\n   * ```typescript\n   * // Create owned by an account\n   * const stream = FileStream.create({ owner: myAccount });\n   *\n   * // Create owned by a group\n   * const stream = FileStream.create({ owner: teamGroup });\n   *\n   * // Create with implicit owner\n   * const stream = FileStream.create(myAccount);\n   * ```\n   *\n   * @remarks\n   * For uploading an existing file or blob, use {@link FileStream.createFromBlob} instead.\n   *\n   * @category Creation\n   */\n  static create<S extends FileStream>(\n    this: CoValueClass<S>,\n    options?: { owner?: Account | Group } | Account | Group,\n  ) {\n    return new this(parseCoValueCreateOptions(options));\n  }\n\n  getMetadata(): BinaryStreamInfo | undefined {\n    return this._raw.getBinaryStreamInfo();\n  }\n\n  getChunks(options?: {\n    allowUnfinished?: boolean;\n  }):\n    | (BinaryStreamInfo & { chunks: Uint8Array[]; finished: boolean })\n    | undefined {\n    return this._raw.getBinaryChunks(options?.allowUnfinished);\n  }\n\n  isBinaryStreamEnded(): boolean {\n    return this._raw.isBinaryStreamEnded();\n  }\n\n  start(options: BinaryStreamInfo): void {\n    this._raw.startBinaryStream(options);\n  }\n\n  push(data: Uint8Array): void {\n    this._raw.pushBinaryStreamChunk(data);\n  }\n\n  end(): void {\n    this._raw.endBinaryStream();\n  }\n\n  toBlob(options?: { allowUnfinished?: boolean }): Blob | undefined {\n    const chunks = this.getChunks({\n      allowUnfinished: options?.allowUnfinished,\n    });\n\n    if (!chunks) {\n      return undefined;\n    }\n\n    // @ts-ignore\n    return new Blob(chunks.chunks, { type: chunks.mimeType });\n  }\n\n  /**\n   * Load a `FileStream` as a `Blob`\n   *\n   * @category Content\n   */\n  static async loadAsBlob(\n    id: ID<FileStream>,\n    options?: {\n      allowUnfinished?: boolean;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Blob | undefined> {\n    let stream = await this.load(id, options);\n\n    return stream?.toBlob({\n      allowUnfinished: options?.allowUnfinished,\n    });\n  }\n\n  /**\n   * Create a `FileStream` from a `Blob` or `File`\n   *\n   * @example\n   * ```ts\n   * import { coField, FileStream } from \"jazz-tools\";\n   *\n   * const fileStream = await FileStream.createFromBlob(file, {owner: group})\n   * ```\n   * @category Content\n   */\n  static async createFromBlob(\n    blob: Blob | File,\n    options?:\n      | {\n          owner?: Group | Account;\n          onProgress?: (progress: number) => void;\n        }\n      | Account\n      | Group,\n  ): Promise<FileStream> {\n    const stream = this.create(options);\n    const onProgress =\n      options && \"onProgress\" in options ? options.onProgress : undefined;\n\n    const start = Date.now();\n\n    const data = new Uint8Array(await blob.arrayBuffer());\n    stream.start({\n      mimeType: blob.type,\n      totalSizeBytes: blob.size,\n      fileName: blob instanceof File ? blob.name : undefined,\n    });\n    const chunkSize = MAX_RECOMMENDED_TX_SIZE;\n\n    let lastProgressUpdate = Date.now();\n\n    for (let idx = 0; idx < data.length; idx += chunkSize) {\n      stream.push(data.slice(idx, idx + chunkSize));\n\n      if (Date.now() - lastProgressUpdate > 100) {\n        onProgress?.(idx / data.length);\n        lastProgressUpdate = Date.now();\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, 0));\n    }\n    stream.end();\n    const end = Date.now();\n\n    console.debug(\n      \"Finished creating binary stream in\",\n      (end - start) / 1000,\n      \"s - Throughput in MB/s\",\n      (1000 * (blob.size / (end - start))) / (1024 * 1024),\n    );\n    onProgress?.(1);\n\n    return stream;\n  }\n\n  /**\n   * Get a JSON representation of the `FileStream`\n   * @category Content\n   */\n  toJSON(): {\n    id: string;\n    _type: \"BinaryCoStream\";\n    mimeType?: string;\n    totalSizeBytes?: number;\n    fileName?: string;\n    chunks?: Uint8Array[];\n    finished?: boolean;\n  } {\n    return {\n      id: this.id,\n      _type: this._type,\n      ...this.getChunks(),\n    };\n  }\n\n  /** @internal */\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  /**\n   * Load a `FileStream`\n   * @category Subscription & Loading\n   */\n  static async load<C extends FileStream>(\n    this: CoValueClass<C>,\n    id: ID<C>,\n    options?: {\n      loadAs?: Account | AnonymousJazzAgent;\n      allowUnfinished?: boolean;\n    },\n  ): Promise<FileStream | null> {\n    const stream = await loadCoValueWithoutMe(this, id, options);\n\n    /**\n     * If the user hasn't requested an incomplete blob and the\n     * stream isn't complete wait for the stream download before progressing\n     */\n    if (!options?.allowUnfinished && !stream?.isBinaryStreamEnded()) {\n      return new Promise<FileStream>((resolve) => {\n        subscribeToCoValueWithoutMe(\n          this,\n          id,\n          options || {},\n          (value, unsubscribe) => {\n            if (value.isBinaryStreamEnded()) {\n              unsubscribe();\n              resolve(value);\n            }\n          },\n        );\n      });\n    }\n\n    return stream;\n  }\n\n  /**\n   * Subscribe to a `FileStream`, when you have an ID but don't have a `FileStream` instance yet\n   * @category Subscription & Loading\n   */\n  static subscribe<F extends FileStream, const R extends RefsToResolve<F>>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<F extends FileStream, const R extends RefsToResolve<F>>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    options: SubscribeListenerOptions<F, R>,\n    listener: (value: Resolved<F, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<F extends FileStream, const R extends RefsToResolve<F>>(\n    this: CoValueClass<F>,\n    id: ID<F>,\n    ...args: SubscribeRestArgs<F, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<F, R>(this, id, options, listener);\n  }\n\n  /**\n   * An instance method to subscribe to an existing `FileStream`\n   * @category Subscription & Loading\n   */\n  subscribe<B extends FileStream>(\n    this: B,\n    listener: (value: Resolved<B, true>) => void,\n  ): () => void {\n    return subscribeToExistingCoValue(this, {}, listener);\n  }\n\n  /**\n   * Wait for the `FileStream` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: { timeout?: number }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n","import {\n  AgentSecret,\n  CoID,\n  ControlledAccount,\n  CryptoProvider,\n  Everyone,\n  InviteSecret,\n  LocalNode,\n  Peer,\n  RawAccount,\n  RawCoMap,\n  RawCoValue,\n  Role,\n  SessionID,\n  cojsonInternals,\n} from \"cojson\";\nimport {\n  AnonymousJazzAgent,\n  AnyAccountSchema,\n  type CoMap,\n  type CoValue,\n  CoValueBase,\n  CoValueClass,\n  CoValueOrZodSchema,\n  type Group,\n  ID,\n  InstanceOfSchema,\n  InstanceOrPrimitiveOfSchema,\n  Profile,\n  Ref,\n  type RefEncoded,\n  RefIfCoValue,\n  RefsToResolve,\n  RefsToResolveStrict,\n  RegisteredSchemas,\n  Resolved,\n  type Schema,\n  SchemaInit,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n  accessChildByKey,\n  activeAccountContext,\n  anySchemaToCoSchema,\n  coValuesCache,\n  createInboxRoot,\n  ensureCoValueLoaded,\n  inspect,\n  loadCoValue,\n  loadCoValueWithoutMe,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n} from \"../internal.js\";\n\nexport type AccountCreationProps = {\n  name: string;\n  onboarding?: boolean;\n};\n\ntype AccountMembers<A extends Account> = [\n  {\n    id: string | \"everyone\";\n    role: Role;\n    ref: Ref<A>;\n    account: A;\n  },\n];\n\n/** @category Identity & Permissions */\nexport class Account extends CoValueBase implements CoValue {\n  declare id: ID<this>;\n  declare _type: \"Account\";\n  declare _raw: RawAccount;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  get _schema(): {\n    profile: Schema;\n    root: Schema;\n  } {\n    return (this.constructor as typeof Account)._schema;\n  }\n  static {\n    this._schema = {\n      profile: {\n        ref: () => Profile,\n        optional: false,\n      } satisfies RefEncoded<Profile>,\n      root: {\n        ref: () => RegisteredSchemas[\"CoMap\"],\n        optional: true,\n      } satisfies RefEncoded<CoMap>,\n    };\n  }\n\n  get _owner(): Account {\n    return this as Account;\n  }\n  get _loadedAs(): Account | AnonymousJazzAgent {\n    if (this.isLocalNodeOwner) return this;\n\n    const agent = this._raw.core.node.getCurrentAgent();\n\n    if (agent instanceof ControlledAccount) {\n      return coValuesCache.get(agent.account, () =>\n        Account.fromRaw(agent.account),\n      );\n    }\n\n    return new AnonymousJazzAgent(this._raw.core.node);\n  }\n\n  declare profile: Profile | null;\n  declare root: CoMap | null;\n\n  getDescriptor(key: string) {\n    if (key === \"profile\") {\n      return this._schema.profile;\n    } else if (key === \"root\") {\n      return this._schema.root;\n    }\n\n    return undefined;\n  }\n\n  get _refs(): {\n    profile: RefIfCoValue<Profile> | undefined;\n    root: RefIfCoValue<CoMap> | undefined;\n  } {\n    const profileID = this._raw.get(\"profile\") as unknown as\n      | ID<NonNullable<this[\"profile\"]>>\n      | undefined;\n    const rootID = this._raw.get(\"root\") as unknown as\n      | ID<NonNullable<this[\"root\"]>>\n      | undefined;\n\n    return {\n      profile: profileID\n        ? (new Ref(\n            profileID,\n            this._loadedAs,\n            this._schema.profile as RefEncoded<\n              NonNullable<this[\"profile\"]> & CoValue\n            >,\n            this,\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ) as any as RefIfCoValue<this[\"profile\"]>)\n        : undefined,\n      root: rootID\n        ? (new Ref(\n            rootID,\n            this._loadedAs,\n            this._schema.root as RefEncoded<\n              NonNullable<this[\"root\"]> & CoValue\n            >,\n            this,\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ) as any as RefIfCoValue<this[\"root\"]>)\n        : undefined,\n    };\n  }\n\n  /**\n   * Whether this account is the currently active account.\n   */\n  get isMe() {\n    return activeAccountContext.get().id === this.id;\n  }\n\n  /**\n   * Whether this account is the owner of the local node.\n   */\n  isLocalNodeOwner: boolean;\n  sessionID: SessionID | undefined;\n\n  constructor(options: { fromRaw: RawAccount }) {\n    super();\n    if (!(\"fromRaw\" in options)) {\n      throw new Error(\"Can only construct account from raw or with .create()\");\n    }\n    this.isLocalNodeOwner =\n      options.fromRaw.id == options.fromRaw.core.node.getCurrentAgent().id;\n\n    Object.defineProperties(this, {\n      id: {\n        value: options.fromRaw.id,\n        enumerable: false,\n      },\n      _raw: { value: options.fromRaw, enumerable: false },\n      _type: { value: \"Account\", enumerable: false },\n    });\n\n    if (this.isLocalNodeOwner) {\n      this.sessionID = options.fromRaw.core.node.currentSessionID;\n    }\n\n    return new Proxy(this, AccountAndGroupProxyHandler as ProxyHandler<this>);\n  }\n\n  myRole(): \"admin\" | undefined {\n    if (this.isLocalNodeOwner) {\n      return \"admin\";\n    }\n  }\n\n  getRoleOf(member: Everyone | ID<Account> | \"me\") {\n    if (member === \"me\") {\n      return this.isMe ? \"admin\" : undefined;\n    }\n\n    if (member === this.id) {\n      return \"admin\";\n    }\n\n    return undefined;\n  }\n\n  getParentGroups(): Array<Group> {\n    return [];\n  }\n\n  get members(): AccountMembers<this> {\n    const ref = new Ref<typeof this>(\n      this.id,\n      this._loadedAs,\n      {\n        ref: () => this.constructor as AccountClass<typeof this>,\n        optional: false,\n      },\n      this,\n    );\n\n    return [{ id: this.id, role: \"admin\", ref, account: this }];\n  }\n\n  canRead(value: CoValue) {\n    const role = value._owner.getRoleOf(this.id);\n\n    return (\n      role === \"admin\" ||\n      role === \"writer\" ||\n      role === \"reader\" ||\n      role === \"writeOnly\"\n    );\n  }\n\n  canWrite(value: CoValue) {\n    const role = value._owner.getRoleOf(this.id);\n\n    return role === \"admin\" || role === \"writer\" || role === \"writeOnly\";\n  }\n\n  canAdmin(value: CoValue) {\n    return value._owner.getRoleOf(this.id) === \"admin\";\n  }\n\n  async acceptInvite<S extends CoValueOrZodSchema>(\n    valueID: string,\n    inviteSecret: InviteSecret,\n    coValueClass: S,\n  ): Promise<Resolved<InstanceOrPrimitiveOfSchema<S>, true> | null> {\n    if (!this.isLocalNodeOwner) {\n      throw new Error(\"Only a controlled account can accept invites\");\n    }\n\n    await this._raw.core.node.acceptInvite(\n      valueID as unknown as CoID<RawCoValue>,\n      inviteSecret,\n    );\n\n    return loadCoValue(anySchemaToCoSchema(coValueClass), valueID, {\n      loadAs: this,\n    }) as Resolved<InstanceOrPrimitiveOfSchema<S>, true> | null;\n  }\n\n  /** @private */\n  static async create<A extends Account>(\n    this: CoValueClass<A> & typeof Account,\n    options: {\n      creationProps: { name: string };\n      initialAgentSecret?: AgentSecret;\n      peersToLoadFrom?: Peer[];\n      crypto: CryptoProvider;\n    },\n  ): Promise<A> {\n    const { node } = await LocalNode.withNewlyCreatedAccount({\n      ...options,\n      migration: async (rawAccount, _node, creationProps) => {\n        const account = new this({\n          fromRaw: rawAccount,\n        }) as A;\n\n        await account.applyMigration?.(creationProps);\n      },\n    });\n\n    return this.fromNode(node) as A;\n  }\n\n  static getMe<A extends Account>(this: CoValueClass<A> & typeof Account) {\n    return activeAccountContext.get() as A;\n  }\n\n  static async createAs<A extends Account>(\n    this: CoValueClass<A> & typeof Account,\n    as: Account,\n    options: {\n      creationProps: { name: string };\n    },\n  ) {\n    // TODO: is there a cleaner way to do this?\n    const connectedPeers = cojsonInternals.connectedPeers(\n      \"creatingAccount\",\n      \"createdAccount\",\n      { peer1role: \"server\", peer2role: \"client\" },\n    );\n\n    as._raw.core.node.syncManager.addPeer(connectedPeers[1]);\n\n    const account = await this.create<A>({\n      creationProps: options.creationProps,\n      crypto: as._raw.core.node.crypto,\n      peersToLoadFrom: [connectedPeers[0]],\n    });\n\n    await account.waitForAllCoValuesSync();\n\n    return account;\n  }\n\n  static fromNode<A extends Account>(\n    this: CoValueClass<A>,\n    node: LocalNode,\n  ): A {\n    return new this({\n      fromRaw: node.expectCurrentAccount(\"jazz-tools/Account.fromNode\"),\n    }) as A;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(): object | any[] {\n    return {\n      id: this.id,\n      _type: this._type,\n    };\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  async applyMigration(creationProps?: AccountCreationProps) {\n    await this.migrate(creationProps);\n\n    // if the user has not defined a profile themselves, we create one\n    if (this.profile === undefined && creationProps) {\n      const profileGroup = RegisteredSchemas[\"Group\"].create({ owner: this });\n\n      this.profile = Profile.create({ name: creationProps.name }, profileGroup);\n      profileGroup.addMember(\"everyone\", \"reader\");\n    } else if (this.profile && creationProps) {\n      if (this.profile._owner._type !== \"Group\") {\n        throw new Error(\"Profile must be owned by a Group\", {\n          cause: `The profile of the account \"${this.id}\" was created with an Account as owner, which is not allowed.`,\n        });\n      }\n    }\n\n    const node = this._raw.core.node;\n    const profile = node\n      .expectCoValueLoaded(this._raw.get(\"profile\")!)\n      .getCurrentContent() as RawCoMap;\n\n    if (!profile.get(\"inbox\")) {\n      const inboxRoot = createInboxRoot(this);\n      profile.set(\"inbox\", inboxRoot.id);\n      profile.set(\"inboxInvite\", inboxRoot.inviteLink);\n    }\n  }\n\n  // Placeholder method for subclasses to override\n  migrate(creationProps?: AccountCreationProps) {\n    creationProps; // To avoid unused parameter warning\n  }\n\n  /** @category Subscription & Loading */\n  static load<A extends Account, const R extends RefsToResolve<A> = true>(\n    this: CoValueClass<A>,\n    id: ID<A>,\n    options?: {\n      resolve?: RefsToResolveStrict<A, R>;\n      loadAs?: Account | AnonymousJazzAgent;\n    },\n  ): Promise<Resolved<A, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /** @category Subscription & Loading */\n  static subscribe<A extends Account, const R extends RefsToResolve<A> = true>(\n    this: CoValueClass<A>,\n    id: ID<A>,\n    listener: (value: Resolved<A, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<A extends Account, const R extends RefsToResolve<A> = true>(\n    this: CoValueClass<A>,\n    id: ID<A>,\n    options: SubscribeListenerOptions<A, R>,\n    listener: (value: Resolved<A, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<A extends Account, const R extends RefsToResolve<A>>(\n    this: CoValueClass<A>,\n    id: ID<A>,\n    ...args: SubscribeRestArgs<A, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<A, R>(this, id, options, listener);\n  }\n\n  /** @category Subscription & Loading */\n  ensureLoaded<A extends Account, const R extends RefsToResolve<A>>(\n    this: A,\n    options: { resolve: RefsToResolveStrict<A, R> },\n  ): Promise<Resolved<A, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /** @category Subscription & Loading */\n  subscribe<A extends Account, const R extends RefsToResolve<A>>(\n    this: A,\n    listener: (value: Resolved<A, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<A extends Account, const R extends RefsToResolve<A>>(\n    this: A,\n    options: { resolve?: RefsToResolveStrict<A, R> },\n    listener: (value: Resolved<A, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<A extends Account, const R extends RefsToResolve<A>>(\n    this: A,\n    ...args: SubscribeRestArgs<A, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue(this, options, listener);\n  }\n\n  /**\n   * Wait for the `Account` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: {\n    timeout?: number;\n  }) {\n    return this._raw.core.waitForSync(options);\n  }\n\n  /**\n   * Wait for all the available `CoValues` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForAllCoValuesSync(options?: {\n    timeout?: number;\n  }) {\n    return this._raw.core.node.syncManager.waitForAllCoValuesSync(\n      options?.timeout,\n    );\n  }\n}\n\nexport const AccountAndGroupProxyHandler: ProxyHandler<Account | Group> = {\n  get(target, key, receiver) {\n    if (key === \"profile\" || key === \"root\") {\n      const id = target._raw.get(key);\n\n      if (id) {\n        return accessChildByKey(target, id, key);\n      } else {\n        return undefined;\n      }\n    } else {\n      return Reflect.get(target, key, receiver);\n    }\n  },\n  set(target, key, value, receiver) {\n    if (\n      (key === \"profile\" || key === \"root\") &&\n      typeof value === \"object\" &&\n      SchemaInit in value\n    ) {\n      (target.constructor as typeof CoMap)._schema ||= {};\n      (target.constructor as typeof CoMap)._schema[key] = value[SchemaInit];\n      return true;\n    } else if (key === \"profile\") {\n      if (value) {\n        target._raw.set(\n          \"profile\",\n          value.id as unknown as CoID<RawCoMap>,\n          \"trusting\",\n        );\n      }\n\n      return true;\n    } else if (key === \"root\") {\n      if (value) {\n        target._raw.set(\"root\", value.id as unknown as CoID<RawCoMap>);\n      }\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n  defineProperty(target, key, descriptor) {\n    if (\n      (key === \"profile\" || key === \"root\") &&\n      typeof descriptor.value === \"object\" &&\n      SchemaInit in descriptor.value\n    ) {\n      (target.constructor as typeof CoMap)._schema ||= {};\n      (target.constructor as typeof CoMap)._schema[key] =\n        descriptor.value[SchemaInit];\n      return true;\n    } else {\n      return Reflect.defineProperty(target, key, descriptor);\n    }\n  },\n};\n\n/** @category Identity & Permissions */\nexport function isControlledAccount(account: Account): account is Account & {\n  isLocalNodeOwner: true;\n  sessionID: SessionID;\n  _raw: RawAccount;\n} {\n  return account.isLocalNodeOwner;\n}\n\nexport type AccountClass<Acc extends Account> = CoValueClass<Acc> & {\n  fromNode: (typeof Account)[\"fromNode\"];\n};\n\nRegisteredSchemas[\"Account\"] = Account;\n","import type {\n  AccountRole,\n  AgentID,\n  Everyone,\n  RawAccountID,\n  RawGroup,\n  Role,\n} from \"cojson\";\nimport type {\n  CoMap,\n  CoValue,\n  CoValueClass,\n  ID,\n  RefEncoded,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Schema,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n} from \"../internal.js\";\nimport {\n  Account,\n  AccountAndGroupProxyHandler,\n  CoValueBase,\n  Profile,\n  Ref,\n  RegisteredSchemas,\n  accessChildById,\n  activeAccountContext,\n  ensureCoValueLoaded,\n  isControlledAccount,\n  loadCoValueWithoutMe,\n  parseGroupCreateOptions,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n} from \"../internal.js\";\n\n/** @category Identity & Permissions */\nexport class Group extends CoValueBase implements CoValue {\n  declare id: ID<this>;\n  declare _type: \"Group\";\n  static {\n    this.prototype._type = \"Group\";\n  }\n  declare _raw: RawGroup;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static _schema: any;\n  get _schema(): {\n    profile: Schema;\n    root: Schema;\n  } {\n    return (this.constructor as typeof Group)._schema;\n  }\n  static {\n    this._schema = {\n      profile: \"json\" satisfies Schema,\n      root: \"json\" satisfies Schema,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as any;\n    Object.defineProperty(this.prototype, \"_schema\", {\n      get: () => this._schema,\n    });\n  }\n\n  declare profile: Profile | null;\n  declare root: CoMap | null;\n\n  get _refs(): {\n    profile: Ref<Profile> | undefined;\n    root: Ref<CoMap> | undefined;\n  } {\n    const profileID = this._raw.get(\"profile\") as unknown as\n      | ID<NonNullable<this[\"profile\"]>>\n      | undefined;\n    const rootID = this._raw.get(\"root\") as unknown as\n      | ID<NonNullable<this[\"root\"]>>\n      | undefined;\n    return {\n      profile: profileID\n        ? (new Ref(\n            profileID,\n            this._loadedAs,\n            this._schema.profile as RefEncoded<NonNullable<this[\"profile\"]>>,\n            this,\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ) as any as this[\"profile\"] extends Profile\n            ? Ref<this[\"profile\"]>\n            : never)\n        : undefined,\n      root: rootID\n        ? (new Ref(\n            rootID,\n            this._loadedAs,\n            this._schema.root as RefEncoded<NonNullable<this[\"root\"]>>,\n            this,\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ) as any as this[\"root\"] extends CoMap ? Ref<this[\"root\"]> : never)\n        : undefined,\n    };\n  }\n\n  /** @deprecated Don't use constructor directly, use .create */\n  constructor(options: { fromRaw: RawGroup } | { owner: Account | Group }) {\n    super();\n    let raw: RawGroup;\n\n    if (options && \"fromRaw\" in options) {\n      raw = options.fromRaw;\n    } else {\n      const initOwner = options.owner;\n      if (!initOwner) throw new Error(\"No owner provided\");\n      if (initOwner._type === \"Account\" && isControlledAccount(initOwner)) {\n        const rawOwner = initOwner._raw;\n        raw = rawOwner.core.node.createGroup();\n      } else {\n        throw new Error(\"Can only construct group as a controlled account\");\n      }\n    }\n\n    Object.defineProperties(this, {\n      id: {\n        value: raw.id,\n        enumerable: false,\n      },\n      _raw: { value: raw, enumerable: false },\n    });\n\n    return new Proxy(this, AccountAndGroupProxyHandler as ProxyHandler<this>);\n  }\n\n  static create<G extends Group>(\n    this: CoValueClass<G>,\n    options?: { owner: Account } | Account,\n  ) {\n    return new this(parseGroupCreateOptions(options));\n  }\n\n  myRole(): Role | undefined {\n    return this._raw.myRole();\n  }\n\n  addMember(member: Everyone, role: \"writer\" | \"reader\" | \"writeOnly\"): void;\n  addMember(member: Account, role: AccountRole): void;\n  /** @category Identity & Permissions\n   * Gives members of a parent group membership in this group.\n   * @param member The group that will gain access to this group.\n   * @param role The role all members of the parent group should have in this group.\n   */\n  addMember(\n    member: Group,\n    role?: \"reader\" | \"writer\" | \"admin\" | \"inherit\",\n  ): void;\n  addMember(\n    member: Group | Everyone | Account,\n    role?: AccountRole | \"inherit\",\n  ) {\n    if (member !== \"everyone\" && member._type === \"Group\") {\n      if (role === \"writeOnly\")\n        throw new Error(\"Cannot add group as member with write-only role\");\n      this._raw.extend(member._raw, role);\n    } else if (role !== undefined && role !== \"inherit\") {\n      this._raw.addMember(member === \"everyone\" ? member : member._raw, role);\n    }\n  }\n\n  removeMember(member: Everyone | Account): Promise<void>;\n  /** @category Identity & Permissions\n   * Revokes membership from members a parent group.\n   * @param member The group that will lose access to this group.\n   */\n  removeMember(member: Group): Promise<void>;\n  removeMember(member: Group | Everyone | Account) {\n    if (member !== \"everyone\" && member._type === \"Group\") {\n      return this._raw.revokeExtend(member._raw);\n    } else {\n      return this._raw.removeMember(\n        member === \"everyone\" ? member : member._raw,\n      );\n    }\n  }\n\n  get members(): Array<{\n    id: string;\n    role: AccountRole;\n    ref: Ref<Account>;\n    account: Account;\n  }> {\n    const members = [];\n\n    const refEncodedAccountSchema = {\n      ref: () => Account,\n      optional: false,\n    } satisfies RefEncoded<Account>;\n\n    for (const accountID of this._raw.getAllMemberKeysSet()) {\n      if (!isAccountID(accountID)) continue;\n\n      const role = this._raw.roleOf(accountID);\n\n      if (\n        role === \"admin\" ||\n        role === \"writer\" ||\n        role === \"reader\" ||\n        role === \"writeOnly\"\n      ) {\n        const ref = new Ref<Account>(\n          accountID,\n          this._loadedAs,\n          refEncodedAccountSchema,\n          this,\n        );\n\n        const group = this;\n\n        members.push({\n          id: accountID as unknown as ID<Account>,\n          role,\n          ref,\n          get account() {\n            // Accounts values are non-nullable because are loaded as dependencies\n            return accessChildById(group, accountID, refEncodedAccountSchema);\n          },\n        });\n      }\n    }\n\n    return members;\n  }\n\n  getRoleOf(member: Everyone | ID<Account> | \"me\") {\n    if (member === \"me\") {\n      return this._raw.roleOf(\n        activeAccountContext.get().id as unknown as RawAccountID,\n      );\n    }\n\n    return this._raw.roleOf(\n      member === \"everyone\" ? member : (member as unknown as RawAccountID),\n    );\n  }\n\n  /**\n   * Make the group public, so that everyone can read it.\n   * Alias for `addMember(\"everyone\", role)`.\n   *\n   * @param role - Optional: the role to grant to everyone. Defaults to \"reader\".\n   * @returns The group itself.\n   */\n  makePublic(role: \"reader\" | \"writer\" = \"reader\") {\n    this.addMember(\"everyone\", role);\n    return this;\n  }\n\n  getParentGroups(): Array<Group> {\n    return this._raw.getParentGroups().map((group) => Group.fromRaw(group));\n  }\n\n  /** @category Identity & Permissions\n   * Gives members of a parent group membership in this group.\n   * @deprecated Use `addMember` instead.\n   * @param parent The group that will gain access to this group.\n   * @param roleMapping The role all members of the parent group should have in this group.\n   * @returns This group.\n   */\n  extend(\n    parent: Group,\n    roleMapping?: \"reader\" | \"writer\" | \"admin\" | \"inherit\",\n  ) {\n    this._raw.extend(parent._raw, roleMapping);\n    return this;\n  }\n\n  /** @category Identity & Permissions\n   * Revokes membership from members a parent group.\n   * @deprecated Use `removeMember` instead.\n   * @param parent The group that will lose access to this group.\n   * @returns This group.\n   */\n  async revokeExtend(parent: Group) {\n    await this._raw.revokeExtend(parent._raw);\n    return this;\n  }\n\n  /** @category Subscription & Loading */\n  static load<G extends Group, const R extends RefsToResolve<G>>(\n    this: CoValueClass<G>,\n    id: ID<G>,\n    options?: { resolve?: RefsToResolveStrict<G, R>; loadAs?: Account },\n  ): Promise<Resolved<G, R> | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  /** @category Subscription & Loading */\n  static subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: CoValueClass<G>,\n    id: ID<G>,\n    listener: (value: Resolved<G, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: CoValueClass<G>,\n    id: ID<G>,\n    options: SubscribeListenerOptions<G, R>,\n    listener: (value: Resolved<G, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: CoValueClass<G>,\n    id: ID<G>,\n    ...args: SubscribeRestArgs<G, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<G, R>(this, id, options, listener);\n  }\n\n  /** @category Subscription & Loading */\n  ensureLoaded<G extends Group, const R extends RefsToResolve<G>>(\n    this: G,\n    options?: { resolve?: RefsToResolveStrict<G, R> },\n  ): Promise<Resolved<G, R>> {\n    return ensureCoValueLoaded(this, options);\n  }\n\n  /** @category Subscription & Loading */\n  subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: G,\n    listener: (value: Resolved<G, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: G,\n    options: { resolve?: RefsToResolveStrict<G, R> },\n    listener: (value: Resolved<G, R>, unsubscribe: () => void) => void,\n  ): () => void;\n  subscribe<G extends Group, const R extends RefsToResolve<G>>(\n    this: G,\n    ...args: SubscribeRestArgs<G, R>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToExistingCoValue(this, options, listener);\n  }\n\n  /**\n   * Wait for the `Group` to be uploaded to the other peers.\n   *\n   * @category Subscription & Loading\n   */\n  waitForSync(options?: { timeout?: number }) {\n    return this._raw.core.waitForSync(options);\n  }\n}\n\nRegisteredSchemas[\"Group\"] = Group;\n\nexport function isAccountID(id: RawAccountID | AgentID): id is RawAccountID {\n  return id.startsWith(\"co_\");\n}\n","import {\n  Account,\n  CoMap,\n  CoMapInit,\n  CoValueClass,\n  Group,\n  Simplify,\n  coField,\n} from \"../internal.js\";\n\n/** @category Identity & Permissions */\nexport class Profile extends CoMap {\n  name = coField.string;\n  inbox? = coField.optional.string;\n  inboxInvite? = coField.optional.string;\n\n  /**\n   * Creates a new profile with the given initial values and owner.\n   *\n   * The owner (a Group) determines access rights to the Profile.\n   *\n   * @category Creation\n   */\n  static override create<M extends CoMap>(\n    this: CoValueClass<M>,\n    init: Simplify<CoMapInit<M>>,\n    options?:\n      | {\n          owner: Group;\n        }\n      | Group,\n  ) {\n    const owner =\n      options !== undefined && \"owner\" in options ? options.owner : options;\n\n    // We add some guardrails to ensure that the owner of a profile is a group\n    if ((owner as Group | Account | undefined)?._type === \"Account\") {\n      throw new Error(\"Profiles should be owned by a group\");\n    }\n\n    return super.create<M>(init, options);\n  }\n}\n","import { CoID, InviteSecret, RawAccount, RawCoMap, SessionID } from \"cojson\";\nimport { CoStreamItem, RawCoStream } from \"cojson\";\nimport {\n  type Account,\n  CoValue,\n  CoValueClass,\n  CoValueOrZodSchema,\n  ID,\n  InstanceOfSchema,\n  activeAccountContext,\n  anySchemaToCoSchema,\n  loadCoValue,\n  zodSchemaToCoSchema,\n} from \"../internal.js\";\n\nexport type InboxInvite = `${CoID<MessagesStream>}/${InviteSecret}`;\ntype TxKey = `${SessionID}/${number}`;\n\ntype MessagesStream = RawCoStream<CoID<InboxMessage<CoValue, any>>>;\ntype FailedMessagesStream = RawCoStream<{\n  errors: string[];\n  value: CoID<InboxMessage<CoValue, any>>;\n}>;\ntype TxKeyStream = RawCoStream<TxKey>;\nexport type InboxRoot = RawCoMap<{\n  messages: CoID<MessagesStream>;\n  processed: CoID<TxKeyStream>;\n  failed: CoID<FailedMessagesStream>;\n  inviteLink: InboxInvite;\n}>;\n\nexport function createInboxRoot(account: Account) {\n  if (!account.isLocalNodeOwner) {\n    throw new Error(\"Account is not controlled\");\n  }\n\n  const rawAccount = account._raw;\n\n  const group = rawAccount.core.node.createGroup();\n  const messagesFeed = group.createStream<MessagesStream>();\n\n  const inboxRoot = rawAccount.createMap<InboxRoot>();\n  const processedFeed = rawAccount.createStream<TxKeyStream>();\n  const failedFeed = rawAccount.createStream<FailedMessagesStream>();\n\n  const inviteLink =\n    `${messagesFeed.id}/${group.createInvite(\"writeOnly\")}` as const;\n\n  inboxRoot.set(\"messages\", messagesFeed.id);\n  inboxRoot.set(\"processed\", processedFeed.id);\n  inboxRoot.set(\"failed\", failedFeed.id);\n\n  return {\n    id: inboxRoot.id,\n    inviteLink,\n  };\n}\n\ntype InboxMessage<I extends CoValue, O extends CoValue | undefined> = RawCoMap<{\n  payload: ID<I>;\n  result: ID<O> | undefined;\n  processed: boolean;\n  error: string | undefined;\n}>;\n\nasync function createInboxMessage<\n  I extends CoValue,\n  O extends CoValue | undefined,\n>(payload: I, inboxOwner: RawAccount) {\n  const group = payload._raw.group;\n\n  if (group instanceof RawAccount) {\n    throw new Error(\"Inbox messages should be owned by a group\");\n  }\n\n  group.addMember(inboxOwner, \"writer\");\n\n  const message = group.createMap<InboxMessage<I, O>>({\n    payload: payload.id,\n    result: undefined,\n    processed: false,\n    error: undefined,\n  });\n\n  await payload._raw.core.waitForSync();\n  await message.core.waitForSync();\n\n  return message;\n}\n\nexport class Inbox {\n  account: Account;\n  messages: MessagesStream;\n  processed: TxKeyStream;\n  failed: FailedMessagesStream;\n  root: InboxRoot;\n  processing = new Set<`${SessionID}/${number}`>();\n\n  private constructor(\n    account: Account,\n    root: InboxRoot,\n    messages: MessagesStream,\n    processed: TxKeyStream,\n    failed: FailedMessagesStream,\n  ) {\n    this.account = account;\n    this.root = root;\n    this.messages = messages;\n    this.processed = processed;\n    this.failed = failed;\n  }\n\n  subscribe<M extends CoValueOrZodSchema, O extends CoValue | undefined>(\n    Schema: M,\n    callback: (\n      message: InstanceOfSchema<M>,\n      senderAccountID: ID<Account>,\n    ) => Promise<O | undefined | void>,\n    options: { retries?: number } = {},\n  ) {\n    const processed = new Set<`${SessionID}/${number}`>();\n    const failed = new Map<`${SessionID}/${number}`, string[]>();\n    const node = this.account._raw.core.node;\n\n    this.processed.subscribe((stream) => {\n      for (const items of Object.values(stream.items)) {\n        for (const item of items) {\n          processed.add(item.value as TxKey);\n        }\n      }\n    });\n\n    const { account } = this;\n    const { retries = 3 } = options;\n\n    let failTimer: ReturnType<typeof setTimeout> | number | undefined =\n      undefined;\n\n    const clearFailTimer = () => {\n      clearTimeout(failTimer);\n      failTimer = undefined;\n    };\n\n    const handleNewMessages = (stream: MessagesStream) => {\n      clearFailTimer(); // Stop the failure timers, we're going to process the failed entries anyway\n\n      for (const [sessionID, items] of Object.entries(stream.items) as [\n        SessionID,\n        CoStreamItem<CoID<InboxMessage<InstanceOfSchema<M>, O>>>[],\n      ][]) {\n        const accountID = getAccountIDfromSessionID(sessionID);\n\n        if (!accountID) {\n          console.warn(\"Received message from unknown account\", sessionID);\n          continue;\n        }\n\n        for (const item of items) {\n          const txKey = `${sessionID}/${item.tx.txIndex}` as const;\n\n          if (!processed.has(txKey) && !this.processing.has(txKey)) {\n            this.processing.add(txKey);\n\n            const id = item.value;\n\n            node\n              .load(id)\n              .then((message) => {\n                if (message === \"unavailable\") {\n                  return Promise.reject(\n                    new Error(\"Unable to load inbox message \" + id),\n                  );\n                }\n\n                return loadCoValue(\n                  anySchemaToCoSchema(Schema),\n                  message.get(\"payload\")!,\n                  {\n                    loadAs: account,\n                  },\n                );\n              })\n              .then((value) => {\n                if (!value) {\n                  return Promise.reject(\n                    new Error(\"Unable to load inbox message \" + id),\n                  );\n                }\n\n                return callback(value as InstanceOfSchema<M>, accountID);\n              })\n              .then((result) => {\n                const inboxMessage = node\n                  .expectCoValueLoaded(item.value)\n                  .getCurrentContent() as RawCoMap;\n\n                if (result) {\n                  inboxMessage.set(\"result\", result.id);\n                }\n\n                inboxMessage.set(\"processed\", true);\n\n                this.processed.push(txKey);\n                this.processing.delete(txKey);\n              })\n              .catch((error) => {\n                console.error(\"Error processing inbox message\", error);\n                this.processing.delete(txKey);\n                const errors = failed.get(txKey) ?? [];\n\n                const stringifiedError = String(error);\n                errors.push(stringifiedError);\n\n                let inboxMessage: RawCoMap | undefined;\n\n                try {\n                  inboxMessage = node\n                    .expectCoValueLoaded(item.value)\n                    .getCurrentContent() as RawCoMap;\n\n                  inboxMessage.set(\"error\", stringifiedError);\n                } catch (error) {}\n\n                if (errors.length > retries) {\n                  inboxMessage?.set(\"processed\", true);\n                  this.processed.push(txKey);\n                  this.failed.push({ errors, value: item.value });\n                } else {\n                  failed.set(txKey, errors);\n                  if (!failTimer) {\n                    failTimer = setTimeout(\n                      () => handleNewMessages(stream),\n                      100,\n                    );\n                  }\n                }\n              });\n          }\n        }\n      }\n    };\n\n    const unsubscribe = this.messages.subscribe(handleNewMessages);\n\n    return () => {\n      unsubscribe();\n      clearFailTimer();\n    };\n  }\n\n  static async load(account: Account) {\n    const profile = account.profile;\n\n    if (!profile) {\n      throw new Error(\"Account profile should already be loaded\");\n    }\n\n    if (!profile.inbox) {\n      throw new Error(\"The account has not set up their inbox\");\n    }\n\n    const node = account._raw.core.node;\n\n    const root = await node.load(profile.inbox as CoID<InboxRoot>);\n\n    if (root === \"unavailable\") {\n      throw new Error(\"Inbox not found\");\n    }\n\n    const [messages, processed, failed] = await Promise.all([\n      node.load(root.get(\"messages\")!),\n      node.load(root.get(\"processed\")!),\n      node.load(root.get(\"failed\")!),\n    ]);\n\n    if (\n      messages === \"unavailable\" ||\n      processed === \"unavailable\" ||\n      failed === \"unavailable\"\n    ) {\n      throw new Error(\"Inbox not found\");\n    }\n\n    return new Inbox(account, root, messages, processed, failed);\n  }\n}\n\nexport class InboxSender<I extends CoValue, O extends CoValue | undefined> {\n  currentAccount: Account;\n  owner: RawAccount;\n  messages: MessagesStream;\n\n  private constructor(\n    currentAccount: Account,\n    owner: RawAccount,\n    messages: MessagesStream,\n  ) {\n    this.currentAccount = currentAccount;\n    this.owner = owner;\n    this.messages = messages;\n  }\n\n  getOwnerAccount() {\n    return this.owner;\n  }\n\n  async sendMessage(\n    message: I,\n  ): Promise<O extends CoValue ? ID<O> : undefined> {\n    const inboxMessage = await createInboxMessage<I, O>(message, this.owner);\n\n    this.messages.push(inboxMessage.id);\n\n    return new Promise((resolve, reject) => {\n      inboxMessage.subscribe((message) => {\n        if (message.get(\"processed\")) {\n          const error = message.get(\"error\");\n          if (error) {\n            reject(new Error(error));\n          } else {\n            resolve(\n              message.get(\"result\") as O extends CoValue ? ID<O> : undefined,\n            );\n          }\n        }\n      });\n    });\n  }\n\n  static async load<\n    I extends CoValue,\n    O extends CoValue | undefined = undefined,\n  >(inboxOwnerID: ID<Account>, currentAccount?: Account) {\n    currentAccount ||= activeAccountContext.get();\n\n    const node = currentAccount._raw.core.node;\n\n    const inboxOwnerRaw = await node.load(\n      inboxOwnerID as unknown as CoID<RawAccount>,\n    );\n\n    if (inboxOwnerRaw === \"unavailable\") {\n      throw new Error(\"Failed to load the inbox owner\");\n    }\n\n    const inboxOwnerProfileRaw = await node.load(inboxOwnerRaw.get(\"profile\")!);\n\n    if (inboxOwnerProfileRaw === \"unavailable\") {\n      throw new Error(\"Failed to load the inbox owner profile\");\n    }\n\n    if (\n      inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== \"reader\" &&\n      inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== \"writer\" &&\n      inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== \"admin\"\n    ) {\n      throw new Error(\n        \"Insufficient permissions to access the inbox, make sure its user profile is publicly readable.\",\n      );\n    }\n\n    const inboxInvite = inboxOwnerProfileRaw.get(\"inboxInvite\");\n\n    if (!inboxInvite) {\n      throw new Error(\"The user has not set up their inbox\");\n    }\n\n    const id = await acceptInvite(inboxInvite as InboxInvite, currentAccount);\n\n    const messages = await node.load(id);\n\n    if (messages === \"unavailable\") {\n      throw new Error(\"Inbox not found\");\n    }\n\n    return new InboxSender<I, O>(currentAccount, inboxOwnerRaw, messages);\n  }\n}\n\nasync function acceptInvite(invite: string, account?: Account) {\n  account ||= activeAccountContext.get();\n\n  const id = invite.slice(0, invite.indexOf(\"/\")) as CoID<MessagesStream>;\n\n  const inviteSecret = invite.slice(invite.indexOf(\"/\") + 1) as InviteSecret;\n\n  if (!id?.startsWith(\"co_z\") || !inviteSecret.startsWith(\"inviteSecret_\")) {\n    throw new Error(\"Invalid inbox ticket\");\n  }\n\n  if (!account.isLocalNodeOwner) {\n    throw new Error(\"Account is not controlled\");\n  }\n\n  await account._raw.core.node.acceptInvite(id, inviteSecret);\n\n  return id;\n}\n\nfunction getAccountIDfromSessionID(sessionID: SessionID) {\n  const until = sessionID.indexOf(\"_session\");\n  const accountID = sessionID.slice(0, until);\n\n  if (accountID.startsWith(\"co_z\")) {\n    return accountID as ID<Account>;\n  }\n\n  return;\n}\n","import {\n  ControlledAccount,\n  type OpID,\n  RawAccount,\n  type RawCoPlainText,\n  stringifyOpID,\n} from \"cojson\";\nimport { calcPatch } from \"fast-myers-diff\";\nimport {\n  AnonymousJazzAgent,\n  CoValue,\n  CoValueClass,\n  ID,\n  Resolved,\n  SubscribeListenerOptions,\n  SubscribeRestArgs,\n  anySchemaToCoSchema,\n  parseCoValueCreateOptions,\n} from \"../internal.js\";\nimport {\n  inspect,\n  loadCoValueWithoutMe,\n  parseSubscribeRestArgs,\n  subscribeToCoValueWithoutMe,\n  subscribeToExistingCoValue,\n} from \"../internal.js\";\nimport { coValuesCache } from \"../lib/cache.js\";\nimport { Account } from \"./account.js\";\nimport { Group } from \"./group.js\";\nimport { RegisteredSchemas } from \"./registeredSchemas.js\";\n\nexport type TextPos = OpID;\n\nexport class CoPlainText extends String implements CoValue {\n  declare id: ID<this>;\n  declare _type: \"CoPlainText\";\n  declare _raw: RawCoPlainText;\n\n  get _owner(): Account | Group {\n    return this._raw.group instanceof RawAccount\n      ? Account.fromRaw(this._raw.group)\n      : Group.fromRaw(this._raw.group);\n  }\n\n  get _loadedAs() {\n    const agent = this._raw.core.node.getCurrentAgent();\n\n    if (agent instanceof ControlledAccount) {\n      return coValuesCache.get(agent.account, () =>\n        anySchemaToCoSchema(RegisteredSchemas[\"Account\"]).fromRaw(\n          agent.account,\n        ),\n      );\n    }\n\n    return new AnonymousJazzAgent(this._raw.core.node);\n  }\n\n  /** @internal */\n  constructor(\n    options:\n      | { fromRaw: RawCoPlainText }\n      | { text: string; owner: Account | Group }\n      | undefined,\n  ) {\n    if (!options) {\n      super(\"\"); // Intialise as empty string\n      return;\n    }\n\n    if (\"fromRaw\" in options) {\n      super(options.fromRaw.toString());\n      const raw = options.fromRaw;\n      Object.defineProperties(this, {\n        id: { value: raw.id, enumerable: false },\n        _type: { value: \"CoPlainText\", enumerable: false },\n        _raw: { value: raw, enumerable: false },\n      });\n      return;\n    }\n\n    if (\"text\" in options && \"owner\" in options) {\n      super(options.text);\n      const raw = options.owner._raw.createPlainText(options.text);\n      Object.defineProperties(this, {\n        id: { value: raw.id, enumerable: false },\n        _type: { value: \"CoPlainText\", enumerable: false },\n        _raw: { value: raw, enumerable: false },\n      });\n      return;\n    }\n\n    throw new Error(\"Invalid constructor arguments\");\n  }\n\n  /**\n   * Create a new `CoPlainText` with the given text and owner.\n   *\n   * The owner (a Group or Account) determines access rights to the CoPlainText.\n   *\n   * The CoPlainText will immediately be persisted and synced to connected peers.\n   *\n   * @example\n   * ```ts\n   * const text = CoPlainText.create(\"Hello, world!\", { owner: me });\n   * ```\n   *\n   * @category Creation\n   */\n  static create<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    text: string,\n    options?: { owner: Account | Group } | Account | Group,\n  ) {\n    const { owner } = parseCoValueCreateOptions(options);\n    return new this({ text, owner });\n  }\n\n  get length() {\n    return this._raw.toString().length;\n  }\n\n  toString() {\n    return this._raw.toString();\n  }\n\n  valueOf() {\n    return this._raw.toString();\n  }\n\n  toJSON(): string {\n    return this._raw.toString();\n  }\n\n  [inspect]() {\n    return this.toJSON();\n  }\n\n  insertBefore(idx: number, text: string) {\n    this._raw.insertBefore(idx, text);\n  }\n\n  insertAfter(idx: number, text: string) {\n    this._raw.insertAfter(idx, text);\n  }\n\n  deleteRange(range: { from: number; to: number }) {\n    this._raw.deleteRange(range);\n  }\n\n  posBefore(idx: number): TextPos | undefined {\n    return this._raw.mapping.opIDbeforeIdx[idx];\n  }\n\n  posAfter(idx: number): TextPos | undefined {\n    return this._raw.mapping.opIDafterIdx[idx];\n  }\n\n  idxBefore(pos: TextPos): number | undefined {\n    return this._raw.mapping.idxBeforeOpID[stringifyOpID(pos)];\n  }\n\n  idxAfter(pos: TextPos): number | undefined {\n    return this._raw.mapping.idxAfterOpID[stringifyOpID(pos)];\n  }\n\n  static fromRaw<V extends CoPlainText>(\n    this: CoValueClass<V> & typeof CoPlainText,\n    raw: RawCoPlainText,\n  ) {\n    return new this({ fromRaw: raw });\n  }\n\n  /**\n   * Apply text, modifying the text in place. Calculates the diff and applies it to the CoValue.\n   *\n   * @category Mutation\n   */\n  applyDiff(other: string) {\n    const current = this._raw.toString();\n\n    // Split both strings into grapheme arrays for proper comparison\n    const currentGraphemes = this._raw.toGraphemes(current);\n    const otherGraphemes = this._raw.toGraphemes(other);\n\n    // Calculate the diff on grapheme arrays\n    const patches = [...calcPatch(currentGraphemes, otherGraphemes)];\n\n    // Apply patches in reverse order to avoid index shifting issues\n    for (const [from, to, insert] of patches.reverse()) {\n      if (to > from) {\n        this.deleteRange({ from, to });\n      }\n      if (insert.length > 0) {\n        // Join the graphemes back into a string for insertion\n        this.insertBefore(from, this._raw.fromGraphemes(insert));\n      }\n    }\n  }\n\n  /**\n   * Load a `CoPlainText` with a given ID, as a given account.\n   *\n   * @category Subscription & Loading\n   */\n  static load<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    id: ID<T>,\n    options?: { loadAs?: Account | AnonymousJazzAgent },\n  ): Promise<T | null> {\n    return loadCoValueWithoutMe(this, id, options);\n  }\n\n  //   /**\n  //    * Effectful version of `CoMap.load()`.\n  //    *\n  //    * Needs to be run inside an `AccountCtx` context.\n  //    *\n  //    * @category Subscription & Loading\n  //    */\n  //   static loadEf<T extends CoPlainText>(\n  //     this: CoValueClass<T>,\n  //     id: ID<T>,\n  //   ): Effect.Effect<T, UnavailableError, AccountCtx> {\n  //     return loadCoValueEf(this, id, []);\n  //   }\n\n  /**\n   * Load and subscribe to a `CoPlainText` with a given ID, as a given account.\n   *\n   * Automatically also subscribes to updates to all referenced/nested CoValues as soon as they are accessed in the listener.\n   *\n   * Check out the `load` methods on `CoMap`/`CoList`/`CoStream`/`Group`/`Account` to see which depth structures are valid to nest.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * Also see the `useCoState` hook to reactively subscribe to a CoValue in a React component.\n   *\n   * @category Subscription & Loading\n   */\n  static subscribe<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    id: ID<T>,\n    listener: (value: Resolved<T, true>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    id: ID<T>,\n    options: Omit<SubscribeListenerOptions<T, true>, \"resolve\">,\n    listener: (value: Resolved<T, true>, unsubscribe: () => void) => void,\n  ): () => void;\n  static subscribe<T extends CoPlainText>(\n    this: CoValueClass<T>,\n    id: ID<T>,\n    ...args: SubscribeRestArgs<T, true>\n  ): () => void {\n    const { options, listener } = parseSubscribeRestArgs(args);\n    return subscribeToCoValueWithoutMe<T, true>(this, id, options, listener);\n  }\n\n  /**\n   * Given an already loaded `CoPlainText`, subscribe to updates to the `CoPlainText` and ensure that the specified fields are loaded to the specified depth.\n   *\n   * Works like `CoPlainText.subscribe()`, but you don't need to pass the ID or the account to load as again.\n   *\n   * Returns an unsubscribe function that you should call when you no longer need updates.\n   *\n   * @category Subscription & Loading\n   **/\n  subscribe<T extends CoPlainText>(\n    this: T,\n    listener: (value: Resolved<T, true>, unsubscribe: () => void) => void,\n  ): () => void {\n    return subscribeToExistingCoValue(this, {}, listener);\n  }\n\n  /**\n   * Allow CoPlainText to behave like a primitive string in most contexts (e.g.,\n   * string concatenation, template literals, React rendering, etc.) by implementing\n   * Symbol.toPrimitive. This eliminates the need to call .toString() explicitly.\n   *\n   * The 'hint' parameter indicates the preferred type of conversion:\n   * - 'string': prefer string conversion\n   * - 'number': prefer number conversion (attempt to parse the text as a number)\n   * - 'default': usually treat as string\n   */\n  [Symbol.toPrimitive](hint: string) {\n    if (hint === \"number\") {\n      // Not meaningful for text, but required for completeness\n      return Number(this._raw.toString());\n    }\n    // For 'string' and 'default', return the string representation\n    return this._raw.toString();\n  }\n}\n","import { RawCoValue } from \"cojson\";\nimport { CoValue } from \"../internal.js\";\n\nconst weakMap = new WeakMap<RawCoValue, CoValue>();\n\nexport const coValuesCache = {\n  get: <V extends CoValue>(raw: RawCoValue, compute: () => V) => {\n    const cached = weakMap.get(raw);\n    if (cached) {\n      return cached as V;\n    }\n    const computed = compute();\n    weakMap.set(raw, computed);\n    return computed;\n  },\n};\n","import { CoPlainText } from \"./coPlainText.js\";\n\nexport class CoRichText extends CoPlainText {}\n","import {\n  CoValue,\n  CoValueBase,\n  CoValueClass,\n  CoValueFromRaw,\n} from \"../internal.js\";\n\n/**\n * SchemaUnion allows you to create union types of CoValues that can be discriminated at runtime.\n *\n * @categoryDescription Declaration\n * Declare your union types by extending `SchemaUnion.Of(...)` and passing a discriminator function that determines which concrete type to use based on the raw data.\n *\n * ```ts\n * import { SchemaUnion, CoMap } from \"jazz-tools\";\n *\n * class BaseWidget extends CoMap {\n *   type = coField.string;\n * }\n *\n * class ButtonWidget extends BaseWidget {\n *   type = coField.literal(\"button\");\n *   label = coField.string;\n * }\n *\n * class SliderWidget extends BaseWidget {\n *   type = coField.literal(\"slider\");\n *   min = coField.number;\n *   max = coField.number;\n * }\n *\n * const WidgetUnion = SchemaUnion.Of<BaseWidget>((raw) => {\n *   switch (raw.get(\"type\")) {\n *     case \"button\": return ButtonWidget;\n *     case \"slider\": return SliderWidget;\n *     default: throw new Error(\"Unknown widget type\");\n *   }\n * });\n * ```\n *\n * @category CoValues\n */\nexport abstract class SchemaUnion extends CoValueBase implements CoValue {\n  /**\n   * Create a new union type from a discriminator function.\n   *\n   * The discriminator function receives the raw data and should return the appropriate concrete class to use for that data.\n   *\n   * When loading a SchemaUnion, the correct subclass will be instantiated based on the discriminator.\n   *\n   * @param discriminator - Function that determines which concrete type to use\n   * @returns A new class that can create/load instances of the union type\n   *\n   * @example\n   * ```ts\n   * const WidgetUnion = SchemaUnion.Of<BaseWidget>((raw) => {\n   *   switch (raw.get(\"type\")) {\n   *     case \"button\": return ButtonWidget;\n   *     case \"slider\": return SliderWidget;\n   *     default: throw new Error(\"Unknown widget type\");\n   *   }\n   * });\n   *\n   * const widget = await loadCoValue(WidgetUnion, id, me, {});\n   *\n   * // You can narrow the returned instance to a subclass by using `instanceof`\n   * if (widget instanceof ButtonWidget) {\n   *   console.log(widget.label);\n   * } else if (widget instanceof SliderWidget) {\n   *   console.log(widget.min, widget.max);\n   * }\n   * ```\n   *\n   * @category Declaration\n   **/\n  static Of<V extends CoValue>(\n    discriminator: (raw: V[\"_raw\"]) => CoValueClass<V> & CoValueFromRaw<V>,\n  ): CoValueClass<V> & typeof SchemaUnion {\n    return class SchemaUnionClass extends SchemaUnion {\n      static override fromRaw<T extends CoValue>(\n        this: CoValueClass<T> & CoValueFromRaw<T>,\n        raw: T[\"_raw\"],\n      ): T {\n        const ResolvedClass = discriminator(\n          raw as V[\"_raw\"],\n        ) as unknown as CoValueClass<T> & CoValueFromRaw<T>;\n        return ResolvedClass.fromRaw(raw);\n      }\n    } as unknown as CoValueClass<V> & typeof SchemaUnion;\n  }\n\n  /**\n   * Create an instance from raw data. This is called internally and should not be used directly.\n   * Use {@link SchemaUnion.Of} to create a union type instead.\n   *\n   * @internal\n   */\n  // @ts-ignore\n  static fromRaw<V extends CoValue>(this: CoValueClass<V>, raw: V[\"_raw\"]): V {\n    throw new Error(\"Not implemented\");\n  }\n}\n","import { LocalNode } from \"cojson\";\n\nexport class AnonymousJazzAgent {\n  _type = \"Anonymous\" as const;\n  constructor(public node: LocalNode) {}\n}\n","import type { Account } from \"../internal.js\";\n\nclass ActiveAccountContext {\n  private activeAccount: Account | null = null;\n  private guestMode: boolean = false;\n\n  set(account: Account | null) {\n    this.activeAccount = account;\n    this.guestMode = false;\n  }\n\n  setGuestMode() {\n    this.activeAccount = null;\n    this.guestMode = true;\n  }\n\n  maybeGet() {\n    return this.activeAccount;\n  }\n\n  get() {\n    if (!this.activeAccount) {\n      if (this.guestMode) {\n        throw new Error(\n          \"Something that expects a full active account was called in guest mode.\",\n        );\n      }\n\n      throw new Error(\"No active account\");\n    }\n\n    return this.activeAccount;\n  }\n}\n\nexport type { ActiveAccountContext };\n\nexport const activeAccountContext = new ActiveAccountContext();\n","import { type Account } from \"../coValues/account.js\";\nimport type {\n  AnonymousJazzAgent,\n  CoValue,\n  ID,\n  RefEncoded,\n} from \"../internal.js\";\nimport {\n  accessChildById,\n  getSubscriptionScope,\n  isRefEncoded,\n} from \"../internal.js\";\n\nexport class Ref<out V extends CoValue> {\n  constructor(\n    readonly id: ID<V>,\n    readonly controlledAccount: Account | AnonymousJazzAgent,\n    readonly schema: RefEncoded<V>,\n    readonly parent: CoValue,\n  ) {\n    if (!isRefEncoded(schema)) {\n      throw new Error(\"Ref must be constructed with a ref schema\");\n    }\n  }\n\n  async load(): Promise<V | null> {\n    const subscriptionScope = getSubscriptionScope(this.parent);\n\n    subscriptionScope.subscribeToId(this.id, this.schema);\n\n    const node = subscriptionScope.childNodes.get(this.id);\n\n    if (!node) {\n      return null;\n    }\n\n    const value = node.value;\n\n    if (value?.type === \"loaded\") {\n      return value.value as V;\n    } else {\n      return new Promise((resolve) => {\n        const unsubscribe = node.subscribe((value) => {\n          if (value?.type === \"loaded\") {\n            unsubscribe();\n            resolve(value.value as V);\n          } else if (value?.type === \"unavailable\") {\n            unsubscribe();\n            resolve(null);\n          } else if (value?.type === \"unauthorized\") {\n            unsubscribe();\n            resolve(null);\n          }\n        });\n      });\n    }\n  }\n\n  get value(): V | null | undefined {\n    return accessChildById(this.parent, this.id, this.schema);\n  }\n}\n\nexport function makeRefs<Keys extends string | number>(\n  parent: CoValue,\n  getIdForKey: (key: Keys) => ID<CoValue> | undefined,\n  getKeysWithIds: () => Keys[],\n  controlledAccount: Account | AnonymousJazzAgent,\n  refSchemaForKey: (key: Keys) => RefEncoded<CoValue>,\n): { [K in Keys]: Ref<CoValue> } & {\n  [Symbol.iterator]: () => IterableIterator<Ref<CoValue>>;\n  length: number;\n} {\n  const refs = {} as { [K in Keys]: Ref<CoValue> } & {\n    [Symbol.iterator]: () => IterableIterator<Ref<CoValue>>;\n    length: number;\n  };\n  return new Proxy(refs, {\n    get(_target, key) {\n      if (key === Symbol.iterator) {\n        return function* () {\n          for (const key of getKeysWithIds()) {\n            yield new Ref(\n              getIdForKey(key)!,\n              controlledAccount,\n              refSchemaForKey(key),\n              parent,\n            );\n          }\n        };\n      }\n      if (typeof key === \"symbol\") return undefined;\n      if (key === \"length\") {\n        return getKeysWithIds().length;\n      }\n      const id = getIdForKey(key as Keys);\n      if (!id) return undefined;\n      return new Ref(\n        id as ID<CoValue>,\n        controlledAccount,\n        refSchemaForKey(key as Keys),\n        parent,\n      );\n    },\n    ownKeys() {\n      return getKeysWithIds().map((key) => key.toString());\n    },\n    getOwnPropertyDescriptor(target, key) {\n      const id = getIdForKey(key as Keys);\n      if (id) {\n        return {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n        };\n      } else {\n        return Reflect.getOwnPropertyDescriptor(target, key);\n      }\n    },\n  });\n}\n\nexport type RefIfCoValue<V> = NonNullable<V> extends CoValue\n  ? Ref<NonNullable<V>>\n  : never;\n","import type { JsonValue, RawCoValue } from \"cojson\";\nimport { CojsonInternalTypes } from \"cojson\";\nimport {\n  type CoValue,\n  type CoValueClass,\n  CoValueFromRaw,\n  ItemsSym,\n  JazzToolsSymbol,\n  SchemaInit,\n  isCoValueClass,\n} from \"../internal.js\";\n\n/** @category Schema definition */\nexport const Encoders = {\n  Date: {\n    encode: (value: Date) => value.toISOString(),\n    decode: (value: JsonValue) => new Date(value as string),\n  },\n  OptionalDate: {\n    encode: (value: Date | undefined) => value?.toISOString() || null,\n    decode: (value: JsonValue) =>\n      value === null ? undefined : new Date(value as string),\n  },\n};\n\nconst optional = {\n  ref: optionalRef,\n  json<T extends CojsonInternalTypes.CoJsonValue<T>>(): T | undefined {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: \"json\" satisfies Schema } as any;\n  },\n  encoded<T>(arg: OptionalEncoder<T>): T | undefined {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: { encoded: arg } satisfies Schema } as any;\n  },\n  string: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as string | undefined,\n  number: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as number | undefined,\n  boolean: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as boolean | undefined,\n  null: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as null | undefined,\n  Date: {\n    [SchemaInit]: { encoded: Encoders.OptionalDate } satisfies Schema,\n  } as unknown as Date | undefined,\n  literal<T extends (string | number | boolean)[]>(\n    ..._lit: T\n  ): T[number] | undefined {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: \"json\" satisfies Schema } as any;\n  },\n};\n\n/** @category Schema definition */\nexport const coField = {\n  string: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as string,\n  number: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as number,\n  boolean: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as boolean,\n  null: {\n    [SchemaInit]: \"json\" satisfies Schema,\n  } as unknown as null,\n  Date: {\n    [SchemaInit]: { encoded: Encoders.Date } satisfies Schema,\n  } as unknown as Date,\n  literal<T extends (string | number | boolean)[]>(..._lit: T): T[number] {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: \"json\" satisfies Schema } as any;\n  },\n  json<T extends CojsonInternalTypes.CoJsonValue<T>>(): T {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: \"json\" satisfies Schema } as any;\n  },\n  encoded<T>(arg: Encoder<T>): T {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return { [SchemaInit]: { encoded: arg } satisfies Schema } as any;\n  },\n  ref,\n  items: ItemsSym as ItemsSym,\n  optional,\n};\n\nfunction optionalRef<C extends CoValueClass>(\n  arg: C | ((_raw: InstanceType<C>[\"_raw\"]) => C),\n): InstanceType<C> | null | undefined {\n  return ref(arg, { optional: true });\n}\n\nfunction ref<C extends CoValueClass>(\n  arg: C | ((_raw: InstanceType<C>[\"_raw\"]) => C),\n  options?: never,\n): InstanceType<C> | null;\nfunction ref<C extends CoValueClass>(\n  arg: C | ((_raw: InstanceType<C>[\"_raw\"]) => C),\n  options: { optional: true },\n): InstanceType<C> | null | undefined;\nfunction ref<\n  C extends CoValueClass,\n  Options extends { optional?: boolean } | undefined,\n>(\n  arg: C | ((_raw: InstanceType<C>[\"_raw\"]) => C),\n  options?: Options,\n): Options extends { optional: true }\n  ? InstanceType<C> | null | undefined\n  : InstanceType<C> | null {\n  return {\n    [SchemaInit]: {\n      ref: arg,\n      optional: options?.optional || false,\n    } satisfies Schema,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } as any;\n}\n\nexport type JsonEncoded = \"json\";\nexport type EncodedAs<V> = { encoded: Encoder<V> | OptionalEncoder<V> };\nexport type RefEncoded<V extends CoValue> = {\n  ref: CoValueClass<V> | ((raw: RawCoValue) => CoValueClass<V>);\n  optional: boolean;\n};\n\nexport function isRefEncoded<V extends CoValue>(\n  schema: Schema,\n): schema is RefEncoded<V> {\n  return (\n    typeof schema === \"object\" &&\n    \"ref\" in schema &&\n    \"optional\" in schema &&\n    typeof schema.ref === \"function\"\n  );\n}\n\nexport function instantiateRefEncoded<V extends CoValue>(\n  schema: RefEncoded<V>,\n  raw: RawCoValue,\n): V {\n  return isCoValueClass<V>(schema.ref)\n    ? schema.ref.fromRaw(raw)\n    : (schema.ref as (raw: RawCoValue) => CoValueClass<V> & CoValueFromRaw<V>)(\n        raw,\n      ).fromRaw(raw);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Schema = JsonEncoded | RefEncoded<CoValue> | EncodedAs<any>;\n\nexport type SchemaFor<Field> = NonNullable<Field> extends CoValue\n  ? RefEncoded<NonNullable<Field>>\n  : NonNullable<Field> extends JsonValue\n    ? JsonEncoded\n    : EncodedAs<NonNullable<Field>>;\n\nexport type Encoder<V> = {\n  encode: (value: V) => JsonValue;\n  decode: (value: JsonValue) => V;\n};\nexport type OptionalEncoder<V> =\n  | Encoder<V>\n  | {\n      encode: (value: V | undefined) => JsonValue;\n      decode: (value: JsonValue) => V | undefined;\n    };\n","import type { CoValue } from \"../internal.js\";\n\nexport function applyCoValueMigrations(instance: CoValue) {\n  const node = instance._raw.core.node;\n\n  // @ts-expect-error _migratedCoValues is a custom expando property\n  const migratedCoValues = (node._migratedCoValues ??= new Set<string>());\n\n  if (\n    \"migrate\" in instance &&\n    typeof instance.migrate === \"function\" &&\n    instance._type !== \"Account\" &&\n    !migratedCoValues.has(instance.id)\n  ) {\n    // We flag this before the migration to avoid that internal loads trigger the migration again\n    migratedCoValues.add(instance.id);\n\n    const result = instance.migrate?.(instance);\n    if (result && \"then\" in result) {\n      throw new Error(\"Migration function cannot be async\");\n    }\n  }\n}\n","import { CoValueCore, LocalNode, RawCoMap, RawCoValue } from \"cojson\";\n\nexport class CoValueCoreSubscription {\n  _unsubscribe: () => void = () => {};\n  unsubscribed = false;\n\n  value: RawCoMap | undefined;\n\n  constructor(\n    public node: LocalNode,\n    public id: string,\n    public listener: (value: RawCoValue | \"unavailable\") => void,\n  ) {\n    const entry = this.node.getCoValue(this.id as any);\n\n    if (entry?.isAvailable()) {\n      this.subscribe(entry.getCurrentContent());\n    } else {\n      this.node.loadCoValueCore(this.id as any).then((value) => {\n        if (this.unsubscribed) return;\n\n        if (value.isAvailable()) {\n          this.subscribe(value.getCurrentContent());\n        } else {\n          this.listener(\"unavailable\");\n          this.subscribeToState();\n        }\n      });\n    }\n  }\n\n  subscribeToState() {\n    const entry = this.node.getCoValue(this.id as any);\n    const handleStateChange = (\n      core: CoValueCore,\n      unsubFromStateChange: () => void,\n    ) => {\n      if (this.unsubscribed) {\n        unsubFromStateChange();\n        return;\n      }\n\n      if (core.isAvailable()) {\n        this.subscribe(core.getCurrentContent());\n        unsubFromStateChange();\n      }\n    };\n\n    const unsubFromStateChange = entry.subscribe(handleStateChange);\n\n    this._unsubscribe = () => {\n      unsubFromStateChange();\n    };\n  }\n\n  subscribe(value: RawCoValue) {\n    if (this.unsubscribed) return;\n\n    this._unsubscribe = value.subscribe((value) => {\n      this.listener(value);\n    });\n\n    this.listener(value);\n  }\n\n  unsubscribe() {\n    if (this.unsubscribed) return;\n    this.unsubscribed = true;\n    this._unsubscribe();\n  }\n}\n","import type { CoValue, ID } from \"../internal.js\";\n\nexport class JazzError {\n  constructor(\n    public id: ID<CoValue> | undefined,\n    public type: \"unavailable\" | \"unauthorized\",\n    public issues: JazzErrorIssue[],\n  ) {}\n\n  toString() {\n    return this.issues\n      .map((issue) => {\n        let message = `${issue.message}`;\n\n        if (this.id) {\n          message += ` from ${this.id}`;\n        }\n\n        if (issue.path.length > 0) {\n          message += ` on path ${issue.path.join(\".\")}`;\n        }\n\n        return message;\n      })\n      .join(\"\\n\");\n  }\n\n  prependPath(item: string) {\n    if (this.issues.length === 0) {\n      return this;\n    }\n\n    const issues = this.issues.map((issue) => {\n      return {\n        ...issue,\n        path: [item].concat(issue.path),\n      };\n    });\n\n    return new JazzError(this.id, this.type, issues);\n  }\n}\nexport type JazzErrorIssue = {\n  code: \"unavailable\" | \"unauthorized\" | \"validationError\";\n  message: string;\n  params: Record<string, any>;\n  path: string[];\n};\n","import { RawAccount, RawCoValue } from \"cojson\";\nimport { RegisteredSchemas } from \"../coValues/registeredSchemas.js\";\nimport {\n  CoValue,\n  RefEncoded,\n  anySchemaToCoSchema,\n  instantiateRefEncoded,\n} from \"../internal.js\";\nimport { coValuesCache } from \"../lib/cache.js\";\nimport { SubscriptionScope } from \"./SubscriptionScope.js\";\n\nexport function getOwnerFromRawValue(raw: RawCoValue) {\n  const owner = raw.group;\n\n  return coValuesCache.get(owner, () =>\n    owner instanceof RawAccount\n      ? anySchemaToCoSchema(RegisteredSchemas[\"Account\"]).fromRaw(owner)\n      : RegisteredSchemas[\"Group\"].fromRaw(owner as any),\n  );\n}\n\nexport function createCoValue<D extends CoValue>(\n  ref: RefEncoded<D>,\n  raw: RawCoValue,\n  subscriptionScope: SubscriptionScope<D>,\n) {\n  const freshValueInstance = instantiateRefEncoded(ref, raw);\n\n  Object.defineProperty(freshValueInstance, \"_subscriptionScope\", {\n    value: subscriptionScope,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n\n  return {\n    type: \"loaded\" as const,\n    value: freshValueInstance,\n    id: subscriptionScope.id,\n  };\n}\n","import type { LocalNode, RawCoValue } from \"cojson\";\nimport {\n  CoFeed,\n  CoList,\n  CoMap,\n  type CoValue,\n  type ID,\n  type RefEncoded,\n  type RefsToResolve,\n  instantiateRefEncoded,\n  isRefEncoded,\n} from \"../internal.js\";\nimport { applyCoValueMigrations } from \"../lib/migration.js\";\nimport { CoValueCoreSubscription } from \"./CoValueCoreSubscription.js\";\nimport { JazzError, type JazzErrorIssue } from \"./JazzError.js\";\nimport type { SubscriptionValue, Unloaded } from \"./types.js\";\nimport { createCoValue, getOwnerFromRawValue } from \"./utils.js\";\n\nexport class SubscriptionScope<D extends CoValue> {\n  childNodes = new Map<string, SubscriptionScope<CoValue>>();\n  childValues: Map<string, SubscriptionValue<any, any> | Unloaded> = new Map<\n    string,\n    SubscriptionValue<D, any>\n  >();\n  value: SubscriptionValue<D, any> | Unloaded;\n  childErrors: Map<string, JazzError> = new Map();\n  validationErrors: Map<string, JazzError> = new Map();\n  errorFromChildren: JazzError | undefined;\n  subscription: CoValueCoreSubscription;\n  dirty = false;\n  resolve: RefsToResolve<any>;\n  idsSubscribed = new Set<string>();\n  autoloaded = new Set<string>();\n  autoloadedKeys = new Set<string>();\n  skipInvalidKeys = new Set<string>();\n  totalValidTransactions = 0;\n  migrated = false;\n  migrating = false;\n\n  silenceUpdates = false;\n\n  constructor(\n    public node: LocalNode,\n    resolve: RefsToResolve<D>,\n    public id: ID<D>,\n    public schema: RefEncoded<D>,\n  ) {\n    this.resolve = resolve;\n    this.value = { type: \"unloaded\", id };\n\n    let lastUpdate: RawCoValue | \"unavailable\" | undefined;\n    this.subscription = new CoValueCoreSubscription(node, id, (value) => {\n      lastUpdate = value;\n\n      // Need all these checks because the migration can trigger new syncronous updates\n      //\n      // We want to:\n      // - Run the migration only once\n      // - Skip all the updates until the migration is done\n      // - Trigger handleUpdate only with the final value\n      if (!this.migrated && value !== \"unavailable\") {\n        if (this.migrating) {\n          return;\n        }\n\n        this.migrating = true;\n        applyCoValueMigrations(instantiateRefEncoded(this.schema, value));\n        this.migrated = true;\n        this.handleUpdate(lastUpdate);\n        return;\n      }\n\n      this.handleUpdate(value);\n    });\n  }\n\n  updateValue(value: SubscriptionValue<D, any>) {\n    this.value = value;\n\n    // Flags that the value has changed and we need to trigger an update\n    this.dirty = true;\n  }\n\n  handleUpdate(update: RawCoValue | \"unavailable\") {\n    if (update === \"unavailable\") {\n      if (this.value.type === \"unloaded\") {\n        this.updateValue(\n          new JazzError(this.id, \"unavailable\", [\n            {\n              code: \"unavailable\",\n              message: \"The value is unavailable\",\n              params: {\n                id: this.id,\n              },\n              path: [],\n            },\n          ]),\n        );\n      }\n      this.triggerUpdate();\n      return;\n    }\n\n    const ruleset = update.core.verified.header.ruleset;\n\n    // Groups and accounts are accessible by everyone, for the other coValues we use the role to check access\n    const hasAccess =\n      ruleset.type !== \"ownedByGroup\" ||\n      getOwnerFromRawValue(update).myRole() !== undefined;\n\n    if (!hasAccess) {\n      if (this.value.type !== \"unauthorized\") {\n        this.updateValue(\n          new JazzError(this.id, \"unauthorized\", [\n            {\n              code: \"unauthorized\",\n              message:\n                \"The current user is not authorized to access this value\",\n              params: {\n                id: this.id,\n              },\n              path: [],\n            },\n          ]),\n        );\n        this.triggerUpdate();\n      }\n      return;\n    }\n\n    // When resolving a CoValue with available children, we want to trigger a single update\n    // after loading all the children, not one per children\n    this.silenceUpdates = true;\n\n    if (this.value.type !== \"loaded\") {\n      this.updateValue(createCoValue(this.schema, update, this));\n      this.loadChildren();\n    } else {\n      const hasChanged =\n        update.totalValidTransactions !== this.totalValidTransactions ||\n        // Checking the identity of the _raw value makes us cover the cases where the group\n        // has been updated and the coValues that don't update the totalValidTransactions value (e.g. FileStream)\n        this.value.value._raw !== update;\n\n      if (this.loadChildren()) {\n        this.updateValue(createCoValue(this.schema, update, this));\n      } else if (hasChanged) {\n        this.updateValue(createCoValue(this.schema, update, this));\n      }\n    }\n\n    this.totalValidTransactions = update.totalValidTransactions;\n\n    this.silenceUpdates = false;\n    this.triggerUpdate();\n  }\n\n  computeChildErrors() {\n    let issues: JazzErrorIssue[] = [];\n    let errorType: JazzError[\"type\"] = \"unavailable\";\n\n    if (this.childErrors.size === 0 && this.validationErrors.size === 0) {\n      return undefined;\n    }\n\n    for (const [key, value] of this.childErrors.entries()) {\n      // We don't want to block updates if the error is on an autoloaded value\n      if (this.autoloaded.has(key)) {\n        continue;\n      }\n\n      if (this.skipInvalidKeys.has(key)) {\n        continue;\n      }\n\n      errorType = value.type;\n      if (value.issues) {\n        issues.push(...value.issues);\n      }\n    }\n\n    for (const [key, value] of this.validationErrors.entries()) {\n      if (this.skipInvalidKeys.has(key)) {\n        continue;\n      }\n\n      errorType = value.type;\n      if (value.issues) {\n        issues.push(...value.issues);\n      }\n    }\n\n    if (issues.length) {\n      return new JazzError(this.id, errorType, issues);\n    }\n\n    return undefined;\n  }\n\n  handleChildUpdate = (\n    id: string,\n    value: SubscriptionValue<any, any> | Unloaded,\n    key?: string,\n  ) => {\n    if (value.type === \"unloaded\") {\n      return;\n    }\n\n    this.childValues.set(id, value);\n\n    if (value.type === \"unavailable\" || value.type === \"unauthorized\") {\n      this.childErrors.set(id, value.prependPath(key ?? id));\n\n      this.errorFromChildren = this.computeChildErrors();\n    } else if (this.errorFromChildren && this.childErrors.has(id)) {\n      this.childErrors.delete(id);\n\n      this.errorFromChildren = this.computeChildErrors();\n    }\n\n    if (this.shouldSendUpdates()) {\n      if (this.value.type === \"loaded\") {\n        // On child updates, we re-create the value instance to make the updates\n        // seamless-immutable and so be compatible with React and the React compiler\n        this.updateValue(\n          createCoValue(this.schema, this.value.value._raw, this),\n        );\n      }\n    }\n\n    this.triggerUpdate();\n  };\n\n  shouldSendUpdates() {\n    if (this.value.type === \"unloaded\") return false;\n\n    // If the value is in error, we send the update regardless of the children statuses\n    if (this.value.type !== \"loaded\") return true;\n\n    for (const value of this.childValues.values()) {\n      // We don't wait for autoloaded values to be loaded, in order to stream updates\n      // on autoloaded lists or records\n      if (value.type === \"unloaded\" && !this.autoloaded.has(value.id)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCurrentValue() {\n    if (\n      this.value.type === \"unauthorized\" ||\n      this.value.type === \"unavailable\"\n    ) {\n      console.error(this.value.toString());\n      return null;\n    }\n\n    if (!this.shouldSendUpdates()) {\n      return undefined;\n    }\n\n    if (this.errorFromChildren) {\n      console.error(this.errorFromChildren.toString());\n      return null;\n    }\n\n    if (this.value.type === \"loaded\") {\n      return this.value.value;\n    }\n\n    return undefined;\n  }\n\n  triggerUpdate() {\n    if (!this.shouldSendUpdates()) return;\n    if (!this.dirty) return;\n    if (this.subscribers.size === 0) return;\n    if (this.silenceUpdates) return;\n\n    const error = this.errorFromChildren;\n    const value = this.value;\n\n    if (error) {\n      this.subscribers.forEach((listener) => listener(error));\n    } else if (value.type !== \"unloaded\") {\n      this.subscribers.forEach((listener) => listener(value));\n    }\n\n    this.dirty = false;\n  }\n\n  subscribers = new Set<(value: SubscriptionValue<D, any>) => void>();\n  subscribe(listener: (value: SubscriptionValue<D, any>) => void) {\n    this.subscribers.add(listener);\n\n    return () => {\n      this.subscribers.delete(listener);\n    };\n  }\n\n  setListener(listener: (value: SubscriptionValue<D, any>) => void) {\n    this.subscribers.add(listener);\n    this.triggerUpdate();\n  }\n\n  subscribeToKey(key: string) {\n    if (this.resolve === true || !this.resolve) {\n      this.resolve = {};\n    }\n\n    if (this.resolve.$each || key in this.resolve) {\n      return;\n    }\n\n    const resolve = this.resolve as Record<string, any>;\n\n    // Adding the key to the resolve object to resolve the key when calling loadChildren\n    resolve[key] = true;\n    // Track the keys that are autoloaded to flag any id on that key as autoloaded\n    this.autoloadedKeys.add(key);\n\n    if (this.value.type !== \"loaded\") {\n      return;\n    }\n\n    const value = this.value.value;\n\n    // We don't want to trigger an update when autoloading available children\n    // because on userland it looks like nothing has changed since the value\n    // is available on the first access\n    // This helps alot with correctness when triggering the autoloading while rendering components (on React and Svelte)\n    this.silenceUpdates = true;\n\n    if (value._type === \"CoMap\" || value._type === \"Account\") {\n      const map = value as CoMap;\n\n      this.loadCoMapKey(map, key, true);\n    } else if (value._type === \"CoList\") {\n      const list = value as CoList;\n\n      this.loadCoListKey(list, key, true);\n    }\n\n    this.silenceUpdates = false;\n  }\n\n  subscribeToId(id: string, descriptor: RefEncoded<any>) {\n    if (this.idsSubscribed.has(id) || this.childValues.has(id)) {\n      return;\n    }\n\n    this.idsSubscribed.add(id);\n    this.autoloaded.add(id);\n\n    // We don't want to trigger an update when autoloading available children\n    // because on userland it looks like nothing has changed since the value\n    // is available on the first access\n    // This helps alot with correctness when triggering the autoloading while rendering components (on React and Svelte)\n    this.silenceUpdates = true;\n\n    this.childValues.set(id, { type: \"unloaded\", id });\n    const child = new SubscriptionScope(\n      this.node,\n      true,\n      id as ID<any>,\n      descriptor,\n    );\n    this.childNodes.set(id, child);\n    child.setListener((value) => this.handleChildUpdate(id, value));\n\n    this.silenceUpdates = false;\n  }\n\n  loadChildren() {\n    const { resolve } = this;\n\n    if (this.value.type !== \"loaded\") {\n      return false;\n    }\n\n    const value = this.value.value;\n\n    const depth =\n      typeof resolve !== \"object\" || resolve === null ? {} : (resolve as any);\n\n    let hasChanged = false;\n\n    const idsToLoad = new Set<string>(this.idsSubscribed);\n\n    const coValueType = value._type;\n\n    if (Object.keys(depth).length > 0) {\n      if (coValueType === \"CoMap\" || coValueType === \"Account\") {\n        const map = value as CoMap;\n        const keys = \"$each\" in depth ? map._raw.keys() : Object.keys(depth);\n\n        for (const key of keys) {\n          const id = this.loadCoMapKey(map, key, depth[key] ?? depth.$each);\n\n          if (id) {\n            idsToLoad.add(id);\n          }\n        }\n      } else if (value._type === \"CoList\") {\n        const list = value as CoList;\n\n        const descriptor = list.getItemsDescriptor();\n\n        if (descriptor && isRefEncoded(descriptor)) {\n          list._raw.processNewTransactions();\n          const entries = list._raw.entries();\n          const keys =\n            \"$each\" in depth ? Object.keys(entries) : Object.keys(depth);\n\n          for (const key of keys) {\n            const id = this.loadCoListKey(list, key, depth[key] ?? depth.$each);\n\n            if (id) {\n              idsToLoad.add(id);\n            }\n          }\n        }\n      } else if (value._type === \"CoStream\") {\n        const stream = value as CoFeed;\n        const descriptor = stream.getItemsDescriptor();\n\n        if (descriptor && isRefEncoded(descriptor)) {\n          for (const session of stream._raw.sessions()) {\n            const values = stream._raw.items[session] ?? [];\n\n            for (const [i, item] of values.entries()) {\n              const key = `${session}/${i}`;\n\n              if (!depth.$each && !depth[key]) {\n                continue;\n              }\n\n              const id = item.value as string | undefined;\n\n              if (id) {\n                idsToLoad.add(id);\n                this.loadChildNode(id, depth[key] ?? depth.$each, descriptor);\n                this.validationErrors.delete(key);\n              } else if (!descriptor.optional) {\n                this.validationErrors.set(\n                  key,\n                  new JazzError(undefined, \"unavailable\", [\n                    {\n                      code: \"validationError\",\n                      message: `The ref on position ${key} requested on ${stream.constructor.name} is missing`,\n                      params: {},\n                      path: [key],\n                    },\n                  ]),\n                );\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this.errorFromChildren = this.computeChildErrors();\n\n    // Collect all the deleted ids\n    for (const id of this.childNodes.keys()) {\n      if (!idsToLoad.has(id)) {\n        hasChanged = true;\n        const childNode = this.childNodes.get(id);\n\n        if (childNode) {\n          childNode.destroy();\n        }\n\n        this.childNodes.delete(id);\n        this.childValues.delete(id);\n      }\n    }\n\n    return hasChanged;\n  }\n\n  loadCoMapKey(map: CoMap, key: string, depth: Record<string, any> | true) {\n    if (key === \"$onError\") {\n      return undefined;\n    }\n\n    const id = map._raw.get(key) as string | undefined;\n    const descriptor = map.getDescriptor(key);\n\n    if (!descriptor) {\n      this.childErrors.set(\n        key,\n        new JazzError(undefined, \"unavailable\", [\n          {\n            code: \"validationError\",\n            message: `The ref ${key} requested on ${map.constructor.name} is not defined in the schema`,\n            params: {},\n            path: [key],\n          },\n        ]),\n      );\n      return undefined;\n    }\n\n    if (isRefEncoded(descriptor)) {\n      if (id) {\n        this.loadChildNode(id, depth, descriptor, key);\n        this.validationErrors.delete(key);\n\n        return id;\n      } else if (!descriptor.optional) {\n        this.validationErrors.set(\n          key,\n          new JazzError(undefined, \"unavailable\", [\n            {\n              code: \"validationError\",\n              message: `The ref ${key} requested on ${map.constructor.name} is missing`,\n              params: {},\n              path: [key],\n            },\n          ]),\n        );\n      }\n    }\n\n    return undefined;\n  }\n\n  loadCoListKey(list: CoList, key: string, depth: Record<string, any> | true) {\n    const descriptor = list.getItemsDescriptor();\n\n    if (!descriptor || !isRefEncoded(descriptor)) {\n      return undefined;\n    }\n\n    const entries = list._raw.entries();\n    const entry = entries[Number(key)];\n\n    if (!entry) {\n      return undefined;\n    }\n\n    const id = entry.value as string | undefined;\n\n    if (id) {\n      this.loadChildNode(id, depth, descriptor, key);\n      this.validationErrors.delete(key);\n\n      return id;\n    } else if (!descriptor.optional) {\n      this.validationErrors.set(\n        key,\n        new JazzError(undefined, \"unavailable\", [\n          {\n            code: \"validationError\",\n            message: `The ref on position ${key} requested on ${list.constructor.name} is missing`,\n            params: {},\n            path: [key],\n          },\n        ]),\n      );\n    }\n\n    return undefined;\n  }\n\n  loadChildNode(\n    id: string,\n    query: RefsToResolve<any>,\n    descriptor: RefEncoded<any>,\n    key?: string,\n  ) {\n    if (this.childValues.has(id)) {\n      return;\n    }\n\n    if (key && this.autoloadedKeys.has(key)) {\n      this.autoloaded.add(id);\n    }\n\n    const skipInvalid = typeof query === \"object\" && query.$onError === null;\n\n    if (skipInvalid) {\n      if (key) {\n        this.skipInvalidKeys.add(key);\n      }\n\n      this.skipInvalidKeys.add(id);\n    }\n\n    // Cloning the resolve objects to avoid mutating the original object when tracking autoloaded values\n    const resolve =\n      typeof query === \"object\" && query !== null ? { ...query } : query;\n\n    this.childValues.set(id, { type: \"unloaded\", id });\n    const child = new SubscriptionScope(\n      this.node,\n      resolve,\n      id as ID<any>,\n      descriptor,\n    );\n    this.childNodes.set(id, child);\n    child.setListener((value) => this.handleChildUpdate(id, value, key));\n  }\n\n  destroy() {\n    this.subscription.unsubscribe();\n    this.subscribers.clear();\n    this.childNodes.forEach((child) => child.destroy());\n  }\n}\n","import type { CoValue, CoValueClass, RefEncoded } from \"../internal.js\";\nimport { SubscriptionScope } from \"./SubscriptionScope.js\";\n\nexport function getSubscriptionScope<D extends CoValue>(value: D) {\n  const subscriptionScope = value._subscriptionScope;\n\n  if (subscriptionScope) {\n    return subscriptionScope;\n  }\n\n  const node = value._raw.core.node;\n  const resolve = true;\n  const id = value.id;\n\n  const newSubscriptionScope = new SubscriptionScope(node, resolve, id, {\n    ref: value.constructor as CoValueClass<D>,\n    optional: false,\n  });\n\n  Object.defineProperty(value, \"_subscriptionScope\", {\n    value: subscriptionScope,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n\n  return newSubscriptionScope;\n}\n\n/** Autoload internals */\n\n/**\n * Given a coValue, access a child coValue by key\n *\n * By subscribing to a given key, the subscription will automatically react to the id changes\n * on that key (e.g. deleting the key value will result on unsubscribing from the id)\n */\nexport function accessChildByKey<D extends CoValue>(\n  parent: D,\n  childId: string,\n  key: string,\n) {\n  const subscriptionScope = getSubscriptionScope(parent);\n\n  if (!subscriptionScope.childValues.has(childId)) {\n    subscriptionScope.subscribeToKey(key);\n  }\n\n  const value = subscriptionScope.childValues.get(childId);\n\n  if (value?.type === \"loaded\") {\n    return value.value;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Given a coValue, access a child coValue by id\n *\n * By subscribing to a given id, the subscription becomes permanent and will unsubscribe\n * only when the root subscription scope is destroyed.\n *\n * Used for refs that never change (e.g. CoFeed entries, CoMap edits)\n */\nexport function accessChildById<D extends CoValue>(\n  parent: D,\n  childId: string,\n  schema: RefEncoded<CoValue>,\n) {\n  const subscriptionScope = getSubscriptionScope(parent);\n\n  subscriptionScope.subscribeToId(childId, schema);\n\n  const value = subscriptionScope.childValues.get(childId);\n\n  if (value?.type === \"loaded\") {\n    return value.value;\n  } else {\n    return null;\n  }\n}\n","import {\n  AgentSecret,\n  CoID,\n  ControlledAgent,\n  CryptoProvider,\n  LocalNode,\n  Peer,\n  RawAccount,\n  RawAccountID,\n  SessionID,\n} from \"cojson\";\nimport { AuthSecretStorage } from \"../auth/AuthSecretStorage.js\";\nimport { type Account, type AccountClass } from \"../coValues/account.js\";\nimport { RegisteredSchemas } from \"../coValues/registeredSchemas.js\";\nimport {\n  type AccountSchema,\n  type AnyAccountSchema,\n  CoValueFromRaw,\n  type ID,\n  type InstanceOfSchema,\n  anySchemaToCoSchema,\n} from \"../internal.js\";\nimport { AuthCredentials, NewAccountProps } from \"../types.js\";\nimport { activeAccountContext } from \"./activeAccountContext.js\";\nimport { AnonymousJazzAgent } from \"./anonymousJazzAgent.js\";\n\nexport type Credentials = {\n  accountID: ID<Account>;\n  secret: AgentSecret;\n};\n\ntype SessionProvider = (\n  accountID: ID<Account>,\n  crypto: CryptoProvider,\n) => Promise<{ sessionID: SessionID; sessionDone: () => void }>;\n\nexport type AuthResult =\n  | {\n      type: \"existing\";\n      username?: string;\n      credentials: Credentials;\n      saveCredentials?: (credentials: Credentials) => Promise<void>;\n      onSuccess: () => void;\n      onError: (error: string | Error) => void;\n      logOut: () => Promise<void>;\n    }\n  | {\n      type: \"new\";\n      creationProps: {\n        name: string;\n        anonymous?: boolean;\n        other?: Record<string, unknown>;\n      };\n      initialSecret?: AgentSecret;\n      saveCredentials: (credentials: Credentials) => Promise<void>;\n      onSuccess: () => void;\n      onError: (error: string | Error) => void;\n      logOut: () => Promise<void>;\n    };\n\nexport async function randomSessionProvider(\n  accountID: ID<Account>,\n  crypto: CryptoProvider,\n) {\n  return {\n    sessionID: crypto.newRandomSessionID(accountID as unknown as RawAccountID),\n    sessionDone: () => {},\n  };\n}\n\nexport type JazzContextWithAccount<Acc extends Account> = {\n  node: LocalNode;\n  account: Acc;\n  done: () => void;\n  logOut: () => Promise<void>;\n};\n\nexport type JazzContextWithAgent = {\n  agent: AnonymousJazzAgent;\n  done: () => void;\n  logOut: () => Promise<void>;\n};\n\nexport type JazzContext<Acc extends Account> =\n  | JazzContextWithAccount<Acc>\n  | JazzContextWithAgent;\n\nexport async function createJazzContextFromExistingCredentials<\n  S extends\n    | (AccountClass<Account> & CoValueFromRaw<Account>)\n    | AnyAccountSchema,\n>({\n  credentials,\n  peersToLoadFrom,\n  crypto,\n  AccountSchema: PropsAccountSchema,\n  sessionProvider,\n  onLogOut,\n}: {\n  credentials: Credentials;\n  peersToLoadFrom: Peer[];\n  crypto: CryptoProvider;\n  AccountSchema?: S;\n  sessionProvider: SessionProvider;\n  onLogOut?: () => void;\n}): Promise<JazzContextWithAccount<InstanceOfSchema<S>>> {\n  const { sessionID, sessionDone } = await sessionProvider(\n    credentials.accountID,\n    crypto,\n  );\n\n  const CurrentAccountSchema =\n    PropsAccountSchema ?? (RegisteredSchemas[\"Account\"] as unknown as S);\n\n  const AccountClass = anySchemaToCoSchema(CurrentAccountSchema);\n\n  const node = await LocalNode.withLoadedAccount({\n    accountID: credentials.accountID as unknown as CoID<RawAccount>,\n    accountSecret: credentials.secret,\n    sessionID: sessionID,\n    peersToLoadFrom: peersToLoadFrom,\n    crypto: crypto,\n    migration: async (rawAccount, _node, creationProps) => {\n      const account = AccountClass.fromRaw(rawAccount) as InstanceOfSchema<S>;\n      activeAccountContext.set(account);\n\n      await account.applyMigration(creationProps);\n    },\n  });\n\n  const account = AccountClass.fromNode(node);\n  activeAccountContext.set(account);\n\n  return {\n    node,\n    account: account as InstanceOfSchema<S>,\n    done: () => {\n      node.gracefulShutdown();\n      sessionDone();\n    },\n    logOut: async () => {\n      node.gracefulShutdown();\n      sessionDone();\n      await onLogOut?.();\n    },\n  };\n}\n\nexport async function createJazzContextForNewAccount<\n  S extends\n    | (AccountClass<Account> & CoValueFromRaw<Account>)\n    | AnyAccountSchema,\n>({\n  creationProps,\n  initialAgentSecret,\n  peersToLoadFrom,\n  crypto,\n  AccountSchema: PropsAccountSchema,\n  onLogOut,\n}: {\n  creationProps: { name: string };\n  initialAgentSecret?: AgentSecret;\n  peersToLoadFrom: Peer[];\n  crypto: CryptoProvider;\n  AccountSchema?: S;\n  onLogOut?: () => Promise<void>;\n}): Promise<JazzContextWithAccount<InstanceOfSchema<S>>> {\n  const CurrentAccountSchema =\n    PropsAccountSchema ?? (RegisteredSchemas[\"Account\"] as unknown as S);\n\n  const AccountClass = anySchemaToCoSchema(CurrentAccountSchema);\n\n  const { node } = await LocalNode.withNewlyCreatedAccount({\n    creationProps,\n    peersToLoadFrom,\n    crypto,\n    initialAgentSecret,\n    migration: async (rawAccount, _node, creationProps) => {\n      const account = AccountClass.fromRaw(rawAccount) as InstanceOfSchema<S>;\n      activeAccountContext.set(account);\n\n      await account.applyMigration(creationProps);\n    },\n  });\n\n  const account = AccountClass.fromNode(node);\n  activeAccountContext.set(account);\n\n  return {\n    node,\n    account: account as InstanceOfSchema<S>,\n    done: () => {\n      node.gracefulShutdown();\n    },\n    logOut: async () => {\n      node.gracefulShutdown();\n      await onLogOut?.();\n    },\n  };\n}\n\nexport async function createJazzContext<\n  S extends\n    | (AccountClass<Account> & CoValueFromRaw<Account>)\n    | AnyAccountSchema,\n>(options: {\n  credentials?: AuthCredentials;\n  newAccountProps?: NewAccountProps;\n  peersToLoadFrom: Peer[];\n  crypto: CryptoProvider;\n  defaultProfileName?: string;\n  AccountSchema?: S;\n  sessionProvider: SessionProvider;\n  authSecretStorage: AuthSecretStorage;\n}) {\n  const crypto = options.crypto;\n\n  let context: JazzContextWithAccount<InstanceOfSchema<S>>;\n\n  const authSecretStorage = options.authSecretStorage;\n\n  await authSecretStorage.migrate();\n\n  const credentials = options.credentials ?? (await authSecretStorage.get());\n\n  if (credentials && !options.newAccountProps) {\n    context = await createJazzContextFromExistingCredentials({\n      credentials: {\n        accountID: credentials.accountID,\n        secret: credentials.accountSecret,\n      },\n      peersToLoadFrom: options.peersToLoadFrom,\n      crypto,\n      AccountSchema: options.AccountSchema,\n      sessionProvider: options.sessionProvider,\n      onLogOut: () => {\n        authSecretStorage.clearWithoutNotify();\n      },\n    });\n  } else {\n    const secretSeed = options.crypto.newRandomSecretSeed();\n\n    const initialAgentSecret =\n      options.newAccountProps?.secret ??\n      crypto.agentSecretFromSecretSeed(secretSeed);\n\n    const creationProps = options.newAccountProps?.creationProps ?? {\n      name: options.defaultProfileName ?? \"Anonymous user\",\n    };\n\n    context = await createJazzContextForNewAccount({\n      creationProps,\n      initialAgentSecret,\n      peersToLoadFrom: options.peersToLoadFrom,\n      crypto,\n      AccountSchema: options.AccountSchema,\n      onLogOut: async () => {\n        await authSecretStorage.clearWithoutNotify();\n      },\n    });\n\n    if (!options.newAccountProps) {\n      await authSecretStorage.setWithoutNotify({\n        accountID: context.account.id,\n        secretSeed,\n        accountSecret: context.node.getCurrentAgent().agentSecret,\n        provider: \"anonymous\",\n      });\n    }\n  }\n\n  return {\n    ...context,\n    authSecretStorage,\n  };\n}\n\nexport function createAnonymousJazzContext({\n  peersToLoadFrom,\n  crypto,\n}: {\n  peersToLoadFrom: Peer[];\n  crypto: CryptoProvider;\n}): JazzContextWithAgent {\n  const agentSecret = crypto.newRandomAgentSecret();\n\n  const node = new LocalNode(\n    agentSecret,\n    crypto.newRandomSessionID(crypto.getAgentID(agentSecret)),\n    crypto,\n  );\n\n  for (const peer of peersToLoadFrom) {\n    node.syncManager.addPeer(peer);\n  }\n\n  activeAccountContext.setGuestMode();\n\n  return {\n    agent: new AnonymousJazzAgent(node),\n    done: () => {},\n    logOut: async () => {},\n  };\n}\n","import { LocalNode, RawAccount } from \"cojson\";\nimport {\n  Account,\n  AccountClass,\n  CoValue,\n  CoValueClass,\n  CoValueFromRaw,\n  RefsToResolve,\n  RefsToResolveStrict,\n  Resolved,\n  Simplify,\n} from \"../../internal.js\";\nimport { AnyAccountSchema } from \"./schemaTypes/AccountSchema.js\";\nimport { AnyCoFeedSchema } from \"./schemaTypes/CoFeedSchema.js\";\nimport { AnyCoListSchema } from \"./schemaTypes/CoListSchema.js\";\nimport { AnyCoMapSchema, CoMapInitZod } from \"./schemaTypes/CoMapSchema.js\";\nimport { AnyCoRecordSchema } from \"./schemaTypes/CoRecordSchema.js\";\nimport { FileStreamSchema } from \"./schemaTypes/FileStreamSchema.js\";\nimport { PlainTextSchema } from \"./schemaTypes/PlainTextSchema.js\";\nimport { RichTextSchema } from \"./schemaTypes/RichTextSchema.js\";\nimport { InstanceOfSchema } from \"./typeConverters/InstanceOfSchema.js\";\nimport { InstanceOfSchemaCoValuesNullable } from \"./typeConverters/InstanceOfSchemaCoValuesNullable.js\";\nimport { z } from \"./zodReExport.js\";\n\n// defining an extra type for this, otherwise BaseSchema & {...} often\n// gets expanded into a n inferred type that's too long for typescript to print\nexport type WithHelpers<\n  Base extends z.core.$ZodType,\n  Helpers extends object,\n> = Base & Helpers;\n\nexport type ZodPrimitiveSchema =\n  | z.core.$ZodString\n  | z.core.$ZodNumber\n  | z.core.$ZodBoolean\n  | z.core.$ZodNull\n  | z.core.$ZodDate\n  | z.core.$ZodLiteral;\n\nexport type AnyCoUnionSchema = z.core.$ZodDiscriminatedUnion<\n  (\n    | (z.core.$ZodType & { collaborative: true })\n    | z.core.$ZodDiscriminatedUnion\n  )[]\n>;\n\n// this is a series of hacks to work around z4 removing _zod at runtime from z.core.$ZodType\nexport function isZodObject(\n  schema: z.core.$ZodType,\n): schema is z.core.$ZodObject<any, any> {\n  return (schema as any).def?.type === \"object\";\n}\n\nexport function isZodArray(\n  schema: z.core.$ZodType,\n): schema is z.core.$ZodArray<any> {\n  return (schema as any).def?.type === \"array\";\n}\n\nexport function isZodCustom(\n  schema: z.core.$ZodType,\n): schema is z.core.$ZodCustom<any, any> {\n  return (schema as any).def?.type === \"custom\";\n}\n\nexport function getDef<S extends z.core.$ZodType>(schema: S): S[\"_zod\"][\"def\"] {\n  return (schema as any).def;\n}\n\nexport type CoValueOrZodSchema = CoValueClass | AnyCoSchema;\n\nexport type CoValueClassFromZodSchema<S extends z.core.$ZodType> = CoValueClass<\n  InstanceOfSchema<S>\n> &\n  CoValueFromRaw<InstanceOfSchema<S>> &\n  (S extends AnyAccountSchema ? AccountClassEssentials : {});\n\ntype AccountClassEssentials = {\n  fromRaw: <A extends Account>(this: AccountClass<A>, raw: RawAccount) => A;\n  fromNode: <A extends Account>(this: AccountClass<A>, node: LocalNode) => A;\n};\n\nexport type AnyCoSchema =\n  | AnyCoMapSchema\n  | AnyAccountSchema\n  | AnyCoRecordSchema\n  | AnyCoListSchema\n  | AnyCoFeedSchema\n  | AnyCoUnionSchema\n  | PlainTextSchema\n  | RichTextSchema\n  | FileStreamSchema;\n\nexport type Loaded<\n  T extends CoValueClass | AnyCoSchema,\n  R extends ResolveQuery<T> = true,\n> = Resolved<NonNullable<InstanceOfSchemaCoValuesNullable<T>>, R>;\n\nexport type ResolveQuery<T extends CoValueClass | AnyCoSchema> = RefsToResolve<\n  NonNullable<InstanceOfSchemaCoValuesNullable<T>>\n>;\n\nexport type ResolveQueryStrict<\n  T extends CoValueClass | AnyCoSchema,\n  R extends ResolveQuery<T>,\n> = RefsToResolveStrict<NonNullable<InstanceOfSchemaCoValuesNullable<T>>, R>;\n\nexport type InitFor<T extends CoValueClass | AnyCoSchema> =\n  T extends AnyCoMapSchema<infer Shape> ? Simplify<CoMapInitZod<Shape>> : never;\n","import {\n  type Account,\n  AccountCreationProps,\n  AccountSchema,\n  AnyCoMapSchema,\n  CoFeed,\n  CoFeedSchema,\n  CoListSchema,\n  CoMapSchema,\n  CoPlainText,\n  CoProfileSchema,\n  CoRecordSchema,\n  CoRichText,\n  DefaultProfileShape,\n  FileStream,\n  FileStreamSchema,\n  ImageDefinition,\n  PlainTextSchema,\n  Simplify,\n  zodSchemaToCoSchema,\n} from \"../../internal.js\";\nimport { RichTextSchema } from \"./schemaTypes/RichTextSchema.js\";\nimport { z } from \"./zodReExport.js\";\n\nfunction enrichCoMapSchema<Shape extends z.core.$ZodLooseShape>(\n  schema: z.ZodObject<\n    { -readonly [P in keyof Shape]: Shape[P] },\n    z.core.$strip\n  >,\n) {\n  const baseCatchall = schema.catchall;\n\n  const enrichedSchema = Object.assign(schema, {\n    collaborative: true,\n    create: (...args: any[]) => {\n      return coSchema.create(...args);\n    },\n    load: (...args: any[]) => {\n      return coSchema.load(...args);\n    },\n    subscribe: (...args: any[]) => {\n      return coSchema.subscribe(...args);\n    },\n    findUnique: (...args: any[]) => {\n      return coSchema.findUnique(...args);\n    },\n    catchall: (index: z.core.$ZodType) => {\n      return enrichCoMapSchema(baseCatchall(index));\n    },\n    withHelpers: (helpers: (Self: z.core.$ZodType) => object) => {\n      return Object.assign(schema, helpers(schema));\n    },\n    withMigration: (migration: (value: any) => undefined) => {\n      coSchema.prototype.migrate = migration;\n\n      return enrichedSchema;\n    },\n    getCoSchema: () => {\n      return coSchema;\n    },\n  }) as unknown as CoMapSchema<Shape>;\n\n  // Needs to be derived from the enriched schema\n  const coSchema = zodSchemaToCoSchema(enrichedSchema) as any;\n\n  return enrichedSchema;\n}\n\nexport const coMapDefiner = <Shape extends z.core.$ZodLooseShape>(\n  shape: Shape,\n): CoMapSchema<Shape> => {\n  const objectSchema = z.object(shape).meta({\n    collaborative: true,\n  });\n\n  return enrichCoMapSchema(objectSchema);\n};\n\nfunction enrichAccountSchema<\n  Shape extends {\n    profile: AnyCoMapSchema<{\n      name: z.core.$ZodString<string>;\n      inbox?: z.core.$ZodOptional<z.core.$ZodString>;\n      inboxInvite?: z.core.$ZodOptional<z.core.$ZodString>;\n    }>;\n    root: AnyCoMapSchema;\n  },\n>(schema: z.ZodObject<Shape, z.core.$strip>) {\n  const enrichedSchema = Object.assign(schema, {\n    collaborative: true,\n    builtin: \"Account\",\n    create: (...args: any[]) => {\n      return coSchema.create(...args);\n    },\n    createAs: (...args: any[]) => {\n      return coSchema.createAs(...args);\n    },\n    getMe: (...args: any[]) => {\n      return coSchema.getMe(...args);\n    },\n    load: (...args: any[]) => {\n      return coSchema.load(...args);\n    },\n    subscribe: (...args: any[]) => {\n      return coSchema.subscribe(...args);\n    },\n    withHelpers: (helpers: (Self: z.core.$ZodType) => object) => {\n      return Object.assign(schema, helpers(schema));\n    },\n    fromRaw: (...args: any[]) => {\n      return coSchema.fromRaw(...args);\n    },\n    withMigration: (\n      migration: (\n        value: any,\n        creationProps?: AccountCreationProps,\n      ) => void | Promise<void>,\n    ) => {\n      (coSchema.prototype as Account).migrate = async function (\n        this,\n        creationProps,\n      ) {\n        await migration(this, creationProps);\n      };\n\n      return enrichedSchema;\n    },\n    getCoSchema: () => {\n      return coSchema;\n    },\n  }) as unknown as AccountSchema<Shape>;\n\n  // Needs to be derived from the enriched schema\n  const coSchema = zodSchemaToCoSchema(enrichedSchema) as any;\n\n  return enrichedSchema;\n}\n\nexport const coAccountDefiner = <\n  Shape extends {\n    profile: AnyCoMapSchema<{\n      name: z.core.$ZodString<string>;\n      inbox?: z.core.$ZodOptional<z.core.$ZodString>;\n      inboxInvite?: z.core.$ZodOptional<z.core.$ZodString>;\n    }>;\n    root: AnyCoMapSchema;\n  },\n>(\n  shape: Shape = {\n    profile: coMapDefiner({\n      name: z.string(),\n      inbox: z.optional(z.string()),\n      inboxInvite: z.optional(z.string()),\n    }),\n    root: coMapDefiner({}),\n  } as unknown as Shape,\n): AccountSchema<Shape> => {\n  const objectSchema = z.object(shape).meta({\n    collaborative: true,\n  });\n\n  return enrichAccountSchema(objectSchema) as unknown as AccountSchema<Shape>;\n};\n\nexport const coRecordDefiner = <\n  K extends z.core.$ZodString<string>,\n  V extends z.core.$ZodType,\n>(\n  _keyType: K,\n  valueType: V,\n): CoRecordSchema<K, V> => {\n  return coMapDefiner({}).catchall(valueType) as unknown as CoRecordSchema<\n    K,\n    V\n  >;\n};\n\nfunction enrichCoListSchema<T extends z.core.$ZodType>(schema: z.ZodArray<T>) {\n  const enrichedSchema = Object.assign(schema, {\n    collaborative: true,\n    create: (...args: any[]) => {\n      return coSchema.create(...args);\n    },\n    load: (...args: any[]) => {\n      return coSchema.load(...args);\n    },\n    subscribe: (...args: any[]) => {\n      return coSchema.subscribe(...args);\n    },\n    withHelpers: (helpers: (Self: z.core.$ZodType) => object) => {\n      return Object.assign(schema, helpers(schema));\n    },\n    getCoSchema: () => {\n      return coSchema;\n    },\n  }) as unknown as CoListSchema<T>;\n\n  // Needs to be derived from the enriched schema\n  const coSchema = zodSchemaToCoSchema(enrichedSchema) as any;\n\n  return enrichedSchema;\n}\n\nexport const coListDefiner = <T extends z.core.$ZodType>(\n  element: T,\n): CoListSchema<T> => {\n  const arraySchema = z.array(element).meta({\n    collaborative: true,\n  });\n\n  return enrichCoListSchema(arraySchema);\n};\n\nexport const coProfileDefiner = <\n  Shape extends z.core.$ZodLooseShape = Simplify<DefaultProfileShape>,\n>(\n  shape: Shape & {\n    name?: z.core.$ZodString<string>;\n    inbox?: z.core.$ZodOptional<z.core.$ZodString>;\n    inboxInvite?: z.core.$ZodOptional<z.core.$ZodString>;\n  } = {} as any,\n): CoProfileSchema<Shape> => {\n  const ehnancedShape = Object.assign(shape ?? {}, {\n    name: z.string(),\n    inbox: z.optional(z.string()),\n    inboxInvite: z.optional(z.string()),\n  });\n\n  return coMapDefiner(ehnancedShape) as CoProfileSchema<Shape>;\n};\n\nfunction enrichCoFeedSchema<T extends z.core.$ZodType>(\n  schema: z.ZodCustom<CoFeed<unknown>, unknown>,\n  element: T,\n) {\n  const enrichedSchema = Object.assign(schema, {\n    collaborative: true,\n    builtin: \"CoFeed\",\n    element,\n    create: (...args: any[]) => {\n      return coSchema.create(...args);\n    },\n    load: (...args: any[]) => {\n      return coSchema.load(...args);\n    },\n    subscribe: (...args: any[]) => {\n      return coSchema.subscribe(...args);\n    },\n    withHelpers: (helpers: (Self: z.core.$ZodType) => object) => {\n      return Object.assign(schema, helpers(schema));\n    },\n    getCoSchema: () => {\n      return coSchema;\n    },\n  }) as unknown as CoFeedSchema<T>;\n\n  // Needs to be derived from the enriched schema\n  const coSchema = zodSchemaToCoSchema(enrichedSchema) as any;\n\n  return enrichedSchema;\n}\n\nexport const coFeedDefiner = <T extends z.core.$ZodType>(\n  element: T,\n): CoFeedSchema<T> => {\n  return enrichCoFeedSchema(z.instanceof(CoFeed), element);\n};\n\nfunction enrichFileStreamSchema(schema: z.ZodCustom<FileStream, unknown>) {\n  const enrichedSchema = Object.assign(schema, {\n    collaborative: true,\n    builtin: \"FileStream\",\n    create: (...args: any[]) => {\n      return coSchema.create(...args);\n    },\n    createFromBlob: (...args: any[]) => {\n      return coSchema.createFromBlob(...args);\n    },\n    load: (...args: any[]) => {\n      return coSchema.load(...args);\n    },\n    loadAsBlob: (...args: any[]) => {\n      return coSchema.loadAsBlob(...args);\n    },\n    subscribe: (...args: any[]) => {\n      return coSchema.subscribe(...args);\n    },\n    getCoSchema: () => {\n      return coSchema;\n    },\n  }) as unknown as FileStreamSchema;\n\n  // Needs to be derived from the enriched schema\n  const coSchema = zodSchemaToCoSchema(enrichedSchema) as any;\n\n  return enrichedSchema;\n}\n\nexport const coFileStreamDefiner = (): FileStreamSchema => {\n  return enrichFileStreamSchema(z.instanceof(FileStream));\n};\n\nfunction enrichPlainTextSchema(schema: z.ZodCustom<CoPlainText, unknown>) {\n  const enrichedSchema = Object.assign(schema, {\n    collaborative: true,\n    builtin: \"CoPlainText\",\n    create: (...args: any[]) => {\n      return coSchema.create(...args);\n    },\n    load: (...args: any[]) => {\n      return coSchema.load(...args);\n    },\n    subscribe: (...args: any[]) => {\n      return coSchema.subscribe(...args);\n    },\n    fromRaw: (...args: any[]) => {\n      return coSchema.fromRaw(...args);\n    },\n    getCoSchema: () => {\n      return coSchema;\n    },\n  }) as unknown as PlainTextSchema;\n\n  // Needs to be derived from the enriched schema\n  const coSchema = zodSchemaToCoSchema(enrichedSchema) as any;\n\n  return enrichedSchema;\n}\n\nexport const coPlainTextDefiner = (): PlainTextSchema => {\n  return enrichPlainTextSchema(z.instanceof(CoPlainText));\n};\n\nfunction enrichRichTextSchema(schema: z.ZodCustom<CoRichText, unknown>) {\n  const enrichedSchema = Object.assign(schema, {\n    collaborative: true,\n    builtin: \"CoRichText\",\n    create: (...args: any[]) => {\n      return coSchema.create(...args);\n    },\n    load: (...args: any[]) => {\n      return coSchema.load(...args);\n    },\n    subscribe: (...args: any[]) => {\n      return coSchema.subscribe(...args);\n    },\n    getCoSchema: () => {\n      return coSchema;\n    },\n  }) as unknown as RichTextSchema;\n\n  // Needs to be derived from the enriched schema\n  const coSchema = zodSchemaToCoSchema(enrichedSchema) as any;\n\n  return enrichedSchema;\n}\n\nexport const coRichTextDefiner = (): RichTextSchema => {\n  return enrichRichTextSchema(z.instanceof(CoRichText));\n};\n\nexport const coImageDefiner = (): typeof ImageDefinition => {\n  return ImageDefinition;\n};\n","export { Loaded as loaded } from \"./zodSchema.js\";\nexport {\n  coMapDefiner as map,\n  coRecordDefiner as record,\n  coListDefiner as list,\n  coFeedDefiner as feed,\n  coPlainTextDefiner as plainText,\n  coRichTextDefiner as richText,\n  coFileStreamDefiner as fileStream,\n  coImageDefiner as image,\n  coAccountDefiner as account,\n  coProfileDefiner as profile,\n} from \"./zodCo.js\";\n","import { RawAccount, RawCoList, RawCoMap } from \"cojson\";\nimport { zodSchemaToCoSchema } from \"./runtimeConverters/zodSchemaToCoSchema.js\";\nimport { z } from \"./zodReExport.js\";\n\nexport function schemaUnionDiscriminatorFor(\n  schema: z.core.$ZodDiscriminatedUnion,\n) {\n  if (isUnionOfCoMapsDeeply(schema)) {\n    if (!schema._zod.disc || schema._zod.disc.size == 0) {\n      throw new Error(\n        \"z.union() of collaborative types is not supported, use z.discriminatedUnion() instead\",\n      );\n    }\n\n    const discriminator = schema._zod.def.discriminator;\n    const field = schema._zod.disc.get(discriminator);\n\n    if (!field) {\n      throw new Error(\n        \"z.discriminatedUnion() of collaborative types with non-existent discriminator key is not supported\",\n      );\n    }\n\n    for (const value of field.values) {\n      if (typeof value !== \"string\" && typeof value !== \"number\") {\n        throw new Error(\n          \"z.discriminatedUnion() of collaborative types with non-string or non-number discriminator value is not supported\",\n        );\n      }\n    }\n\n    const availableOptions: z.core.$ZodObject[] = [];\n\n    for (const option of schema._zod.def.options) {\n      if (option._zod.def.type === \"object\") {\n        availableOptions.push(option as z.core.$ZodObject);\n      } else if (option._zod.def.type === \"union\") {\n        for (const subOption of (option as z.core.$ZodUnion)._zod.def.options) {\n          if (subOption._zod.def.type === \"object\") {\n            availableOptions.push(subOption as z.core.$ZodObject);\n          }\n        }\n      } else {\n        throw new Error(\n          \"Unsupported zod type in z.discriminatedUnion() of collaborative types\",\n        );\n      }\n    }\n\n    const determineSchema = (_raw: RawCoMap | RawAccount | RawCoList) => {\n      if (_raw instanceof RawCoList) {\n        throw new Error(\n          \"z.discriminatedUnion() of collaborative types is not supported for CoLists\",\n        );\n      }\n\n      for (const option of availableOptions) {\n        let match = true;\n\n        for (const key of schema._zod.disc.keys()) {\n          const discriminatorDef = (option as z.core.$ZodObject)._zod.def.shape[\n            key as string\n          ];\n\n          const discriminatorValue = (_raw as RawCoMap).get(key as string);\n\n          if (discriminatorValue && typeof discriminatorValue === \"object\") {\n            throw new Error(\"Discriminator must be a primitive value\");\n          }\n\n          if (!discriminatorDef) {\n            if (key === discriminator) {\n              match = false;\n              break;\n            } else {\n              continue;\n            }\n          }\n\n          if (discriminatorDef._zod.def.type !== \"literal\") {\n            break;\n          }\n\n          const literalDef = discriminatorDef._zod.def as z.core.$ZodLiteralDef;\n\n          if (!Array.from(literalDef.values).includes(discriminatorValue)) {\n            match = false;\n            break;\n          }\n        }\n\n        if (match) {\n          return zodSchemaToCoSchema(option);\n        }\n      }\n\n      throw new Error(\n        \"z.discriminatedUnion() of collaborative types with no matching discriminator value found\",\n      );\n    };\n\n    return determineSchema;\n  } else {\n    throw new Error(\n      \"z.discriminatedUnion() of non-collaborative types is not supported\",\n    );\n  }\n}\n\nexport function isUnionOfCoMapsDeeply(\n  schema: z.core.$ZodType,\n): schema is z.core.$ZodDiscriminatedUnion {\n  if (schema instanceof z.core.$ZodUnion) {\n    return schema._zod.def.options.every(isCoMapOrUnionOfCoMapsDeeply);\n  } else {\n    return false;\n  }\n}\n\nfunction isCoMapOrUnionOfCoMapsDeeply(\n  schema: z.core.$ZodType,\n): schema is z.core.$ZodDiscriminatedUnion {\n  if (\n    schema instanceof z.core.$ZodObject &&\n    \"collaborative\" in schema &&\n    schema.collaborative\n  ) {\n    return true;\n  } else if (schema instanceof z.core.$ZodUnion) {\n    return schema._zod.def.options.every(isCoMapOrUnionOfCoMapsDeeply);\n  } else {\n    return false;\n  }\n}\n\nexport function isUnionOfPrimitivesDeeply(schema: z.core.$ZodType) {\n  if (schema instanceof z.core.$ZodUnion) {\n    return schema._zod.def.options.every(isUnionOfPrimitivesDeeply);\n  } else {\n    return !(\"collaborative\" in schema);\n  }\n}\n","import { CoMap, CoValueClass, isCoValueClass } from \"../../../internal.js\";\nimport { coField } from \"../../schema.js\";\nimport {\n  isUnionOfCoMapsDeeply,\n  isUnionOfPrimitivesDeeply,\n  schemaUnionDiscriminatorFor,\n} from \"../unionUtils.js\";\nimport {\n  ZodCatch,\n  ZodDefault,\n  ZodLazy,\n  ZodReadonly,\n  z,\n} from \"../zodReExport.js\";\nimport { ZodPrimitiveSchema } from \"../zodSchema.js\";\nimport { zodSchemaToCoSchemaOrKeepPrimitive } from \"./zodSchemaToCoSchema.js\";\n\ntype FieldSchema =\n  | CoValueClass\n  | ZodPrimitiveSchema\n  | z.core.$ZodOptional<z.core.$ZodType>\n  | z.core.$ZodUnion<z.core.$ZodType[]>\n  | z.core.$ZodObject<z.core.$ZodLooseShape>\n  | z.core.$ZodArray<z.core.$ZodType>\n  | z.core.$ZodTuple<z.core.$ZodType[]>\n  | z.core.$ZodReadonly<z.core.$ZodType>\n  | z.core.$ZodLazy<z.core.$ZodType>\n  | z.core.$ZodTemplateLiteral<any>\n  | z.core.$ZodLiteral<any>\n  | z.core.$ZodCatch<z.core.$ZodType>\n  | z.core.$ZodEnum<any>\n  | z.core.$ZodDefault<z.core.$ZodType>\n  | z.core.$ZodCatch<z.core.$ZodType>\n  | (z.core.$ZodCustom<any, any> & { builtin: any });\n\nexport function zodFieldToCoFieldDef(schema: FieldSchema) {\n  if (isCoValueClass(schema)) {\n    return coField.ref(schema);\n  } else {\n    if (\"_zod\" in schema) {\n      if (schema._zod.def.type === \"optional\") {\n        const inner = zodSchemaToCoSchemaOrKeepPrimitive(\n          schema._zod.def.innerType,\n        );\n        if (isCoValueClass(inner)) {\n          return coField.ref(inner, { optional: true });\n        } else {\n          return zodFieldToCoFieldDef(inner);\n        }\n      } else if (schema._zod.def.type === \"string\") {\n        return coField.string;\n      } else if (schema._zod.def.type === \"number\") {\n        return coField.number;\n      } else if (schema._zod.def.type === \"boolean\") {\n        return coField.boolean;\n      } else if (schema._zod.def.type === \"null\") {\n        return coField.null;\n      } else if (schema._zod.def.type === \"enum\") {\n        return coField.string;\n      } else if (schema._zod.def.type === \"readonly\") {\n        return zodFieldToCoFieldDef(\n          (schema as unknown as ZodReadonly).def.innerType as FieldSchema,\n        );\n      } else if (schema._zod.def.type === \"date\") {\n        return coField.optional.Date;\n      } else if (schema._zod.def.type === \"template_literal\") {\n        return coField.string;\n      } else if (schema._zod.def.type === \"lazy\") {\n        // Mostly to support z.json()\n        return zodFieldToCoFieldDef(\n          (schema as unknown as ZodLazy).unwrap() as FieldSchema,\n        );\n      } else if (\n        schema._zod.def.type === \"default\" ||\n        schema._zod.def.type === \"catch\"\n      ) {\n        console.warn(\n          \"z.default()/z.catch() are not supported in collaborative schemas. They will be ignored.\",\n        );\n\n        return zodFieldToCoFieldDef(\n          (schema as unknown as ZodDefault | ZodCatch).def\n            .innerType as FieldSchema,\n        );\n      } else if (schema._zod.def.type === \"literal\") {\n        if (\n          schema._zod.def.values.some(\n            (literal) => typeof literal === \"undefined\",\n          )\n        ) {\n          throw new Error(\"z.literal() with undefined is not supported\");\n        }\n        if (schema._zod.def.values.some((literal) => literal === null)) {\n          throw new Error(\"z.literal() with null is not supported\");\n        }\n        if (\n          schema._zod.def.values.some((literal) => typeof literal === \"bigint\")\n        ) {\n          throw new Error(\"z.literal() with bigint is not supported\");\n        }\n        return coField.literal(\n          ...(schema._zod.def.values as Exclude<\n            (typeof schema._zod.def.values)[number],\n            undefined | null | bigint\n          >[]),\n        );\n      } else if (\n        schema._zod.def.type === \"object\" ||\n        schema._zod.def.type === \"array\" ||\n        schema._zod.def.type === \"tuple\"\n      ) {\n        return coField.json();\n      } else if (schema._zod.def.type === \"custom\") {\n        if (\"builtin\" in schema) {\n          return zodFieldToCoFieldDef(schema.builtin);\n        } else {\n          throw new Error(`Unsupported custom zod type`);\n        }\n      } else if (schema._zod.def.type === \"union\") {\n        if (isUnionOfPrimitivesDeeply(schema)) {\n          return coField.json();\n        } else if (isUnionOfCoMapsDeeply(schema)) {\n          return coField.ref<CoValueClass<CoMap>>(\n            schemaUnionDiscriminatorFor(schema),\n          );\n        } else {\n          throw new Error(\n            \"z.union()/z.discriminatedUnion() of mixed collaborative and non-collaborative types is not supported\",\n          );\n        }\n      } else {\n        throw new Error(\n          `Unsupported zod type: ${(schema._zod?.def as any)?.type || JSON.stringify(schema)}`,\n        );\n      }\n    } else {\n      throw new Error(`Unsupported zod type: ${schema}`);\n    }\n  }\n}\n","import { RawCoList, RawCoMap } from \"cojson\";\nimport {\n  Account,\n  CoFeed,\n  CoList,\n  CoMap,\n  CoPlainText,\n  CoRichText,\n  CoValueClass,\n  FileStream,\n  SchemaUnion,\n  isCoValueClass,\n} from \"../../../internal.js\";\nimport { coField } from \"../../schema.js\";\nimport {\n  isUnionOfCoMapsDeeply,\n  schemaUnionDiscriminatorFor,\n} from \"../unionUtils.js\";\nimport { z } from \"../zodReExport.js\";\nimport {\n  CoValueClassFromZodSchema,\n  ZodPrimitiveSchema,\n  getDef,\n  isZodArray,\n  isZodCustom,\n  isZodObject,\n} from \"../zodSchema.js\";\nimport { zodFieldToCoFieldDef } from \"./zodFieldToCoFieldDef.js\";\n\nlet coSchemasForZodSchemas = new Map<z.core.$ZodType, CoValueClass>();\n\nexport function tryZodSchemaToCoSchema<S extends z.core.$ZodType>(\n  schema: S,\n): CoValueClassFromZodSchema<S> | null {\n  if (\"collaborative\" in schema && schema.collaborative) {\n    if (coSchemasForZodSchemas.has(schema)) {\n      return coSchemasForZodSchemas.get(schema) as CoValueClassFromZodSchema<S>;\n    }\n\n    if (isZodObject(schema)) {\n      const def = getDef(schema);\n\n      const ClassToExtend =\n        \"builtin\" in schema && schema.builtin === \"Account\" ? Account : CoMap;\n\n      const coSchema = class ZCoMap extends ClassToExtend {\n        constructor(options: { fromRaw: RawCoMap } | undefined) {\n          super(options);\n          for (const [field, fieldType] of Object.entries(\n            def.shape as z.core.$ZodShape,\n          )) {\n            (this as any)[field] = zodFieldToCoFieldDef(\n              zodSchemaToCoSchemaOrKeepPrimitive(fieldType),\n            );\n          }\n          if (def.catchall) {\n            (this as any)[coField.items] = zodFieldToCoFieldDef(\n              zodSchemaToCoSchemaOrKeepPrimitive(def.catchall),\n            );\n          }\n        }\n      };\n\n      coSchemasForZodSchemas.set(schema, coSchema as unknown as CoValueClass);\n      return coSchema as unknown as CoValueClassFromZodSchema<S>;\n    } else if (isZodArray(schema)) {\n      const def = getDef(schema);\n      const coSchema = class ZCoList extends CoList {\n        constructor(options: { fromRaw: RawCoList } | undefined) {\n          super(options);\n          (this as any)[coField.items] = zodFieldToCoFieldDef(\n            zodSchemaToCoSchemaOrKeepPrimitive(def.element),\n          );\n        }\n      };\n\n      coSchemasForZodSchemas.set(schema, coSchema);\n      return coSchema as unknown as CoValueClassFromZodSchema<S>;\n    } else if (isZodCustom(schema)) {\n      if (\"builtin\" in schema) {\n        if (schema.builtin === \"CoFeed\" && \"element\" in schema) {\n          return CoFeed.Of(\n            zodFieldToCoFieldDef(\n              zodSchemaToCoSchemaOrKeepPrimitive(\n                schema.element as z.core.$ZodType,\n              ),\n            ),\n          ) as unknown as CoValueClassFromZodSchema<S>;\n        } else if (schema.builtin === \"FileStream\") {\n          return FileStream as unknown as CoValueClassFromZodSchema<S>;\n        } else if (schema.builtin === \"CoPlainText\") {\n          return CoPlainText as unknown as CoValueClassFromZodSchema<S>;\n        } else if (schema.builtin === \"CoRichText\") {\n          return CoRichText as unknown as CoValueClassFromZodSchema<S>;\n        } else {\n          throw new Error(`Unsupported builtin type: ${schema.builtin}`);\n        }\n      } else {\n        throw new Error(`Unsupported custom zod type`);\n      }\n    } else {\n      throw new Error(\n        `Unsupported zod CoValue type for top-level schema: ${schema._zod?.def?.type || JSON.stringify(schema, undefined, 2)}`,\n      );\n    }\n  } else if (schema instanceof z.core.$ZodDiscriminatedUnion) {\n    if (isUnionOfCoMapsDeeply(schema)) {\n      return SchemaUnion.Of(\n        schemaUnionDiscriminatorFor(schema),\n      ) as unknown as CoValueClassFromZodSchema<S>;\n    } else {\n      throw new Error(\n        \"z.discriminatedUnion() of non-collaborative types is not supported as a top-level schema\",\n      );\n    }\n  } else {\n    return null;\n  }\n}\n\nexport function zodSchemaToCoSchema<\n  S extends\n    | z.core.$ZodType\n    | (z.core.$ZodObject<any, any> & {\n        builtin: \"Account\";\n        migration?: (account: any, creationProps?: { name: string }) => void;\n      })\n    | (z.core.$ZodCustom<any, any> & { builtin: \"FileStream\" })\n    | (z.core.$ZodCustom<any, any> & {\n        builtin: \"CoFeed\";\n        element: z.core.$ZodType;\n      }),\n>(schema: S): CoValueClassFromZodSchema<S> {\n  const coSchema = tryZodSchemaToCoSchema(schema);\n  if (!coSchema) {\n    throw new Error(\n      `Unsupported zod type: ${schema._zod?.def?.type || JSON.stringify(schema)}`,\n    );\n  }\n  return coSchema;\n}\n\nexport function anySchemaToCoSchema<\n  S extends\n    | CoValueClass\n    | z.core.$ZodType\n    | (z.core.$ZodObject<any, any> & {\n        builtin: \"Account\";\n        migration?: (account: any, creationProps?: { name: string }) => void;\n      })\n    | (z.core.$ZodCustom<any, any> & { builtin: \"FileStream\" })\n    | (z.core.$ZodCustom<any, any> & {\n        builtin: \"CoFeed\";\n        element: z.core.$ZodType;\n      }),\n>(\n  schema: S,\n): S extends CoValueClass\n  ? S\n  : S extends z.core.$ZodType\n    ? CoValueClassFromZodSchema<S>\n    : never {\n  if (isCoValueClass(schema)) {\n    return schema as any;\n  } else if (\"getCoSchema\" in schema) {\n    return (schema as any).getCoSchema() as any;\n  } else if (\"def\" in schema) {\n    const coSchema = tryZodSchemaToCoSchema(schema as z.core.$ZodType);\n    if (!coSchema) {\n      throw new Error(\n        `Unsupported zod type: ${(schema.def as any)?.type || JSON.stringify(schema)}`,\n      );\n    }\n    return coSchema as any;\n  }\n\n  throw new Error(`Unsupported schema: ${JSON.stringify(schema)}`);\n}\n\nexport function zodSchemaToCoSchemaOrKeepPrimitive<S extends z.core.$ZodType>(\n  schema: S,\n): CoValueClassFromZodSchema<S> | ZodPrimitiveSchema {\n  const coSchema = tryZodSchemaToCoSchema(schema);\n  if (!coSchema) {\n    return schema as any;\n  }\n  return coSchema;\n}\n","import { z } from \"../../implementation/zodSchema/zodReExport.js\";\nimport { Loaded, coFileStreamDefiner, coMapDefiner } from \"../../internal.js\";\n\n// avoiding circularity by using the standalone definers instead of `co`\nconst ImageDefinitionBase = coMapDefiner({\n  originalSize: z.tuple([z.number(), z.number()]),\n  placeholderDataURL: z.string().optional(),\n}).catchall(coFileStreamDefiner());\n\n/** @category Media */\nexport const ImageDefinition = ImageDefinitionBase.withHelpers((Self) => ({\n  highestResAvailable(\n    imageDef: Loaded<typeof Self>,\n    options?: {\n      maxWidth?: number;\n      targetWidth?: number;\n    },\n  ) {\n    const resolutions = Object.keys(imageDef).filter((key) =>\n      key.match(/^\\d+x\\d+$/),\n    ) as `${number}x${number}`[];\n\n    let maxWidth = options?.maxWidth;\n\n    if (options?.targetWidth) {\n      const targetWidth = options.targetWidth;\n      const widths = resolutions.map((res) => Number(res.split(\"x\")[0]));\n\n      maxWidth = Math.min(...widths.filter((w) => w >= targetWidth));\n    }\n\n    const validResolutions = resolutions.filter(\n      (key) => maxWidth === undefined || Number(key.split(\"x\")[0]) <= maxWidth,\n    ) as `${number}x${number}`[];\n\n    // Sort the resolutions by width, smallest to largest\n    validResolutions.sort((a, b) => {\n      const aWidth = Number(a.split(\"x\")[0]);\n      const bWidth = Number(b.split(\"x\")[0]);\n      return aWidth - bWidth; // Sort smallest to largest\n    });\n\n    let highestAvailableResolution: `${number}x${number}` | undefined;\n\n    for (const resolution of validResolutions) {\n      if (imageDef[resolution] && imageDef[resolution]?.getChunks()) {\n        highestAvailableResolution = resolution;\n      }\n    }\n\n    // Return the highest complete resolution if we found one\n    return (\n      highestAvailableResolution && {\n        res: highestAvailableResolution,\n        stream: imageDef[highestAvailableResolution]!,\n      }\n    );\n  },\n}));\nexport type ImageDefinition = Loaded<typeof ImageDefinition>;\n","import { AgentSecret, LocalNode, cojsonInternals } from \"cojson\";\nimport { PureJSCrypto } from \"cojson/dist/crypto/PureJSCrypto\";\nimport { AuthSecretStorage } from \"../auth/AuthSecretStorage.js\";\nimport { InMemoryKVStore } from \"../auth/InMemoryKVStore.js\";\nimport { KvStore, KvStoreContext } from \"../auth/KvStoreContext.js\";\nimport { Account } from \"../coValues/account.js\";\nimport { AuthCredentials } from \"../types.js\";\nimport { JazzContextType } from \"../types.js\";\nimport { AnonymousJazzAgent } from \"./anonymousJazzAgent.js\";\nimport { createAnonymousJazzContext } from \"./createContext.js\";\nimport { InstanceOfSchema } from \"./zodSchema/typeConverters/InstanceOfSchema.js\";\n\nexport type JazzContextManagerAuthProps = {\n  credentials?: AuthCredentials;\n  newAccountProps?: { secret: AgentSecret; creationProps: { name: string } };\n};\n\nexport type JazzContextManagerBaseProps<Acc extends Account> = {\n  onAnonymousAccountDiscarded?: (anonymousAccount: Acc) => Promise<void>;\n  onLogOut?: () => void | Promise<unknown>;\n  logOutReplacement?: () => void | Promise<unknown>;\n};\n\ntype PlatformSpecificAuthContext<Acc extends Account> = {\n  me: Acc;\n  node: LocalNode;\n  logOut: () => Promise<void>;\n  done: () => void;\n};\n\ntype PlatformSpecificGuestContext = {\n  guest: AnonymousJazzAgent;\n  node: LocalNode;\n  logOut: () => Promise<void>;\n  done: () => void;\n};\n\ntype PlatformSpecificContext<Acc extends Account> =\n  | PlatformSpecificAuthContext<Acc>\n  | PlatformSpecificGuestContext;\n\nfunction getAnonymousFallback() {\n  const context = createAnonymousJazzContext({\n    peersToLoadFrom: [],\n    crypto: new PureJSCrypto(),\n  });\n\n  return {\n    guest: context.agent,\n    node: context.agent.node,\n    done: () => {},\n    logOut: async () => {},\n    isAuthenticated: false,\n    authenticate: async () => {},\n    register: async () => {\n      throw new Error(\"Not implemented\");\n    },\n  } satisfies JazzContextType<InstanceOfSchema<any>>;\n}\n\nexport class JazzContextManager<\n  Acc extends Account,\n  P extends JazzContextManagerBaseProps<Acc>,\n> {\n  protected value: JazzContextType<Acc> | undefined;\n  protected context: PlatformSpecificContext<Acc> | undefined;\n  protected props: P | undefined;\n  protected authSecretStorage = new AuthSecretStorage();\n  protected keepContextOpen = false;\n  contextPromise: Promise<void> | undefined;\n\n  constructor(opts?: {\n    useAnonymousFallback?: boolean;\n  }) {\n    KvStoreContext.getInstance().initialize(this.getKvStore());\n\n    if (opts?.useAnonymousFallback) {\n      this.value = getAnonymousFallback();\n    }\n  }\n\n  getKvStore(): KvStore {\n    return new InMemoryKVStore();\n  }\n\n  async createContext(props: P, authProps?: JazzContextManagerAuthProps) {\n    // We need to store the props here to block the double effect execution\n    // on React. Otherwise when calling propsChanged this.props is undefined.\n    this.props = props;\n\n    // Avoid race condition between the previous context and the new one\n    const { promise, resolve } = createResolvablePromise<void>();\n\n    const prevPromise = this.contextPromise;\n    this.contextPromise = promise;\n\n    await prevPromise;\n\n    try {\n      const result = await this.getNewContext(props, authProps);\n      await this.updateContext(props, result, authProps);\n\n      resolve();\n    } catch (error) {\n      resolve();\n      throw error;\n    }\n  }\n\n  async getNewContext(\n    props: P,\n    authProps?: JazzContextManagerAuthProps,\n  ): Promise<PlatformSpecificContext<Acc>> {\n    props;\n    authProps;\n    throw new Error(\"Not implemented\");\n  }\n\n  async updateContext(\n    props: P,\n    context: PlatformSpecificContext<Acc>,\n    authProps?: JazzContextManagerAuthProps,\n  ) {\n    // When keepContextOpen we don't want to close the previous context\n    // because we might need to handle the onAnonymousAccountDiscarded callback\n    if (!this.keepContextOpen) {\n      this.context?.done();\n    }\n\n    this.context = context;\n    this.props = props;\n    this.value = {\n      ...context,\n      node: context.node,\n      authenticate: this.authenticate,\n      register: this.register,\n      logOut: this.logOut,\n    };\n\n    if (authProps?.credentials) {\n      this.authSecretStorage.emitUpdate(authProps.credentials);\n    } else {\n      this.authSecretStorage.emitUpdate(await this.authSecretStorage.get());\n    }\n\n    this.notify();\n  }\n\n  propsChanged(props: P) {\n    props;\n    throw new Error(\"Not implemented\");\n  }\n\n  getCurrentValue() {\n    return this.value;\n  }\n\n  setCurrentValue(value: JazzContextType<Acc>) {\n    this.value = value;\n  }\n\n  getAuthSecretStorage() {\n    return this.authSecretStorage;\n  }\n\n  logOut = async () => {\n    if (!this.context || !this.props) {\n      return;\n    }\n\n    await this.props.onLogOut?.();\n\n    if (this.props.logOutReplacement) {\n      await this.props.logOutReplacement();\n    } else {\n      await this.context.logOut();\n      return this.createContext(this.props);\n    }\n  };\n\n  done = () => {\n    if (!this.context) {\n      return;\n    }\n\n    this.context.done();\n  };\n\n  shouldMigrateAnonymousAccount = async () => {\n    if (!this.props?.onAnonymousAccountDiscarded) {\n      return false;\n    }\n\n    const prevCredentials = await this.authSecretStorage.get();\n    const wasAnonymous =\n      this.authSecretStorage.getIsAuthenticated(prevCredentials) === false;\n\n    return wasAnonymous;\n  };\n\n  /**\n   * Authenticates the user with the given credentials\n   */\n  authenticate = async (credentials: AuthCredentials) => {\n    if (!this.props) {\n      throw new Error(\"Props required\");\n    }\n\n    const prevContext = this.context;\n    const migratingAnonymousAccount =\n      await this.shouldMigrateAnonymousAccount();\n\n    this.keepContextOpen = migratingAnonymousAccount;\n    await this.createContext(this.props, { credentials }).finally(() => {\n      this.keepContextOpen = false;\n    });\n\n    if (migratingAnonymousAccount) {\n      await this.handleAnonymousAccountMigration(prevContext);\n    }\n  };\n\n  register = async (\n    accountSecret: AgentSecret,\n    creationProps: { name: string },\n  ) => {\n    if (!this.props) {\n      throw new Error(\"Props required\");\n    }\n\n    const prevContext = this.context;\n    const migratingAnonymousAccount =\n      await this.shouldMigrateAnonymousAccount();\n\n    this.keepContextOpen = migratingAnonymousAccount;\n    await this.createContext(this.props, {\n      newAccountProps: {\n        secret: accountSecret,\n        creationProps,\n      },\n    }).finally(() => {\n      this.keepContextOpen = false;\n    });\n\n    if (migratingAnonymousAccount) {\n      await this.handleAnonymousAccountMigration(prevContext);\n    }\n\n    if (this.context && \"me\" in this.context) {\n      return this.context.me.id;\n    }\n\n    throw new Error(\"The registration hasn't created a new account\");\n  };\n\n  private async handleAnonymousAccountMigration(\n    prevContext: PlatformSpecificContext<Acc> | undefined,\n  ) {\n    if (!this.props) {\n      throw new Error(\"Props required\");\n    }\n\n    const currentContext = this.context;\n\n    if (\n      prevContext &&\n      currentContext &&\n      \"me\" in prevContext &&\n      \"me\" in currentContext\n    ) {\n      // Using a direct connection to make coValue transfer almost synchronous\n      const [prevAccountAsPeer, currentAccountAsPeer] =\n        cojsonInternals.connectedPeers(\n          prevContext.me.id,\n          currentContext.me.id,\n          {\n            peer1role: \"client\",\n            peer2role: \"server\",\n          },\n        );\n\n      prevContext.node.syncManager.addPeer(currentAccountAsPeer);\n      currentContext.node.syncManager.addPeer(prevAccountAsPeer);\n\n      try {\n        await this.props.onAnonymousAccountDiscarded?.(prevContext.me);\n        await prevContext.me.waitForAllCoValuesSync();\n      } catch (error) {\n        console.error(\"Error onAnonymousAccountDiscarded\", error);\n      }\n\n      prevAccountAsPeer.outgoing.close();\n      currentAccountAsPeer.outgoing.close();\n    }\n\n    prevContext?.done();\n  }\n\n  listeners = new Set<() => void>();\n  subscribe = (callback: () => void) => {\n    this.listeners.add(callback);\n\n    return () => {\n      this.listeners.delete(callback);\n    };\n  };\n\n  notify() {\n    for (const listener of this.listeners) {\n      listener();\n    }\n  }\n}\n\nfunction createResolvablePromise<T>() {\n  let resolve!: (value: T) => void;\n\n  const promise = new Promise<T>((res) => {\n    resolve = res;\n  });\n\n  return { promise, resolve };\n}\n","export interface KvStore {\n  get(key: string): Promise<string | null>;\n  set(key: string, value: string): Promise<void>;\n  delete(key: string): Promise<void>;\n  clearAll(): Promise<void>;\n}\n\nexport class KvStoreContext {\n  private static instance: KvStoreContext;\n  private storageInstance: KvStore | null = null;\n\n  private constructor() {}\n\n  public static getInstance(): KvStoreContext {\n    if (!KvStoreContext.instance) {\n      KvStoreContext.instance = new KvStoreContext();\n    }\n    return KvStoreContext.instance;\n  }\n\n  public isInitialized(): boolean {\n    return this.storageInstance !== null;\n  }\n\n  public initialize(store: KvStore): void {\n    if (!this.storageInstance) {\n      this.storageInstance = store;\n    }\n  }\n\n  public getStorage(): KvStore {\n    if (!this.storageInstance) {\n      throw new Error(\"Storage instance is not initialized.\");\n    }\n    return this.storageInstance;\n  }\n}\n\nexport default KvStoreContext;\n","import { AgentSecret } from \"cojson\";\nimport type { Account } from \"../coValues/account.js\";\nimport type { ID } from \"../internal.js\";\nimport { AuthCredentials } from \"../types.js\";\nimport KvStoreContext from \"./KvStoreContext.js\";\n\nconst STORAGE_KEY = \"jazz-logged-in-secret\";\n\nexport type AuthSetPayload = {\n  accountID: ID<Account>;\n  secretSeed?: Uint8Array;\n  accountSecret: AgentSecret;\n  provider:\n    | \"anonymous\"\n    | \"clerk\"\n    | \"betterauth\"\n    | \"demo\"\n    | \"passkey\"\n    | \"passphrase\"\n    | string;\n};\n\nexport class AuthSecretStorage {\n  private listeners: Set<(isAuthenticated: boolean) => void>;\n  public isAuthenticated: boolean;\n\n  constructor() {\n    this.listeners = new Set();\n    this.isAuthenticated = false;\n  }\n\n  async migrate() {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n\n    if (!(await kvStore.get(STORAGE_KEY))) {\n      const demoAuthSecret = await kvStore.get(\"demo-auth-logged-in-secret\");\n      if (demoAuthSecret) {\n        const parsed = JSON.parse(demoAuthSecret);\n        await kvStore.set(\n          STORAGE_KEY,\n          JSON.stringify({\n            accountID: parsed.accountID,\n            accountSecret: parsed.accountSecret,\n            provider: \"demo\",\n          }),\n        );\n        await kvStore.delete(\"demo-auth-logged-in-secret\");\n      }\n\n      const clerkAuthSecret = await kvStore.get(\"jazz-clerk-auth\");\n      if (clerkAuthSecret) {\n        const parsed = JSON.parse(clerkAuthSecret);\n        await kvStore.set(\n          STORAGE_KEY,\n          JSON.stringify({\n            accountID: parsed.accountID,\n            accountSecret: parsed.secret,\n            provider: \"clerk\",\n          }),\n        );\n        await kvStore.delete(\"jazz-clerk-auth\");\n      }\n    }\n\n    const value = await kvStore.get(STORAGE_KEY);\n\n    if (value) {\n      const parsed = JSON.parse(value);\n\n      if (\"secret\" in parsed) {\n        await kvStore.set(\n          STORAGE_KEY,\n          JSON.stringify({\n            accountID: parsed.accountID,\n            secretSeed: parsed.secretSeed,\n            accountSecret: parsed.secret,\n            provider: parsed.provider,\n          }),\n        );\n      }\n    }\n  }\n\n  async get(): Promise<AuthCredentials | null> {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    const data = await kvStore.get(STORAGE_KEY);\n\n    if (!data) return null;\n\n    const parsed = JSON.parse(data);\n\n    if (!parsed.accountID || !parsed.accountSecret) {\n      throw new Error(\"Invalid auth secret storage data\");\n    }\n\n    return {\n      accountID: parsed.accountID,\n      secretSeed: parsed.secretSeed\n        ? new Uint8Array(parsed.secretSeed)\n        : undefined,\n      accountSecret: parsed.accountSecret,\n      provider: parsed.provider,\n    };\n  }\n\n  async setWithoutNotify(payload: AuthSetPayload) {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    await kvStore.set(\n      STORAGE_KEY,\n      JSON.stringify({\n        accountID: payload.accountID,\n        secretSeed: payload.secretSeed\n          ? Array.from(payload.secretSeed)\n          : undefined,\n        accountSecret: payload.accountSecret,\n        provider: payload.provider,\n      }),\n    );\n  }\n\n  async set(payload: AuthSetPayload) {\n    this.setWithoutNotify(payload);\n    this.emitUpdate(payload);\n  }\n\n  getIsAuthenticated(data: AuthCredentials | null): boolean {\n    if (!data) return false;\n    return data.provider !== \"anonymous\";\n  }\n\n  onUpdate(handler: (isAuthenticated: boolean) => void) {\n    this.listeners.add(handler);\n    return () => {\n      this.listeners.delete(handler);\n    };\n  }\n\n  emitUpdate(data: AuthCredentials | null) {\n    const isAuthenticated = this.getIsAuthenticated(data);\n\n    if (this.isAuthenticated === isAuthenticated) return;\n\n    this.isAuthenticated = isAuthenticated;\n    for (const listener of this.listeners) {\n      listener(this.isAuthenticated);\n    }\n  }\n\n  async clearWithoutNotify() {\n    const kvStore = KvStoreContext.getInstance().getStorage();\n    await kvStore.delete(STORAGE_KEY);\n  }\n\n  async clear() {\n    await this.clearWithoutNotify();\n    this.emitUpdate(null);\n  }\n}\n","import { KvStore } from \"./KvStoreContext.js\";\n\nexport class InMemoryKVStore implements KvStore {\n  private store: Record<string, string> = {};\n\n  async get(key: string) {\n    const data = this.store[key];\n\n    if (!data) return null;\n\n    return data;\n  }\n\n  async set(key: string, value: string) {\n    this.store[key] = value;\n  }\n\n  async delete(key: string) {\n    delete this.store[key];\n  }\n\n  async clearAll() {\n    this.store = {};\n  }\n}\n","/* istanbul ignore file -- @preserve */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ItemsSym } from \"./symbols.js\";\n\n(globalThis as any).devtoolsFormatters = [\n  {\n    header: (object: any) => {\n      if (object._type === \"CoMap\") {\n        return [\"div\", {}, [\"span\", {}, object.constructor.name]];\n      } else if (object._type === \"CoList\") {\n        return [\n          \"div\",\n          {},\n          [\"span\", {}, object.constructor.name + \"(\" + object.length + \") \"],\n        ];\n      } else if (object._type === \"Account\") {\n        return [\n          \"div\",\n          {},\n          [\n            \"span\",\n            {},\n            object.constructor.name +\n              \"(\" +\n              object._refs.profile.value?.name +\n              (object.isMe ? \" ME\" : \"\") +\n              \")\",\n          ],\n        ];\n      } else {\n        return null;\n      }\n    },\n    hasBody: function () {\n      return true;\n    },\n    body: function (object: any) {\n      if (object._type === \"CoMap\" || object._type === \"Account\") {\n        return [\n          \"div\",\n          { style: \"margin-left: 15px\" },\n          [\"div\", \"id: \", [\"object\", { object: object.id }]],\n          ...Object.entries(object).map(([k, v]) => [\n            \"div\",\n            { style: \"white-space: nowrap;\" },\n            [\"span\", { style: \"font-weight: bold; opacity: 0.6\" }, k, \": \"],\n            [\"object\", { object: v }],\n            ...(typeof object._schema[k] === \"function\"\n              ? v === null\n                ? [\n                    [\n                      \"span\",\n                      { style: \"opacity: 0.5\" },\n                      ` (pending ${object._schema[k].name} `,\n                      [\"object\", { object: object._refs[k] }],\n                      \")\",\n                    ],\n                  ]\n                : []\n              : []),\n          ]),\n        ];\n      } else if (object._type === \"CoList\") {\n        return [\n          \"div\",\n          { style: \"margin-left: 15px\" },\n          [\"div\", \"id: \", [\"object\", { object: object.id }]],\n          ...(object as any[]).map((v, i) => [\n            \"div\",\n            { style: \"white-space: nowrap;\" },\n            [\"span\", { style: \"font-weight: bold; opacity: 0.6\" }, i, \": \"],\n            [\"object\", { object: v }],\n            ...(typeof object._schema[ItemsSym] === \"function\"\n              ? v === null\n                ? [\n                    [\n                      \"span\",\n                      { style: \"opacity: 0.5\" },\n                      ` (pending ${object._schema[ItemsSym].name} `,\n                      [\"object\", { object: object._refs[i] }],\n                      \")\",\n                    ],\n                  ]\n                : []\n              : []),\n          ]),\n        ];\n      }\n    },\n  },\n];\n","import type { CoValueUniqueness, RawCoValue } from \"cojson\";\nimport {\n  type Account,\n  AnonymousJazzAgent,\n  CoValueOrZodSchema,\n  type Group,\n  Loaded,\n  RefsToResolve,\n  RefsToResolveStrict,\n  RegisteredSchemas,\n  ResolveQuery,\n  ResolveQueryStrict,\n  Resolved,\n  SubscriptionScope,\n  type SubscriptionValue,\n  activeAccountContext,\n  anySchemaToCoSchema,\n  inspect,\n} from \"../internal.js\";\n\n/** @category Abstract interfaces */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface CoValueClass<Value extends CoValue = CoValue> {\n  /** @ignore */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  new (...args: any[]): Value;\n}\n\nexport interface CoValueFromRaw<V extends CoValue> {\n  fromRaw(raw: V[\"_raw\"]): V;\n}\n\n/** @category Abstract interfaces */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface CoValue {\n  /** @category Content */\n  readonly id: ID<this>;\n  /** @category Type Helpers */\n  _type: string;\n  /** @category Collaboration */\n  _owner: Account | Group;\n  /** @category Internals */\n  _raw: RawCoValue;\n\n  /** @internal */\n  _subscriptionScope?: SubscriptionScope<this>;\n\n  /** @internal */\n  readonly _loadedAs: Account | AnonymousJazzAgent;\n  /** @category Stringifying & Inspection */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(key?: string, seenAbove?: ID<CoValue>[]): any[] | object | string;\n  /** @category Stringifying & Inspection */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [inspect](): any;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isCoValue(value: any): value is CoValue {\n  return value && value._type !== undefined;\n}\n\nexport function isCoValueClass<V extends CoValue>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n): value is CoValueClass<V> & CoValueFromRaw<V> {\n  return typeof value === \"function\" && value.fromRaw !== undefined;\n}\n\n/**\n * IDs are unique identifiers for `CoValue`s.\n * Can be used with a type argument to refer to a specific `CoValue` type.\n *\n * @example\n *\n * ```ts\n * type AccountID = ID<Account>;\n * ```\n *\n * @category CoValues\n */\nexport type ID<T> = string;\n\nexport function loadCoValueWithoutMe<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  cls: CoValueClass<V>,\n  id: ID<CoValue>,\n  options?: {\n    resolve?: RefsToResolveStrict<V, R>;\n    loadAs?: Account | AnonymousJazzAgent;\n  },\n): Promise<Resolved<V, R> | null> {\n  return loadCoValue(cls, id, {\n    ...options,\n    loadAs: options?.loadAs ?? activeAccountContext.get(),\n  });\n}\n\nexport function loadCoValue<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  cls: CoValueClass<V>,\n  id: ID<CoValue>,\n  options: {\n    resolve?: RefsToResolveStrict<V, R>;\n    loadAs: Account | AnonymousJazzAgent;\n  },\n): Promise<Resolved<V, R> | null> {\n  return new Promise((resolve) => {\n    subscribeToCoValue<V, R>(\n      cls,\n      id,\n      {\n        resolve: options.resolve,\n        loadAs: options.loadAs,\n        syncResolution: true,\n        onUnavailable: () => {\n          resolve(null);\n        },\n        onUnauthorized: () => {\n          resolve(null);\n        },\n      },\n      (value, unsubscribe) => {\n        resolve(value);\n        unsubscribe();\n      },\n    );\n  });\n}\n\nexport async function ensureCoValueLoaded<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  existing: V,\n  options?: { resolve?: RefsToResolveStrict<V, R> } | undefined,\n): Promise<Resolved<V, R>> {\n  const response = await loadCoValue(\n    existing.constructor as CoValueClass<V>,\n    existing.id,\n    {\n      loadAs: existing._loadedAs,\n      resolve: options?.resolve,\n    },\n  );\n\n  if (!response) {\n    throw new Error(\"Failed to deeply load CoValue \" + existing.id);\n  }\n\n  return response;\n}\n\ntype SubscribeListener<V extends CoValue, R extends RefsToResolve<V>> = (\n  value: Resolved<V, R>,\n  unsubscribe: () => void,\n) => void;\n\nexport type SubscribeListenerOptions<\n  V extends CoValue,\n  R extends RefsToResolve<V>,\n> = {\n  resolve?: RefsToResolveStrict<V, R>;\n  loadAs?: Account | AnonymousJazzAgent;\n  onUnauthorized?: () => void;\n  onUnavailable?: () => void;\n};\n\nexport type SubscribeRestArgs<V extends CoValue, R extends RefsToResolve<V>> =\n  | [options: SubscribeListenerOptions<V, R>, listener: SubscribeListener<V, R>]\n  | [listener: SubscribeListener<V, R>];\n\nexport function parseSubscribeRestArgs<\n  V extends CoValue,\n  R extends RefsToResolve<V>,\n>(\n  args: SubscribeRestArgs<V, R>,\n): {\n  options: SubscribeListenerOptions<V, R>;\n  listener: SubscribeListener<V, R>;\n} {\n  if (args.length === 2) {\n    if (\n      typeof args[0] === \"object\" &&\n      args[0] &&\n      typeof args[1] === \"function\"\n    ) {\n      return {\n        options: {\n          resolve: args[0].resolve,\n          loadAs: args[0].loadAs,\n          onUnauthorized: args[0].onUnauthorized,\n          onUnavailable: args[0].onUnavailable,\n        },\n        listener: args[1],\n      };\n    } else {\n      throw new Error(\"Invalid arguments\");\n    }\n  } else {\n    if (typeof args[0] === \"function\") {\n      return { options: {}, listener: args[0] };\n    } else {\n      throw new Error(\"Invalid arguments\");\n    }\n  }\n}\n\nexport function subscribeToCoValueWithoutMe<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  cls: CoValueClass<V>,\n  id: ID<CoValue>,\n  options: SubscribeListenerOptions<V, R>,\n  listener: SubscribeListener<V, R>,\n) {\n  return subscribeToCoValue(\n    cls,\n    id,\n    {\n      ...options,\n      loadAs: options.loadAs ?? activeAccountContext.get(),\n    },\n    listener,\n  );\n}\n\nexport function subscribeToCoValue<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  cls: CoValueClass<V>,\n  id: ID<CoValue>,\n  options: {\n    resolve?: RefsToResolveStrict<V, R>;\n    loadAs: Account | AnonymousJazzAgent;\n    onUnavailable?: () => void;\n    onUnauthorized?: () => void;\n    syncResolution?: boolean;\n  },\n  listener: SubscribeListener<V, R>,\n): () => void {\n  const loadAs = options.loadAs ?? activeAccountContext.get();\n  const node = \"node\" in loadAs ? loadAs.node : loadAs._raw.core.node;\n\n  const resolve = options.resolve ?? true;\n\n  let unsubscribed = false;\n\n  const rootNode = new SubscriptionScope<V>(node, resolve, id as ID<V>, {\n    ref: cls,\n    optional: false,\n  });\n\n  const handleUpdate = (value: SubscriptionValue<V, any>) => {\n    if (unsubscribed) return;\n\n    if (value.type === \"unavailable\") {\n      options.onUnavailable?.();\n\n      console.error(value.toString());\n    } else if (value.type === \"unauthorized\") {\n      options.onUnauthorized?.();\n\n      console.error(value.toString());\n    } else if (value.type === \"loaded\") {\n      listener(value.value as Resolved<V, R>, unsubscribe);\n    }\n  };\n\n  let shouldDefer = !options.syncResolution;\n\n  rootNode.setListener((value) => {\n    if (shouldDefer) {\n      shouldDefer = false;\n      Promise.resolve().then(() => {\n        handleUpdate(value);\n      });\n    } else {\n      handleUpdate(value);\n    }\n  });\n\n  function unsubscribe() {\n    unsubscribed = true;\n    rootNode.destroy();\n  }\n\n  return unsubscribe;\n}\n\n/**\n * @deprecated Used for the React integration in the past, but we moved to use SubscriptionScope directly.\n *\n * Going to be removed in the next minor version.\n */\nexport function createCoValueObservable<\n  S extends CoValueOrZodSchema,\n  const R extends ResolveQuery<S>,\n>(initialValue: undefined | null = undefined) {\n  let currentValue: Loaded<S, R> | undefined | null = initialValue;\n  let subscriberCount = 0;\n\n  function subscribe(\n    cls: S,\n    id: string,\n    options: {\n      loadAs: Account | AnonymousJazzAgent;\n      resolve?: ResolveQueryStrict<S, R>;\n      onUnavailable?: () => void;\n      onUnauthorized?: () => void;\n      syncResolution?: boolean;\n    },\n    listener: () => void,\n  ) {\n    subscriberCount++;\n\n    const unsubscribe = subscribeToCoValue(\n      anySchemaToCoSchema(cls),\n      id,\n      {\n        loadAs: options.loadAs,\n        resolve: options.resolve as any,\n        onUnavailable: () => {\n          currentValue = null;\n          options.onUnavailable?.();\n        },\n        onUnauthorized: () => {\n          currentValue = null;\n          options.onUnauthorized?.();\n        },\n        syncResolution: options.syncResolution,\n      },\n      (value) => {\n        currentValue = value as Loaded<S, R>;\n        listener();\n      },\n    );\n\n    return () => {\n      unsubscribe();\n      subscriberCount--;\n      if (subscriberCount === 0) {\n        currentValue = undefined;\n      }\n    };\n  }\n\n  const observable = {\n    getCurrentValue: () => currentValue,\n    subscribe,\n  };\n\n  return observable;\n}\n\nexport function subscribeToExistingCoValue<\n  V extends CoValue,\n  const R extends RefsToResolve<V>,\n>(\n  existing: V,\n  options:\n    | {\n        resolve?: RefsToResolveStrict<V, R>;\n        onUnavailable?: () => void;\n        onUnauthorized?: () => void;\n      }\n    | undefined,\n  listener: SubscribeListener<V, R>,\n): () => void {\n  return subscribeToCoValue(\n    existing.constructor as CoValueClass<V>,\n    existing.id,\n    {\n      loadAs: existing._loadedAs,\n      resolve: options?.resolve,\n      onUnavailable: options?.onUnavailable,\n      onUnauthorized: options?.onUnauthorized,\n    },\n    listener,\n  );\n}\n\nexport function isAccountInstance(instance: unknown): instance is Account {\n  if (typeof instance !== \"object\" || instance === null) {\n    return false;\n  }\n\n  return \"_type\" in instance && instance._type === \"Account\";\n}\n\nexport function isAnonymousAgentInstance(\n  instance: unknown,\n): instance is AnonymousJazzAgent {\n  if (typeof instance !== \"object\" || instance === null) {\n    return false;\n  }\n\n  return \"_type\" in instance && instance._type === \"Anonymous\";\n}\n\nexport function parseCoValueCreateOptions(\n  options:\n    | {\n        owner?: Account | Group;\n        unique?: CoValueUniqueness[\"uniqueness\"];\n      }\n    | Account\n    | Group\n    | undefined,\n) {\n  const Group = RegisteredSchemas[\"Group\"];\n\n  if (!options) {\n    return { owner: Group.create(), uniqueness: undefined };\n  }\n\n  if (\"_type\" in options) {\n    if (options._type === \"Account\" || options._type === \"Group\") {\n      return { owner: options, uniqueness: undefined };\n    }\n  }\n\n  const uniqueness = options.unique\n    ? { uniqueness: options.unique }\n    : undefined;\n\n  return {\n    owner: options.owner ?? Group.create(),\n    uniqueness,\n  };\n}\n\nexport function parseGroupCreateOptions(\n  options:\n    | {\n        owner?: Account;\n      }\n    | Account\n    | undefined,\n) {\n  if (!options) {\n    return { owner: activeAccountContext.get() };\n  }\n\n  return \"_type\" in options && isAccountInstance(options)\n    ? { owner: options }\n    : { owner: options.owner ?? activeAccountContext.get() };\n}\n"],"mappings":"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","names":["enum","rawEdit","ref","ControlledAccount","RawAccount","RawAccount","ControlledAccount","cojsonInternals","rawEntry","cojsonInternals","ControlledAccount","cojsonInternals","ControlledAccount","ref","cojsonInternals","ref","RawAccount","RawAccount","error","message","ControlledAccount","RawAccount","calcPatch","RawAccount","ControlledAccount","calcPatch","value","key","optional","unsubFromStateChange","value","RawAccount","RawAccount","ref","LocalNode","LocalNode","account","creationProps","zodSchemaToCoSchema","zodSchemaToCoSchema","literal","zodSchemaToCoSchema","cojsonInternals","cojsonInternals","object","Group"]}