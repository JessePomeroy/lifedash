var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/implementation/zodSchema/zodReExport.ts
var zodReExport_exports = {};
__export(zodReExport_exports, {
  array: () => array,
  base64: () => base64,
  base64url: () => base64url,
  boolean: () => boolean,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  discriminatedUnion: () => discriminatedUnion,
  email: () => email,
  emoji: () => emoji,
  enum: () => enum2,
  int: () => int,
  int32: () => int32,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  iso: () => iso,
  json: () => json,
  literal: () => literal,
  nanoid: () => nanoid,
  number: () => number,
  object: () => object,
  optional: () => optional,
  strictObject: () => strictObject,
  string: () => string,
  templateLiteral: () => templateLiteral,
  tuple: () => tuple,
  ulid: () => ulid,
  union: () => union,
  url: () => url,
  uuid: () => uuid,
  z: () => z
});
import {
  string,
  number,
  boolean,
  union,
  object,
  array,
  templateLiteral,
  json,
  tuple,
  date,
  emoji,
  base64,
  base64url,
  nanoid,
  cuid,
  cuid2,
  ulid,
  ipv4,
  ipv6,
  email,
  url,
  uuid,
  literal,
  enum as enum2,
  cidrv4,
  cidrv6,
  iso,
  int32,
  strictObject,
  discriminatedUnion,
  int,
  optional,
  z
} from "zod/v4";

// src/coValues/CoValueBase.ts
import { ControlledAccount, RawAccount } from "cojson";
var CoValueBase = class {
  get _owner() {
    const schema = this._raw.group instanceof RawAccount ? RegisteredSchemas["Account"] : RegisteredSchemas["Group"];
    return accessChildById(this, this._raw.group.id, {
      ref: schema,
      optional: false
    });
  }
  /** @private */
  get _loadedAs() {
    const agent = this._raw.core.node.getCurrentAgent();
    if (agent instanceof ControlledAccount) {
      return coValuesCache.get(
        agent.account,
        () => anySchemaToCoSchema(RegisteredSchemas["Account"]).fromRaw(
          agent.account
        )
      );
    }
    return new AnonymousJazzAgent(this._raw.core.node);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(..._args) {
    Object.defineProperty(this, "_instanceID", {
      value: `instance-${Math.random().toString(36).slice(2)}`,
      enumerable: false
    });
  }
  /** @category Internals */
  static fromRaw(raw) {
    return new this({ fromRaw: raw });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON() {
    return {
      id: this.id,
      type: this._type,
      error: "unknown CoValue class"
    };
  }
  [inspect]() {
    return this.toJSON();
  }
  /** @category Type Helpers */
  castAs(schema) {
    const cl = "getCoSchema" in schema ? schema.getCoSchema() : schema;
    if (this.constructor === cl) {
      return this;
    }
    return cl.fromRaw(this._raw);
  }
};

// src/implementation/inspect.ts
var inspect = Symbol.for("nodejs.util.inspect.custom");

// src/implementation/symbols.ts
var SchemaInit = "$SchemaInit$";
var ItemsSym = "$items$";

// src/coValues/registeredSchemas.ts
var RegisteredSchemas = {};

// src/coValues/coMap.ts
import {
  cojsonInternals
} from "cojson";
var _CoMap = class _CoMap extends CoValueBase {
  /** @internal */
  get _schema() {
    return this.constructor._schema;
  }
  /**
   * The timestamp of the creation time of the CoMap
   */
  get _createdAt() {
    return this._raw.earliestTxMadeAt ?? Number.MAX_SAFE_INTEGER;
  }
  /**
   * The timestamp of the last updated time of the CoMap
   */
  get _lastUpdatedAt() {
    return this._raw.latestTxMadeAt;
  }
  /**
   * If property `prop` is a `coField.ref(...)`, you can use `coMaps._refs.prop` to access
   * the `Ref` instead of the potentially loaded/null value.
   *
   * This allows you to always get the ID or load the value manually.
   *
   * @example
   * ```ts
   * person._refs.pet.id; // => ID<Animal>
   * person._refs.pet.value;
   * // => Animal | null
   * const pet = await person._refs.pet.load();
   * ```
   *
   * @category Content
   **/
  get _refs() {
    return makeRefs(
      this,
      (key) => this._raw.get(key),
      () => {
        const keys = this._raw.keys().filter((key) => {
          const descriptor = this.getDescriptor(key);
          return descriptor && descriptor !== "json" && isRefEncoded(descriptor);
        });
        return keys;
      },
      this._loadedAs,
      (key) => this.getDescriptor(key)
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    );
  }
  /** @internal */
  getEditFromRaw(target, rawEdit, descriptor, key) {
    return {
      value: descriptor === "json" ? rawEdit.value : "encoded" in descriptor ? rawEdit.value === null || rawEdit.value === void 0 ? rawEdit.value : descriptor.encoded.decode(rawEdit.value) : accessChildById(target, rawEdit.value, descriptor),
      ref: descriptor !== "json" && isRefEncoded(descriptor) ? new Ref(
        rawEdit.value,
        target._loadedAs,
        descriptor,
        target
      ) : void 0,
      get by() {
        return rawEdit.by && accessChildById(target, rawEdit.by, {
          ref: Account,
          optional: false
        });
      },
      madeAt: rawEdit.at,
      key
    };
  }
  /** @category Collaboration */
  get _edits() {
    const map = this;
    return new Proxy(
      {},
      {
        get(_target, key) {
          const rawEdit = map._raw.lastEditAt(key);
          if (!rawEdit) return void 0;
          const descriptor = map.getDescriptor(key);
          if (!descriptor) return void 0;
          return {
            ...map.getEditFromRaw(map, rawEdit, descriptor, key),
            get all() {
              return [...map._raw.editsAt(key)].map(
                (rawEdit2) => map.getEditFromRaw(map, rawEdit2, descriptor, key)
              );
            }
          };
        },
        ownKeys(_target) {
          return map._raw.keys();
        },
        getOwnPropertyDescriptor(target, key) {
          return {
            value: Reflect.get(target, key),
            writable: false,
            enumerable: true,
            configurable: true
          };
        }
      }
    );
  }
  /** @internal */
  constructor(options) {
    super();
    if (options) {
      if ("fromRaw" in options) {
        Object.defineProperties(this, {
          id: {
            value: options.fromRaw.id,
            enumerable: false
          },
          _raw: { value: options.fromRaw, enumerable: false }
        });
      } else {
        throw new Error("Invalid CoMap constructor arguments");
      }
    }
    return new Proxy(this, CoMapProxyHandler);
  }
  /**
   * Create a new CoMap with the given initial values and owner.
   *
   * The owner (a Group or Account) determines access rights to the CoMap.
   *
   * The CoMap will immediately be persisted and synced to connected peers.
   *
   * @example
   * ```ts
   * const person = Person.create({
   *   name: "Alice",
   *   age: 42,
   *   pet: cat,
   * }, { owner: friendGroup });
   * ```
   *
   * @category Creation
   **/
  static create(init, options) {
    const instance = new this();
    const { owner, uniqueness } = parseCoValueCreateOptions(options);
    const raw = instance.rawFromInit(init, owner, uniqueness);
    Object.defineProperties(instance, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _raw: { value: raw, enumerable: false }
    });
    return instance;
  }
  /**
   * Return a JSON representation of the `CoMap`
   * @category Content
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON(_key, processedValues) {
    const result = {
      id: this.id,
      _type: this._type
    };
    for (const key of this._raw.keys()) {
      const tKey = key;
      const descriptor = this.getDescriptor(tKey);
      if (!descriptor) {
        continue;
      }
      if (descriptor == "json" || "encoded" in descriptor) {
        result[key] = this._raw.get(key);
      } else if (isRefEncoded(descriptor)) {
        const id = this._raw.get(key);
        if (processedValues?.includes(id) || id === this.id) {
          result[key] = { _circular: id };
          continue;
        }
        const ref2 = this[tKey];
        if (ref2 && typeof ref2 === "object" && "toJSON" in ref2 && typeof ref2.toJSON === "function") {
          const jsonedRef = ref2.toJSON(tKey, [
            ...processedValues || [],
            this.id
          ]);
          result[key] = jsonedRef;
        }
      } else {
        result[key] = void 0;
      }
    }
    return result;
  }
  [inspect]() {
    return this.toJSON();
  }
  /**
   * Create a new `RawCoMap` from an initialization object
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  rawFromInit(init, owner, uniqueness) {
    const rawOwner = owner._raw;
    const rawInit = {};
    if (init)
      for (const key of Object.keys(init)) {
        const initValue = init[key];
        const descriptor = this.getDescriptor(key);
        if (!descriptor) {
          continue;
        }
        if (descriptor === "json") {
          rawInit[key] = initValue;
        } else if (isRefEncoded(descriptor)) {
          if (initValue) {
            rawInit[key] = initValue.id;
          }
        } else if ("encoded" in descriptor) {
          rawInit[key] = descriptor.encoded.encode(
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            initValue
          );
        }
      }
    return rawOwner.createMap(rawInit, null, "private", uniqueness);
  }
  getDescriptor(key) {
    return this._schema?.[key] || this._schema?.[ItemsSym];
  }
  /**
   * Declare a Record-like CoMap schema, by extending `CoMap.Record(...)` and passing the value schema using `co`. Keys are always `string`.
   *
   * @example
   * ```ts
   * import { coField, CoMap } from "jazz-tools";
   *
   * class ColorToFruitMap extends CoMap.Record(
   *  coField.ref(Fruit)
   * ) {}
   *
   * // assume we have map: ColorToFruitMap
   * // and strawberry: Fruit
   * map["red"] = strawberry;
   * ```
   *
   * @category Declaration
   */
  static Record(value) {
    var _a, _b;
    class RecordLikeCoMap extends (_b = _CoMap, _a = ItemsSym, _b) {
      constructor() {
        super(...arguments);
        this[_a] = value;
      }
    }
    return RecordLikeCoMap;
  }
  /**
   * Load a `CoMap` with a given ID, as a given account.
   *
   * `depth` specifies which (if any) fields that reference other CoValues to load as well before resolving.
   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.
   *
   * You can pass `[]` or `{}` for shallowly loading only this CoMap, or `{ fieldA: depthA, fieldB: depthB }` for recursively loading referenced CoValues.
   *
   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.
   *
   * @example
   * ```ts
   * const person = await Person.load(
   *   "co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax",
   *   { pet: {} }
   * );
   * ```
   *
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  static findUnique(unique, ownerID, as) {
    as ||= activeAccountContext.get();
    const header = {
      type: "comap",
      ruleset: {
        type: "ownedByGroup",
        group: ownerID
      },
      meta: null,
      uniqueness: unique
    };
    const crypto = as._type === "Anonymous" ? as.node.crypto : as._raw.core.node.crypto;
    return cojsonInternals.idforHeader(header, crypto);
  }
  /**
   * Given an already loaded `CoMap`, ensure that the specified fields are loaded to the specified depth.
   *
   * Works like `CoMap.load()`, but you don't need to pass the ID or the account to load as again.
   *
   * @category Subscription & Loading
   */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  applyDiff(newValues) {
    for (const key in newValues) {
      if (Object.prototype.hasOwnProperty.call(newValues, key)) {
        const tKey = key;
        const descriptor = this.getDescriptor(key);
        if (!descriptor) continue;
        const newValue = newValues[tKey];
        const currentValue = this[tKey];
        if (descriptor === "json" || "encoded" in descriptor) {
          if (currentValue !== newValue) {
            this[tKey] = newValue;
          }
        } else if (isRefEncoded(descriptor)) {
          const currentId = currentValue?.id;
          const newId = newValue?.id;
          if (currentId !== newId) {
            this[tKey] = newValue;
          }
        }
      }
    }
    return this;
  }
  /**
   * Wait for the `CoMap` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
_CoMap.prototype._type = "CoMap";
var CoMap = _CoMap;
var CoMapProxyHandler = {
  get(target, key, receiver) {
    if (key === "_schema") {
      return Reflect.get(target, key);
    } else if (key in target) {
      return Reflect.get(target, key, receiver);
    } else {
      if (typeof key !== "string") {
        return void 0;
      }
      const descriptor = target.getDescriptor(key);
      if (!descriptor) {
        return void 0;
      }
      const raw = target._raw.get(key);
      if (descriptor === "json") {
        return raw;
      } else if ("encoded" in descriptor) {
        return raw === void 0 ? void 0 : descriptor.encoded.decode(raw);
      } else if (isRefEncoded(descriptor)) {
        return raw === void 0 || raw === null ? void 0 : accessChildByKey(target, raw, key);
      }
    }
  },
  set(target, key, value, receiver) {
    if ((typeof key === "string" || ItemsSym) && typeof value === "object" && value !== null && SchemaInit in value) {
      target.constructor._schema ||= {};
      target.constructor._schema[key] = value[SchemaInit];
      return true;
    }
    const descriptor = target.getDescriptor(key);
    if (!descriptor) return false;
    if (typeof key === "string") {
      if (descriptor === "json") {
        target._raw.set(key, value);
      } else if ("encoded" in descriptor) {
        target._raw.set(key, descriptor.encoded.encode(value));
      } else if (isRefEncoded(descriptor)) {
        if (value === void 0) {
          if (descriptor.optional) {
            target._raw.set(key, null);
          } else {
            throw new Error(
              `Cannot set required reference ${key} to undefined`
            );
          }
        } else if (value?.id) {
          target._raw.set(key, value.id);
        } else {
          throw new Error(
            `Cannot set reference ${key} to a non-CoValue. Got ${value}`
          );
        }
      }
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  },
  defineProperty(target, key, attributes) {
    if ("value" in attributes && typeof attributes.value === "object" && SchemaInit in attributes.value) {
      target.constructor._schema ||= {};
      target.constructor._schema[key] = attributes.value[SchemaInit];
      return true;
    } else {
      return Reflect.defineProperty(target, key, attributes);
    }
  },
  ownKeys(target) {
    const keys = Reflect.ownKeys(target).filter((k) => k !== ItemsSym);
    for (const key of target._raw.keys()) {
      if (!keys.includes(key)) {
        keys.push(key);
      }
    }
    return keys;
  },
  getOwnPropertyDescriptor(target, key) {
    if (key in target) {
      return Reflect.getOwnPropertyDescriptor(target, key);
    } else {
      const descriptor = target.getDescriptor(key);
      if (descriptor || key in target._raw.latest) {
        return {
          enumerable: true,
          configurable: true,
          writable: true
        };
      }
    }
  },
  has(target, key) {
    const descriptor = target.getDescriptor(key);
    if (target._raw && typeof key === "string" && descriptor) {
      return target._raw.get(key) !== void 0;
    } else {
      return Reflect.has(target, key);
    }
  },
  deleteProperty(target, key) {
    const descriptor = target.getDescriptor(key);
    if (typeof key === "string" && descriptor) {
      target._raw.delete(key);
      return true;
    } else {
      return Reflect.deleteProperty(target, key);
    }
  }
};
RegisteredSchemas["CoMap"] = CoMap;

// src/coValues/coList.ts
import { ControlledAccount as ControlledAccount2, RawAccount as RawAccount2 } from "cojson";
import { calcPatch } from "fast-myers-diff";
var _CoList = class _CoList extends Array {
  /**
   * Declare a `CoList` by subclassing `CoList.Of(...)` and passing the item schema using `co`.
   *
   * @example
   * ```ts
   * class ColorList extends CoList.Of(
   *   coField.string
   * ) {}
   * class AnimalList extends CoList.Of(
   *   coField.ref(Animal)
   * ) {}
   * ```
   *
   * @category Declaration
   */
  static Of(item) {
    var _a, _b;
    return class CoListOf extends (_b = _CoList, _a = coField.items, _b) {
      constructor() {
        super(...arguments);
        this[_a] = item;
      }
    };
  }
  /**
   * @ignore
   * @deprecated Use UPPERCASE `CoList.Of` instead! */
  static of(..._args) {
    throw new Error("Can't use Array.of with CoLists");
  }
  /** @internal */
  get _schema() {
    return this.constructor._schema;
  }
  /** @category Collaboration */
  get _owner() {
    return this._raw.group instanceof RawAccount2 ? anySchemaToCoSchema(RegisteredSchemas["Account"]).fromRaw(
      this._raw.group
    ) : RegisteredSchemas["Group"].fromRaw(this._raw.group);
  }
  /**
   * If a `CoList`'s items are a `coField.ref(...)`, you can use `coList._refs[i]` to access
   * the `Ref` instead of the potentially loaded/null value.
   *
   * This allows you to always get the ID or load the value manually.
   *
   * @example
   * ```ts
   * animals._refs[0].id; // => ID<Animal>
   * animals._refs[0].value;
   * // => Animal | null
   * const animal = await animals._refs[0].load();
   * ```
   *
   * @category Content
   **/
  get _refs() {
    return makeRefs(
      this,
      (idx) => this._raw.get(idx),
      () => Array.from({ length: this._raw.entries().length }, (_, idx) => idx),
      this._loadedAs,
      (_idx) => this._schema[ItemsSym]
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    );
  }
  get _edits() {
    throw new Error("Not implemented");
  }
  get _loadedAs() {
    const agent = this._raw.core.node.getCurrentAgent();
    if (agent instanceof ControlledAccount2) {
      return coValuesCache.get(
        agent.account,
        () => anySchemaToCoSchema(RegisteredSchemas["Account"]).fromRaw(
          agent.account
        )
      );
    }
    return new AnonymousJazzAgent(this._raw.core.node);
  }
  static get [(ItemsSym, Symbol.species)]() {
    return Array;
  }
  getItemsDescriptor() {
    return this._schema?.[ItemsSym];
  }
  constructor(options) {
    super();
    Object.defineProperty(this, "_instanceID", {
      value: `instance-${Math.random().toString(36).slice(2)}`,
      enumerable: false
    });
    if (options && "fromRaw" in options) {
      Object.defineProperties(this, {
        id: {
          value: options.fromRaw.id,
          enumerable: false
        },
        _raw: { value: options.fromRaw, enumerable: false }
      });
    }
    return new Proxy(this, CoListProxyHandler);
  }
  /**
   * Create a new CoList with the given initial values and owner.
   *
   * The owner (a Group or Account) determines access rights to the CoMap.
   *
   * The CoList will immediately be persisted and synced to connected peers.
   *
   * @example
   * ```ts
   * const colours = ColorList.create(
   *   ["red", "green", "blue"],
   *   { owner: me }
   * );
   * const animals = AnimalList.create(
   *   [cat, dog, fish],
   *   { owner: me }
   * );
   * ```
   *
   * @category Creation
   **/
  static create(items, options) {
    const { owner } = parseCoValueCreateOptions(options);
    const instance = new this({ init: items, owner });
    const raw = owner._raw.createList(
      toRawItems(items, instance._schema[ItemsSym])
    );
    Object.defineProperties(instance, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _raw: { value: raw, enumerable: false }
    });
    return instance;
  }
  push(...items) {
    this._raw.appendItems(
      toRawItems(items, this._schema[ItemsSym]),
      void 0,
      "private"
    );
    return this._raw.entries().length;
  }
  unshift(...items) {
    for (const item of toRawItems(items, this._schema[ItemsSym])) {
      this._raw.prepend(item);
    }
    return this._raw.entries().length;
  }
  pop() {
    const last = this[this.length - 1];
    this._raw.delete(this.length - 1);
    return last;
  }
  shift() {
    const first = this[0];
    this._raw.delete(0);
    return first;
  }
  /**
   * Splice the `CoList` at a given index.
   *
   * @param start - The index to start the splice.
   * @param deleteCount - The number of items to delete.
   * @param items - The items to insert.
   */
  splice(start, deleteCount, ...items) {
    const deleted = this.slice(start, start + deleteCount);
    for (let idxToDelete = start + deleteCount - 1; idxToDelete >= start; idxToDelete--) {
      this._raw.delete(idxToDelete);
    }
    const rawItems = toRawItems(items, this._schema[ItemsSym]);
    if (rawItems.length === 0) {
      return deleted;
    }
    if (rawItems.length === 1) {
      const item = rawItems[0];
      if (item === void 0) return deleted;
      if (start === 0) {
        this._raw.prepend(item);
      } else {
        this._raw.append(item, Math.max(start - 1, 0));
      }
      return deleted;
    }
    if (start === 0) {
      for (let i = rawItems.length - 1; i >= 0; i--) {
        const item = rawItems[i];
        if (item === void 0) continue;
        this._raw.prepend(item);
      }
    } else {
      let appendAfter = Math.max(start - 1, 0);
      for (const item of rawItems) {
        if (item === void 0) continue;
        this._raw.append(item, appendAfter);
        appendAfter++;
      }
    }
    return deleted;
  }
  /**
   * Modify the `CoList` to match another list, where the changes are managed internally.
   *
   * @param result - The resolved list of items.
   */
  applyDiff(result) {
    const current = this._raw.asArray();
    const comparator = isRefEncoded(this._schema[ItemsSym]) ? (aIdx, bIdx) => {
      return current[aIdx]?.id === result[bIdx]?.id;
    } : void 0;
    const patches = [...calcPatch(current, result, comparator)];
    for (const [from, to, insert] of patches.reverse()) {
      this.splice(from, to - from, ...insert);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON(_key, seenAbove) {
    const itemDescriptor = this._schema[ItemsSym];
    if (itemDescriptor === "json") {
      return this._raw.asArray();
    } else if ("encoded" in itemDescriptor) {
      return this._raw.asArray().map((e) => itemDescriptor.encoded.encode(e));
    } else if (isRefEncoded(itemDescriptor)) {
      return this.map(
        (item, idx) => seenAbove?.includes(item?.id) ? { _circular: item.id } : item?.toJSON(idx + "", [
          ...seenAbove || [],
          this.id
        ])
      );
    } else {
      return [];
    }
  }
  [inspect]() {
    return this.toJSON();
  }
  /** @category Internals */
  static fromRaw(raw) {
    return new this({ fromRaw: raw });
  }
  /** @internal */
  static schema(def) {
    this._schema ||= {};
    Object.assign(this._schema, def);
  }
  /**
   * Load a `CoList` with a given ID, as a given account.
   *
   * `depth` specifies if item CoValue references should be loaded as well before resolving.
   * The `DeeplyLoaded` return type guarantees that corresponding referenced CoValues are loaded to the specified depth.
   *
   * You can pass `[]` or for shallowly loading only this CoList, or `[itemDepth]` for recursively loading referenced CoValues.
   *
   * Check out the `load` methods on `CoMap`/`CoList`/`CoFeed`/`Group`/`Account` to see which depth structures are valid to nest.
   *
   * @example
   * ```ts
   * const animalsWithVets =
   *   await ListOfAnimals.load(
   *     "co_zdsMhHtfG6VNKt7RqPUPvUtN2Ax",
   *     me,
   *     [{ vet: {} }]
   *   );
   * ```
   *
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /**
   * Given an already loaded `CoList`, ensure that items are loaded to the specified depth.
   *
   * Works like `CoList.load()`, but you don't need to pass the ID or the account to load as again.
   *
   * @category Subscription & Loading
   */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  /** @category Type Helpers */
  castAs(cl) {
    return cl.fromRaw(this._raw);
  }
  /**
   * Wait for the `CoList` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
_CoList.prototype._type = "CoList";
var CoList = _CoList;
function toRawItems(items, itemDescriptor) {
  const rawItems = itemDescriptor === "json" ? items : "encoded" in itemDescriptor ? items?.map((e) => itemDescriptor.encoded.encode(e)) : isRefEncoded(itemDescriptor) ? items?.map((v) => {
    if (!v) return null;
    return v.id;
  }) : (() => {
    throw new Error("Invalid element descriptor");
  })();
  return rawItems;
}
var CoListProxyHandler = {
  get(target, key, receiver) {
    if (typeof key === "string" && !isNaN(+key)) {
      const itemDescriptor = target._schema[ItemsSym];
      const rawValue = target._raw.get(Number(key));
      if (itemDescriptor === "json") {
        return rawValue;
      } else if ("encoded" in itemDescriptor) {
        return rawValue === void 0 ? void 0 : itemDescriptor.encoded.decode(rawValue);
      } else if (isRefEncoded(itemDescriptor)) {
        return rawValue === void 0 || rawValue === null ? void 0 : accessChildByKey(target, rawValue, key);
      }
    } else if (key === "length") {
      return target._raw.entries().length;
    } else {
      return Reflect.get(target, key, receiver);
    }
  },
  set(target, key, value, receiver) {
    if (key === ItemsSym && typeof value === "object" && SchemaInit in value) {
      target.constructor._schema ||= {};
      target.constructor._schema[ItemsSym] = value[SchemaInit];
      return true;
    }
    if (typeof key === "string" && !isNaN(+key)) {
      const itemDescriptor = target._schema[ItemsSym];
      let rawValue;
      if (itemDescriptor === "json") {
        rawValue = value;
      } else if ("encoded" in itemDescriptor) {
        rawValue = itemDescriptor.encoded.encode(value);
      } else if (isRefEncoded(itemDescriptor)) {
        if (value === void 0) {
          if (itemDescriptor.optional) {
            rawValue = null;
          } else {
            throw new Error(
              `Cannot set required reference ${key} to undefined`
            );
          }
        } else if (value?.id) {
          rawValue = value.id;
        } else {
          throw new Error(
            `Cannot set reference ${key} to a non-CoValue. Got ${value}`
          );
        }
      }
      target._raw.replace(Number(key), rawValue);
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.value && key === ItemsSym && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
      target.constructor._schema ||= {};
      target.constructor._schema[ItemsSym] = descriptor.value[SchemaInit];
      return true;
    } else {
      return Reflect.defineProperty(target, key, descriptor);
    }
  },
  has(target, key) {
    if (typeof key === "string" && !isNaN(+key)) {
      return Number(key) < target._raw.entries().length;
    } else {
      return Reflect.has(target, key);
    }
  }
};

// src/coValues/coFeed.ts
import { MAX_RECOMMENDED_TX_SIZE, cojsonInternals as cojsonInternals2 } from "cojson";
var _CoFeed = class _CoFeed extends CoValueBase {
  /**
   * Declare a `CoFeed` by subclassing `CoFeed.Of(...)` and passing the item schema using a `co` primitive or a `coField.ref`.
   *
   * @example
   * ```ts
   * class ColorFeed extends CoFeed.Of(coField.string) {}
   * class AnimalFeed extends CoFeed.Of(coField.ref(Animal)) {}
   * ```
   *
   * @category Declaration
   */
  static Of(item) {
    var _a, _b;
    const cls = class CoFeedOf extends (_b = _CoFeed, _a = coField.items, _b) {
      constructor() {
        super(...arguments);
        this[_a] = item;
      }
    };
    cls._schema ||= {};
    cls._schema[ItemsSym] = item[SchemaInit];
    return cls;
  }
  /** @internal */
  get _schema() {
    return this.constructor._schema;
  }
  /**
   * The current account's view of this `CoFeed`
   * @category Content
   */
  get byMe() {
    if (this._loadedAs._type === "Account") {
      return this.perAccount[this._loadedAs.id];
    } else {
      return void 0;
    }
  }
  /**
   * The per-account view of this `CoFeed`
   *
   * @example
   * ```ts
   * // Access entries directly by account ID
   * const aliceEntries = feed[aliceAccount.id];
   * console.log(aliceEntries.value); // Latest value from Alice
   *
   * // Iterate through all accounts' entries
   * for (const [accountId, entries] of Object.entries(feed)) {
   *   console.log(`Latest entry from ${accountId}:`, entries.value);
   *
   *   // Access all entries from this account
   *   for (const entry of entries.all) {
   *     console.log(`Entry made at ${entry.madeAt}:`, entry.value);
   *   }
   * }
   * ```
   *
   * @category Content
   */
  get perAccount() {
    return new Proxy({}, CoStreamPerAccountProxyHandler(this));
  }
  /**
   * The per-session view of this `CoFeed`
   * @category Content
   */
  get perSession() {
    return new Proxy(
      {},
      CoStreamPerSessionProxyHandler(this, this)
    );
  }
  /**
   * The current session's view of this `CoFeed`
   *
   * This is a shortcut for `this.perSession` where the session ID is the current session ID.
   *
   * @category Content
   */
  get inCurrentSession() {
    if (this._loadedAs._type === "Account") {
      return this.perSession[this._loadedAs.sessionID];
    } else {
      return void 0;
    }
  }
  constructor(options) {
    super();
    if (options && "fromRaw" in options) {
      Object.defineProperties(this, {
        id: {
          value: options.fromRaw.id,
          enumerable: false
        },
        _raw: { value: options.fromRaw, enumerable: false }
      });
    }
    return this;
  }
  /**
   * Create a new `CoFeed`
   * @category Creation
   */
  static create(init, options) {
    const { owner } = parseCoValueCreateOptions(options);
    const instance = new this({ init, owner });
    const raw = owner._raw.createStream();
    Object.defineProperties(instance, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _raw: { value: raw, enumerable: false }
    });
    if (init) {
      instance.push(...init);
    }
    return instance;
  }
  getItemsDescriptor() {
    return this._schema?.[ItemsSym];
  }
  /**
   * Push items to this `CoFeed`
   *
   * Items are appended to the current session's log. Each session (tab, device, app instance)
   * maintains its own append-only log, which is then aggregated into the per-account view.
   *
   * @example
   * ```ts
   * // Adds items to current session's log
   * feed.push("item1", "item2");
   *
   * // View items from current session
   * console.log(feed.inCurrentSession);
   *
   * // View aggregated items from all sessions for current account
   * console.log(feed.byMe);
   * ```
   *
   * @category Content
   */
  push(...items) {
    for (const item of items) {
      this.pushItem(item);
    }
  }
  pushItem(item) {
    const itemDescriptor = this._schema[ItemsSym];
    if (itemDescriptor === "json") {
      this._raw.push(item);
    } else if ("encoded" in itemDescriptor) {
      this._raw.push(itemDescriptor.encoded.encode(item));
    } else if (isRefEncoded(itemDescriptor)) {
      this._raw.push(item.id);
    }
  }
  /**
   * Get a JSON representation of the `CoFeed`
   * @category
   */
  toJSON() {
    const itemDescriptor = this._schema[ItemsSym];
    const mapper = itemDescriptor === "json" ? (v) => v : "encoded" in itemDescriptor ? itemDescriptor.encoded.encode : (v) => v && v.id;
    return {
      id: this.id,
      _type: this._type,
      ...Object.fromEntries(
        Object.entries(this).map(([account, entry]) => [
          account,
          mapper(entry.value)
        ])
      ),
      in: Object.fromEntries(
        Object.entries(this.perSession).map(([session, entry]) => [
          session,
          mapper(entry.value)
        ])
      )
    };
  }
  /** @internal */
  [(ItemsSym, inspect)]() {
    return this.toJSON();
  }
  /** @internal */
  static schema(def) {
    this._schema ||= {};
    Object.assign(this._schema, def);
  }
  /**
   * Load a `CoFeed`
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /**
   * Ensure a `CoFeed` is loaded to the specified depth
   *
   * @returns A new instance of the same CoFeed that's loaded to the specified depth
   * @category Subscription & Loading
   */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  /**
   * Wait for the `CoFeed` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
_CoFeed.prototype._type = "CoStream";
var CoFeed = _CoFeed;
function entryFromRawEntry(accessFrom, rawEntry, loadedAs, accountID, itemField) {
  return {
    get value() {
      if (itemField === "json") {
        return rawEntry.value;
      } else if ("encoded" in itemField) {
        return itemField.encoded.decode(rawEntry.value);
      } else if (isRefEncoded(itemField)) {
        return accessChildById(
          accessFrom,
          rawEntry.value,
          itemField
        );
      } else {
        throw new Error("Invalid item field schema");
      }
    },
    get ref() {
      if (itemField !== "json" && isRefEncoded(itemField)) {
        const rawId = rawEntry.value;
        return new Ref(
          rawId,
          loadedAs,
          itemField,
          accessFrom
        );
      } else {
        return void 0;
      }
    },
    get by() {
      return accountID && accessChildById(accessFrom, accountID, {
        ref: Account,
        optional: false
      });
    },
    madeAt: rawEntry.at,
    tx: rawEntry.tx
  };
}
var CoStreamPerAccountProxyHandler = (innerTarget) => ({
  get(_target, key, receiver) {
    if (typeof key === "string" && key.startsWith("co_")) {
      const rawEntry = innerTarget._raw.lastItemBy(key);
      if (!rawEntry) return;
      const entry = entryFromRawEntry(
        receiver,
        rawEntry,
        innerTarget._loadedAs,
        key,
        innerTarget._schema[ItemsSym]
      );
      Object.defineProperty(entry, "all", {
        get: () => {
          const allRawEntries = innerTarget._raw.itemsBy(key);
          return function* () {
            while (true) {
              const rawEntry2 = allRawEntries.next();
              if (rawEntry2.done) return;
              yield entryFromRawEntry(
                receiver,
                rawEntry2.value,
                innerTarget._loadedAs,
                key,
                innerTarget._schema[ItemsSym]
              );
            }
          }();
        }
      });
      return entry;
    } else {
      return Reflect.get(innerTarget, key, receiver);
    }
  },
  ownKeys(_target) {
    return Array.from(innerTarget._raw.accounts());
  },
  getOwnPropertyDescriptor(_target, key) {
    if (typeof key === "string" && key.startsWith("co_")) {
      return {
        configurable: true,
        enumerable: true,
        writable: false
      };
    } else {
      return Reflect.getOwnPropertyDescriptor(innerTarget, key);
    }
  }
});
var CoStreamPerSessionProxyHandler = (innerTarget, accessFrom) => ({
  get(_target, key, receiver) {
    if (typeof key === "string" && key.includes("session")) {
      const sessionID = key;
      const rawEntry = innerTarget._raw.lastItemIn(sessionID);
      if (!rawEntry) return;
      const by = cojsonInternals2.accountOrAgentIDfromSessionID(sessionID);
      const entry = entryFromRawEntry(
        accessFrom,
        rawEntry,
        innerTarget._loadedAs,
        cojsonInternals2.isAccountID(by) ? by : void 0,
        innerTarget._schema[ItemsSym]
      );
      Object.defineProperty(entry, "all", {
        get: () => {
          const allRawEntries = innerTarget._raw.itemsIn(sessionID);
          return function* () {
            while (true) {
              const rawEntry2 = allRawEntries.next();
              if (rawEntry2.done) return;
              yield entryFromRawEntry(
                accessFrom,
                rawEntry2.value,
                innerTarget._loadedAs,
                cojsonInternals2.isAccountID(by) ? by : void 0,
                innerTarget._schema[ItemsSym]
              );
            }
          }();
        }
      });
      return entry;
    } else {
      return Reflect.get(innerTarget, key, receiver);
    }
  },
  ownKeys() {
    return innerTarget._raw.sessions();
  },
  getOwnPropertyDescriptor(target, key) {
    if (typeof key === "string" && key.startsWith("co_")) {
      return {
        configurable: true,
        enumerable: true,
        writable: false
      };
    } else {
      return Reflect.getOwnPropertyDescriptor(target, key);
    }
  }
});
var FileStream = class extends CoValueBase {
  constructor(options) {
    super();
    let raw;
    if ("fromRaw" in options) {
      raw = options.fromRaw;
    } else {
      const rawOwner = options.owner._raw;
      raw = rawOwner.createBinaryStream();
    }
    Object.defineProperties(this, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _type: { value: "BinaryCoStream", enumerable: false },
      _raw: { value: raw, enumerable: false }
    });
  }
  /**
   * Create a new empty `FileStream` instance.
   *
   * @param options - Configuration options for the new FileStream
   * @param options.owner - The Account or Group that will own this FileStream and control access rights
   *
   * @example
   * ```typescript
   * // Create owned by an account
   * const stream = FileStream.create({ owner: myAccount });
   *
   * // Create owned by a group
   * const stream = FileStream.create({ owner: teamGroup });
   *
   * // Create with implicit owner
   * const stream = FileStream.create(myAccount);
   * ```
   *
   * @remarks
   * For uploading an existing file or blob, use {@link FileStream.createFromBlob} instead.
   *
   * @category Creation
   */
  static create(options) {
    return new this(parseCoValueCreateOptions(options));
  }
  getMetadata() {
    return this._raw.getBinaryStreamInfo();
  }
  getChunks(options) {
    return this._raw.getBinaryChunks(options?.allowUnfinished);
  }
  isBinaryStreamEnded() {
    return this._raw.isBinaryStreamEnded();
  }
  start(options) {
    this._raw.startBinaryStream(options);
  }
  push(data) {
    this._raw.pushBinaryStreamChunk(data);
  }
  end() {
    this._raw.endBinaryStream();
  }
  toBlob(options) {
    const chunks = this.getChunks({
      allowUnfinished: options?.allowUnfinished
    });
    if (!chunks) {
      return void 0;
    }
    return new Blob(chunks.chunks, { type: chunks.mimeType });
  }
  /**
   * Load a `FileStream` as a `Blob`
   *
   * @category Content
   */
  static async loadAsBlob(id, options) {
    let stream = await this.load(id, options);
    return stream?.toBlob({
      allowUnfinished: options?.allowUnfinished
    });
  }
  /**
   * Create a `FileStream` from a `Blob` or `File`
   *
   * @example
   * ```ts
   * import { coField, FileStream } from "jazz-tools";
   *
   * const fileStream = await FileStream.createFromBlob(file, {owner: group})
   * ```
   * @category Content
   */
  static async createFromBlob(blob, options) {
    const stream = this.create(options);
    const onProgress = options && "onProgress" in options ? options.onProgress : void 0;
    const start = Date.now();
    const data = new Uint8Array(await blob.arrayBuffer());
    stream.start({
      mimeType: blob.type,
      totalSizeBytes: blob.size,
      fileName: blob instanceof File ? blob.name : void 0
    });
    const chunkSize = MAX_RECOMMENDED_TX_SIZE;
    let lastProgressUpdate = Date.now();
    for (let idx = 0; idx < data.length; idx += chunkSize) {
      stream.push(data.slice(idx, idx + chunkSize));
      if (Date.now() - lastProgressUpdate > 100) {
        onProgress?.(idx / data.length);
        lastProgressUpdate = Date.now();
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    stream.end();
    const end = Date.now();
    console.debug(
      "Finished creating binary stream in",
      (end - start) / 1e3,
      "s - Throughput in MB/s",
      1e3 * (blob.size / (end - start)) / (1024 * 1024)
    );
    onProgress?.(1);
    return stream;
  }
  /**
   * Get a JSON representation of the `FileStream`
   * @category Content
   */
  toJSON() {
    return {
      id: this.id,
      _type: this._type,
      ...this.getChunks()
    };
  }
  /** @internal */
  [inspect]() {
    return this.toJSON();
  }
  /**
   * Load a `FileStream`
   * @category Subscription & Loading
   */
  static async load(id, options) {
    const stream = await loadCoValueWithoutMe(this, id, options);
    if (!options?.allowUnfinished && !stream?.isBinaryStreamEnded()) {
      return new Promise((resolve) => {
        subscribeToCoValueWithoutMe(
          this,
          id,
          options || {},
          (value, unsubscribe) => {
            if (value.isBinaryStreamEnded()) {
              unsubscribe();
              resolve(value);
            }
          }
        );
      });
    }
    return stream;
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /**
   * An instance method to subscribe to an existing `FileStream`
   * @category Subscription & Loading
   */
  subscribe(listener) {
    return subscribeToExistingCoValue(this, {}, listener);
  }
  /**
   * Wait for the `FileStream` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};

// src/coValues/account.ts
import {
  ControlledAccount as ControlledAccount3,
  LocalNode,
  cojsonInternals as cojsonInternals3
} from "cojson";
var _Account = class _Account extends CoValueBase {
  get _schema() {
    return this.constructor._schema;
  }
  get _owner() {
    return this;
  }
  get _loadedAs() {
    if (this.isLocalNodeOwner) return this;
    const agent = this._raw.core.node.getCurrentAgent();
    if (agent instanceof ControlledAccount3) {
      return coValuesCache.get(
        agent.account,
        () => _Account.fromRaw(agent.account)
      );
    }
    return new AnonymousJazzAgent(this._raw.core.node);
  }
  getDescriptor(key) {
    if (key === "profile") {
      return this._schema.profile;
    } else if (key === "root") {
      return this._schema.root;
    }
    return void 0;
  }
  get _refs() {
    const profileID = this._raw.get("profile");
    const rootID = this._raw.get("root");
    return {
      profile: profileID ? new Ref(
        profileID,
        this._loadedAs,
        this._schema.profile,
        this
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ) : void 0,
      root: rootID ? new Ref(
        rootID,
        this._loadedAs,
        this._schema.root,
        this
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ) : void 0
    };
  }
  /**
   * Whether this account is the currently active account.
   */
  get isMe() {
    return activeAccountContext.get().id === this.id;
  }
  constructor(options) {
    super();
    if (!("fromRaw" in options)) {
      throw new Error("Can only construct account from raw or with .create()");
    }
    this.isLocalNodeOwner = options.fromRaw.id == options.fromRaw.core.node.getCurrentAgent().id;
    Object.defineProperties(this, {
      id: {
        value: options.fromRaw.id,
        enumerable: false
      },
      _raw: { value: options.fromRaw, enumerable: false },
      _type: { value: "Account", enumerable: false }
    });
    if (this.isLocalNodeOwner) {
      this.sessionID = options.fromRaw.core.node.currentSessionID;
    }
    return new Proxy(this, AccountAndGroupProxyHandler);
  }
  myRole() {
    if (this.isLocalNodeOwner) {
      return "admin";
    }
  }
  getRoleOf(member) {
    if (member === "me") {
      return this.isMe ? "admin" : void 0;
    }
    if (member === this.id) {
      return "admin";
    }
    return void 0;
  }
  getParentGroups() {
    return [];
  }
  get members() {
    const ref2 = new Ref(
      this.id,
      this._loadedAs,
      {
        ref: () => this.constructor,
        optional: false
      },
      this
    );
    return [{ id: this.id, role: "admin", ref: ref2, account: this }];
  }
  canRead(value) {
    const role = value._owner.getRoleOf(this.id);
    return role === "admin" || role === "writer" || role === "reader" || role === "writeOnly";
  }
  canWrite(value) {
    const role = value._owner.getRoleOf(this.id);
    return role === "admin" || role === "writer" || role === "writeOnly";
  }
  canAdmin(value) {
    return value._owner.getRoleOf(this.id) === "admin";
  }
  async acceptInvite(valueID, inviteSecret, coValueClass) {
    if (!this.isLocalNodeOwner) {
      throw new Error("Only a controlled account can accept invites");
    }
    await this._raw.core.node.acceptInvite(
      valueID,
      inviteSecret
    );
    return loadCoValue(anySchemaToCoSchema(coValueClass), valueID, {
      loadAs: this
    });
  }
  /** @private */
  static async create(options) {
    const { node } = await LocalNode.withNewlyCreatedAccount({
      ...options,
      migration: async (rawAccount, _node, creationProps) => {
        const account = new this({
          fromRaw: rawAccount
        });
        await account.applyMigration?.(creationProps);
      }
    });
    return this.fromNode(node);
  }
  static getMe() {
    return activeAccountContext.get();
  }
  static async createAs(as, options) {
    const connectedPeers = cojsonInternals3.connectedPeers(
      "creatingAccount",
      "createdAccount",
      { peer1role: "server", peer2role: "client" }
    );
    as._raw.core.node.syncManager.addPeer(connectedPeers[1]);
    const account = await this.create({
      creationProps: options.creationProps,
      crypto: as._raw.core.node.crypto,
      peersToLoadFrom: [connectedPeers[0]]
    });
    await account.waitForAllCoValuesSync();
    return account;
  }
  static fromNode(node) {
    return new this({
      fromRaw: node.expectCurrentAccount("jazz-tools/Account.fromNode")
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON() {
    return {
      id: this.id,
      _type: this._type
    };
  }
  [inspect]() {
    return this.toJSON();
  }
  async applyMigration(creationProps) {
    await this.migrate(creationProps);
    if (this.profile === void 0 && creationProps) {
      const profileGroup = RegisteredSchemas["Group"].create({ owner: this });
      this.profile = Profile.create({ name: creationProps.name }, profileGroup);
      profileGroup.addMember("everyone", "reader");
    } else if (this.profile && creationProps) {
      if (this.profile._owner._type !== "Group") {
        throw new Error("Profile must be owned by a Group", {
          cause: `The profile of the account "${this.id}" was created with an Account as owner, which is not allowed.`
        });
      }
    }
    const node = this._raw.core.node;
    const profile = node.expectCoValueLoaded(this._raw.get("profile")).getCurrentContent();
    if (!profile.get("inbox")) {
      const inboxRoot = createInboxRoot(this);
      profile.set("inbox", inboxRoot.id);
      profile.set("inboxInvite", inboxRoot.inviteLink);
    }
  }
  // Placeholder method for subclasses to override
  migrate(creationProps) {
    creationProps;
  }
  /** @category Subscription & Loading */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /** @category Subscription & Loading */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  /**
   * Wait for the `Account` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
  /**
   * Wait for all the available `CoValues` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForAllCoValuesSync(options) {
    return this._raw.core.node.syncManager.waitForAllCoValuesSync(
      options?.timeout
    );
  }
};
_Account._schema = {
  profile: {
    ref: () => Profile,
    optional: false
  },
  root: {
    ref: () => RegisteredSchemas["CoMap"],
    optional: true
  }
};
var Account = _Account;
var AccountAndGroupProxyHandler = {
  get(target, key, receiver) {
    if (key === "profile" || key === "root") {
      const id = target._raw.get(key);
      if (id) {
        return accessChildByKey(target, id, key);
      } else {
        return void 0;
      }
    } else {
      return Reflect.get(target, key, receiver);
    }
  },
  set(target, key, value, receiver) {
    if ((key === "profile" || key === "root") && typeof value === "object" && SchemaInit in value) {
      target.constructor._schema ||= {};
      target.constructor._schema[key] = value[SchemaInit];
      return true;
    } else if (key === "profile") {
      if (value) {
        target._raw.set(
          "profile",
          value.id,
          "trusting"
        );
      }
      return true;
    } else if (key === "root") {
      if (value) {
        target._raw.set("root", value.id);
      }
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  },
  defineProperty(target, key, descriptor) {
    if ((key === "profile" || key === "root") && typeof descriptor.value === "object" && SchemaInit in descriptor.value) {
      target.constructor._schema ||= {};
      target.constructor._schema[key] = descriptor.value[SchemaInit];
      return true;
    } else {
      return Reflect.defineProperty(target, key, descriptor);
    }
  }
};
function isControlledAccount(account) {
  return account.isLocalNodeOwner;
}
RegisteredSchemas["Account"] = Account;

// src/coValues/group.ts
var _Group = class _Group extends CoValueBase {
  get _schema() {
    return this.constructor._schema;
  }
  get _refs() {
    const profileID = this._raw.get("profile");
    const rootID = this._raw.get("root");
    return {
      profile: profileID ? new Ref(
        profileID,
        this._loadedAs,
        this._schema.profile,
        this
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ) : void 0,
      root: rootID ? new Ref(
        rootID,
        this._loadedAs,
        this._schema.root,
        this
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ) : void 0
    };
  }
  /** @deprecated Don't use constructor directly, use .create */
  constructor(options) {
    super();
    let raw;
    if (options && "fromRaw" in options) {
      raw = options.fromRaw;
    } else {
      const initOwner = options.owner;
      if (!initOwner) throw new Error("No owner provided");
      if (initOwner._type === "Account" && isControlledAccount(initOwner)) {
        const rawOwner = initOwner._raw;
        raw = rawOwner.core.node.createGroup();
      } else {
        throw new Error("Can only construct group as a controlled account");
      }
    }
    Object.defineProperties(this, {
      id: {
        value: raw.id,
        enumerable: false
      },
      _raw: { value: raw, enumerable: false }
    });
    return new Proxy(this, AccountAndGroupProxyHandler);
  }
  static create(options) {
    return new this(parseGroupCreateOptions(options));
  }
  myRole() {
    return this._raw.myRole();
  }
  addMember(member, role) {
    if (member !== "everyone" && member._type === "Group") {
      if (role === "writeOnly")
        throw new Error("Cannot add group as member with write-only role");
      this._raw.extend(member._raw, role);
    } else if (role !== void 0 && role !== "inherit") {
      this._raw.addMember(member === "everyone" ? member : member._raw, role);
    }
  }
  removeMember(member) {
    if (member !== "everyone" && member._type === "Group") {
      return this._raw.revokeExtend(member._raw);
    } else {
      return this._raw.removeMember(
        member === "everyone" ? member : member._raw
      );
    }
  }
  get members() {
    const members = [];
    const refEncodedAccountSchema = {
      ref: () => Account,
      optional: false
    };
    for (const accountID of this._raw.getAllMemberKeysSet()) {
      if (!isAccountID(accountID)) continue;
      const role = this._raw.roleOf(accountID);
      if (role === "admin" || role === "writer" || role === "reader" || role === "writeOnly") {
        const ref2 = new Ref(
          accountID,
          this._loadedAs,
          refEncodedAccountSchema,
          this
        );
        const group = this;
        members.push({
          id: accountID,
          role,
          ref: ref2,
          get account() {
            return accessChildById(group, accountID, refEncodedAccountSchema);
          }
        });
      }
    }
    return members;
  }
  getRoleOf(member) {
    if (member === "me") {
      return this._raw.roleOf(
        activeAccountContext.get().id
      );
    }
    return this._raw.roleOf(
      member === "everyone" ? member : member
    );
  }
  /**
   * Make the group public, so that everyone can read it.
   * Alias for `addMember("everyone", role)`.
   *
   * @param role - Optional: the role to grant to everyone. Defaults to "reader".
   * @returns The group itself.
   */
  makePublic(role = "reader") {
    this.addMember("everyone", role);
    return this;
  }
  getParentGroups() {
    return this._raw.getParentGroups().map((group) => _Group.fromRaw(group));
  }
  /** @category Identity & Permissions
   * Gives members of a parent group membership in this group.
   * @deprecated Use `addMember` instead.
   * @param parent The group that will gain access to this group.
   * @param roleMapping The role all members of the parent group should have in this group.
   * @returns This group.
   */
  extend(parent, roleMapping) {
    this._raw.extend(parent._raw, roleMapping);
    return this;
  }
  /** @category Identity & Permissions
   * Revokes membership from members a parent group.
   * @deprecated Use `removeMember` instead.
   * @param parent The group that will lose access to this group.
   * @returns This group.
   */
  async revokeExtend(parent) {
    await this._raw.revokeExtend(parent._raw);
    return this;
  }
  /** @category Subscription & Loading */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /** @category Subscription & Loading */
  ensureLoaded(options) {
    return ensureCoValueLoaded(this, options);
  }
  subscribe(...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToExistingCoValue(this, options, listener);
  }
  /**
   * Wait for the `Group` to be uploaded to the other peers.
   *
   * @category Subscription & Loading
   */
  waitForSync(options) {
    return this._raw.core.waitForSync(options);
  }
};
_Group.prototype._type = "Group";
_Group._schema = {
  profile: "json",
  root: "json"
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
};
Object.defineProperty(_Group.prototype, "_schema", {
  get: () => _Group._schema
});
var Group = _Group;
RegisteredSchemas["Group"] = Group;
function isAccountID(id) {
  return id.startsWith("co_");
}

// src/coValues/profile.ts
var Profile = class extends CoMap {
  constructor() {
    super(...arguments);
    this.name = coField.string;
    this.inbox = coField.optional.string;
    this.inboxInvite = coField.optional.string;
  }
  /**
   * Creates a new profile with the given initial values and owner.
   *
   * The owner (a Group) determines access rights to the Profile.
   *
   * @category Creation
   */
  static create(init, options) {
    const owner = options !== void 0 && "owner" in options ? options.owner : options;
    if (owner?._type === "Account") {
      throw new Error("Profiles should be owned by a group");
    }
    return super.create(init, options);
  }
};

// src/coValues/inbox.ts
import { RawAccount as RawAccount4 } from "cojson";
function createInboxRoot(account) {
  if (!account.isLocalNodeOwner) {
    throw new Error("Account is not controlled");
  }
  const rawAccount = account._raw;
  const group = rawAccount.core.node.createGroup();
  const messagesFeed = group.createStream();
  const inboxRoot = rawAccount.createMap();
  const processedFeed = rawAccount.createStream();
  const failedFeed = rawAccount.createStream();
  const inviteLink = `${messagesFeed.id}/${group.createInvite("writeOnly")}`;
  inboxRoot.set("messages", messagesFeed.id);
  inboxRoot.set("processed", processedFeed.id);
  inboxRoot.set("failed", failedFeed.id);
  return {
    id: inboxRoot.id,
    inviteLink
  };
}
async function createInboxMessage(payload, inboxOwner) {
  const group = payload._raw.group;
  if (group instanceof RawAccount4) {
    throw new Error("Inbox messages should be owned by a group");
  }
  group.addMember(inboxOwner, "writer");
  const message = group.createMap({
    payload: payload.id,
    result: void 0,
    processed: false,
    error: void 0
  });
  await payload._raw.core.waitForSync();
  await message.core.waitForSync();
  return message;
}
var Inbox = class _Inbox {
  constructor(account, root, messages, processed, failed) {
    this.processing = /* @__PURE__ */ new Set();
    this.account = account;
    this.root = root;
    this.messages = messages;
    this.processed = processed;
    this.failed = failed;
  }
  subscribe(Schema, callback, options = {}) {
    const processed = /* @__PURE__ */ new Set();
    const failed = /* @__PURE__ */ new Map();
    const node = this.account._raw.core.node;
    this.processed.subscribe((stream) => {
      for (const items of Object.values(stream.items)) {
        for (const item of items) {
          processed.add(item.value);
        }
      }
    });
    const { account } = this;
    const { retries = 3 } = options;
    let failTimer = void 0;
    const clearFailTimer = () => {
      clearTimeout(failTimer);
      failTimer = void 0;
    };
    const handleNewMessages = (stream) => {
      clearFailTimer();
      for (const [sessionID, items] of Object.entries(stream.items)) {
        const accountID = getAccountIDfromSessionID(sessionID);
        if (!accountID) {
          console.warn("Received message from unknown account", sessionID);
          continue;
        }
        for (const item of items) {
          const txKey = `${sessionID}/${item.tx.txIndex}`;
          if (!processed.has(txKey) && !this.processing.has(txKey)) {
            this.processing.add(txKey);
            const id = item.value;
            node.load(id).then((message) => {
              if (message === "unavailable") {
                return Promise.reject(
                  new Error("Unable to load inbox message " + id)
                );
              }
              return loadCoValue(
                anySchemaToCoSchema(Schema),
                message.get("payload"),
                {
                  loadAs: account
                }
              );
            }).then((value) => {
              if (!value) {
                return Promise.reject(
                  new Error("Unable to load inbox message " + id)
                );
              }
              return callback(value, accountID);
            }).then((result) => {
              const inboxMessage = node.expectCoValueLoaded(item.value).getCurrentContent();
              if (result) {
                inboxMessage.set("result", result.id);
              }
              inboxMessage.set("processed", true);
              this.processed.push(txKey);
              this.processing.delete(txKey);
            }).catch((error) => {
              console.error("Error processing inbox message", error);
              this.processing.delete(txKey);
              const errors = failed.get(txKey) ?? [];
              const stringifiedError = String(error);
              errors.push(stringifiedError);
              let inboxMessage;
              try {
                inboxMessage = node.expectCoValueLoaded(item.value).getCurrentContent();
                inboxMessage.set("error", stringifiedError);
              } catch (error2) {
              }
              if (errors.length > retries) {
                inboxMessage?.set("processed", true);
                this.processed.push(txKey);
                this.failed.push({ errors, value: item.value });
              } else {
                failed.set(txKey, errors);
                if (!failTimer) {
                  failTimer = setTimeout(
                    () => handleNewMessages(stream),
                    100
                  );
                }
              }
            });
          }
        }
      }
    };
    const unsubscribe = this.messages.subscribe(handleNewMessages);
    return () => {
      unsubscribe();
      clearFailTimer();
    };
  }
  static async load(account) {
    const profile = account.profile;
    if (!profile) {
      throw new Error("Account profile should already be loaded");
    }
    if (!profile.inbox) {
      throw new Error("The account has not set up their inbox");
    }
    const node = account._raw.core.node;
    const root = await node.load(profile.inbox);
    if (root === "unavailable") {
      throw new Error("Inbox not found");
    }
    const [messages, processed, failed] = await Promise.all([
      node.load(root.get("messages")),
      node.load(root.get("processed")),
      node.load(root.get("failed"))
    ]);
    if (messages === "unavailable" || processed === "unavailable" || failed === "unavailable") {
      throw new Error("Inbox not found");
    }
    return new _Inbox(account, root, messages, processed, failed);
  }
};
var InboxSender = class _InboxSender {
  constructor(currentAccount, owner, messages) {
    this.currentAccount = currentAccount;
    this.owner = owner;
    this.messages = messages;
  }
  getOwnerAccount() {
    return this.owner;
  }
  async sendMessage(message) {
    const inboxMessage = await createInboxMessage(message, this.owner);
    this.messages.push(inboxMessage.id);
    return new Promise((resolve, reject) => {
      inboxMessage.subscribe((message2) => {
        if (message2.get("processed")) {
          const error = message2.get("error");
          if (error) {
            reject(new Error(error));
          } else {
            resolve(
              message2.get("result")
            );
          }
        }
      });
    });
  }
  static async load(inboxOwnerID, currentAccount) {
    currentAccount ||= activeAccountContext.get();
    const node = currentAccount._raw.core.node;
    const inboxOwnerRaw = await node.load(
      inboxOwnerID
    );
    if (inboxOwnerRaw === "unavailable") {
      throw new Error("Failed to load the inbox owner");
    }
    const inboxOwnerProfileRaw = await node.load(inboxOwnerRaw.get("profile"));
    if (inboxOwnerProfileRaw === "unavailable") {
      throw new Error("Failed to load the inbox owner profile");
    }
    if (inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== "reader" && inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== "writer" && inboxOwnerProfileRaw.group.roleOf(currentAccount._raw.id) !== "admin") {
      throw new Error(
        "Insufficient permissions to access the inbox, make sure its user profile is publicly readable."
      );
    }
    const inboxInvite = inboxOwnerProfileRaw.get("inboxInvite");
    if (!inboxInvite) {
      throw new Error("The user has not set up their inbox");
    }
    const id = await acceptInvite(inboxInvite, currentAccount);
    const messages = await node.load(id);
    if (messages === "unavailable") {
      throw new Error("Inbox not found");
    }
    return new _InboxSender(currentAccount, inboxOwnerRaw, messages);
  }
};
async function acceptInvite(invite, account) {
  account ||= activeAccountContext.get();
  const id = invite.slice(0, invite.indexOf("/"));
  const inviteSecret = invite.slice(invite.indexOf("/") + 1);
  if (!id?.startsWith("co_z") || !inviteSecret.startsWith("inviteSecret_")) {
    throw new Error("Invalid inbox ticket");
  }
  if (!account.isLocalNodeOwner) {
    throw new Error("Account is not controlled");
  }
  await account._raw.core.node.acceptInvite(id, inviteSecret);
  return id;
}
function getAccountIDfromSessionID(sessionID) {
  const until = sessionID.indexOf("_session");
  const accountID = sessionID.slice(0, until);
  if (accountID.startsWith("co_z")) {
    return accountID;
  }
  return;
}

// src/coValues/coPlainText.ts
import {
  ControlledAccount as ControlledAccount4,
  RawAccount as RawAccount5,
  stringifyOpID
} from "cojson";
import { calcPatch as calcPatch2 } from "fast-myers-diff";

// src/lib/cache.ts
var weakMap = /* @__PURE__ */ new WeakMap();
var coValuesCache = {
  get: (raw, compute) => {
    const cached = weakMap.get(raw);
    if (cached) {
      return cached;
    }
    const computed = compute();
    weakMap.set(raw, computed);
    return computed;
  }
};

// src/coValues/coPlainText.ts
var CoPlainText = class extends String {
  get _owner() {
    return this._raw.group instanceof RawAccount5 ? Account.fromRaw(this._raw.group) : Group.fromRaw(this._raw.group);
  }
  get _loadedAs() {
    const agent = this._raw.core.node.getCurrentAgent();
    if (agent instanceof ControlledAccount4) {
      return coValuesCache.get(
        agent.account,
        () => anySchemaToCoSchema(RegisteredSchemas["Account"]).fromRaw(
          agent.account
        )
      );
    }
    return new AnonymousJazzAgent(this._raw.core.node);
  }
  /** @internal */
  constructor(options) {
    if (!options) {
      super("");
      return;
    }
    if ("fromRaw" in options) {
      super(options.fromRaw.toString());
      const raw = options.fromRaw;
      Object.defineProperties(this, {
        id: { value: raw.id, enumerable: false },
        _type: { value: "CoPlainText", enumerable: false },
        _raw: { value: raw, enumerable: false }
      });
      return;
    }
    if ("text" in options && "owner" in options) {
      super(options.text);
      const raw = options.owner._raw.createPlainText(options.text);
      Object.defineProperties(this, {
        id: { value: raw.id, enumerable: false },
        _type: { value: "CoPlainText", enumerable: false },
        _raw: { value: raw, enumerable: false }
      });
      return;
    }
    throw new Error("Invalid constructor arguments");
  }
  /**
   * Create a new `CoPlainText` with the given text and owner.
   *
   * The owner (a Group or Account) determines access rights to the CoPlainText.
   *
   * The CoPlainText will immediately be persisted and synced to connected peers.
   *
   * @example
   * ```ts
   * const text = CoPlainText.create("Hello, world!", { owner: me });
   * ```
   *
   * @category Creation
   */
  static create(text, options) {
    const { owner } = parseCoValueCreateOptions(options);
    return new this({ text, owner });
  }
  get length() {
    return this._raw.toString().length;
  }
  toString() {
    return this._raw.toString();
  }
  valueOf() {
    return this._raw.toString();
  }
  toJSON() {
    return this._raw.toString();
  }
  [inspect]() {
    return this.toJSON();
  }
  insertBefore(idx, text) {
    this._raw.insertBefore(idx, text);
  }
  insertAfter(idx, text) {
    this._raw.insertAfter(idx, text);
  }
  deleteRange(range) {
    this._raw.deleteRange(range);
  }
  posBefore(idx) {
    return this._raw.mapping.opIDbeforeIdx[idx];
  }
  posAfter(idx) {
    return this._raw.mapping.opIDafterIdx[idx];
  }
  idxBefore(pos) {
    return this._raw.mapping.idxBeforeOpID[stringifyOpID(pos)];
  }
  idxAfter(pos) {
    return this._raw.mapping.idxAfterOpID[stringifyOpID(pos)];
  }
  static fromRaw(raw) {
    return new this({ fromRaw: raw });
  }
  /**
   * Apply text, modifying the text in place. Calculates the diff and applies it to the CoValue.
   *
   * @category Mutation
   */
  applyDiff(other) {
    const current = this._raw.toString();
    const currentGraphemes = this._raw.toGraphemes(current);
    const otherGraphemes = this._raw.toGraphemes(other);
    const patches = [...calcPatch2(currentGraphemes, otherGraphemes)];
    for (const [from, to, insert] of patches.reverse()) {
      if (to > from) {
        this.deleteRange({ from, to });
      }
      if (insert.length > 0) {
        this.insertBefore(from, this._raw.fromGraphemes(insert));
      }
    }
  }
  /**
   * Load a `CoPlainText` with a given ID, as a given account.
   *
   * @category Subscription & Loading
   */
  static load(id, options) {
    return loadCoValueWithoutMe(this, id, options);
  }
  static subscribe(id, ...args) {
    const { options, listener } = parseSubscribeRestArgs(args);
    return subscribeToCoValueWithoutMe(this, id, options, listener);
  }
  /**
   * Given an already loaded `CoPlainText`, subscribe to updates to the `CoPlainText` and ensure that the specified fields are loaded to the specified depth.
   *
   * Works like `CoPlainText.subscribe()`, but you don't need to pass the ID or the account to load as again.
   *
   * Returns an unsubscribe function that you should call when you no longer need updates.
   *
   * @category Subscription & Loading
   **/
  subscribe(listener) {
    return subscribeToExistingCoValue(this, {}, listener);
  }
  /**
   * Allow CoPlainText to behave like a primitive string in most contexts (e.g.,
   * string concatenation, template literals, React rendering, etc.) by implementing
   * Symbol.toPrimitive. This eliminates the need to call .toString() explicitly.
   *
   * The 'hint' parameter indicates the preferred type of conversion:
   * - 'string': prefer string conversion
   * - 'number': prefer number conversion (attempt to parse the text as a number)
   * - 'default': usually treat as string
   */
  [Symbol.toPrimitive](hint) {
    if (hint === "number") {
      return Number(this._raw.toString());
    }
    return this._raw.toString();
  }
};

// src/coValues/coRichText.ts
var CoRichText = class extends CoPlainText {
};

// src/coValues/schemaUnion.ts
var SchemaUnion = class _SchemaUnion extends CoValueBase {
  /**
   * Create a new union type from a discriminator function.
   *
   * The discriminator function receives the raw data and should return the appropriate concrete class to use for that data.
   *
   * When loading a SchemaUnion, the correct subclass will be instantiated based on the discriminator.
   *
   * @param discriminator - Function that determines which concrete type to use
   * @returns A new class that can create/load instances of the union type
   *
   * @example
   * ```ts
   * const WidgetUnion = SchemaUnion.Of<BaseWidget>((raw) => {
   *   switch (raw.get("type")) {
   *     case "button": return ButtonWidget;
   *     case "slider": return SliderWidget;
   *     default: throw new Error("Unknown widget type");
   *   }
   * });
   *
   * const widget = await loadCoValue(WidgetUnion, id, me, {});
   *
   * // You can narrow the returned instance to a subclass by using `instanceof`
   * if (widget instanceof ButtonWidget) {
   *   console.log(widget.label);
   * } else if (widget instanceof SliderWidget) {
   *   console.log(widget.min, widget.max);
   * }
   * ```
   *
   * @category Declaration
   **/
  static Of(discriminator) {
    return class SchemaUnionClass extends _SchemaUnion {
      static fromRaw(raw) {
        const ResolvedClass = discriminator(
          raw
        );
        return ResolvedClass.fromRaw(raw);
      }
    };
  }
  /**
   * Create an instance from raw data. This is called internally and should not be used directly.
   * Use {@link SchemaUnion.Of} to create a union type instead.
   *
   * @internal
   */
  // @ts-ignore
  static fromRaw(raw) {
    throw new Error("Not implemented");
  }
};

// src/implementation/anonymousJazzAgent.ts
var AnonymousJazzAgent = class {
  constructor(node) {
    this.node = node;
    this._type = "Anonymous";
  }
};

// src/implementation/activeAccountContext.ts
var ActiveAccountContext = class {
  constructor() {
    this.activeAccount = null;
    this.guestMode = false;
  }
  set(account) {
    this.activeAccount = account;
    this.guestMode = false;
  }
  setGuestMode() {
    this.activeAccount = null;
    this.guestMode = true;
  }
  maybeGet() {
    return this.activeAccount;
  }
  get() {
    if (!this.activeAccount) {
      if (this.guestMode) {
        throw new Error(
          "Something that expects a full active account was called in guest mode."
        );
      }
      throw new Error("No active account");
    }
    return this.activeAccount;
  }
};
var activeAccountContext = new ActiveAccountContext();

// src/implementation/refs.ts
var Ref = class {
  constructor(id, controlledAccount, schema, parent) {
    this.id = id;
    this.controlledAccount = controlledAccount;
    this.schema = schema;
    this.parent = parent;
    if (!isRefEncoded(schema)) {
      throw new Error("Ref must be constructed with a ref schema");
    }
  }
  async load() {
    const subscriptionScope = getSubscriptionScope(this.parent);
    subscriptionScope.subscribeToId(this.id, this.schema);
    const node = subscriptionScope.childNodes.get(this.id);
    if (!node) {
      return null;
    }
    const value = node.value;
    if (value?.type === "loaded") {
      return value.value;
    } else {
      return new Promise((resolve) => {
        const unsubscribe = node.subscribe((value2) => {
          if (value2?.type === "loaded") {
            unsubscribe();
            resolve(value2.value);
          } else if (value2?.type === "unavailable") {
            unsubscribe();
            resolve(null);
          } else if (value2?.type === "unauthorized") {
            unsubscribe();
            resolve(null);
          }
        });
      });
    }
  }
  get value() {
    return accessChildById(this.parent, this.id, this.schema);
  }
};
function makeRefs(parent, getIdForKey, getKeysWithIds, controlledAccount, refSchemaForKey) {
  const refs = {};
  return new Proxy(refs, {
    get(_target, key) {
      if (key === Symbol.iterator) {
        return function* () {
          for (const key2 of getKeysWithIds()) {
            yield new Ref(
              getIdForKey(key2),
              controlledAccount,
              refSchemaForKey(key2),
              parent
            );
          }
        };
      }
      if (typeof key === "symbol") return void 0;
      if (key === "length") {
        return getKeysWithIds().length;
      }
      const id = getIdForKey(key);
      if (!id) return void 0;
      return new Ref(
        id,
        controlledAccount,
        refSchemaForKey(key),
        parent
      );
    },
    ownKeys() {
      return getKeysWithIds().map((key) => key.toString());
    },
    getOwnPropertyDescriptor(target, key) {
      const id = getIdForKey(key);
      if (id) {
        return {
          enumerable: true,
          configurable: true,
          writable: true
        };
      } else {
        return Reflect.getOwnPropertyDescriptor(target, key);
      }
    }
  });
}

// src/implementation/schema.ts
var Encoders = {
  Date: {
    encode: (value) => value.toISOString(),
    decode: (value) => new Date(value)
  },
  OptionalDate: {
    encode: (value) => value?.toISOString() || null,
    decode: (value) => value === null ? void 0 : new Date(value)
  }
};
var optional2 = {
  ref: optionalRef,
  json() {
    return { [SchemaInit]: "json" };
  },
  encoded(arg) {
    return { [SchemaInit]: { encoded: arg } };
  },
  string: {
    [SchemaInit]: "json"
  },
  number: {
    [SchemaInit]: "json"
  },
  boolean: {
    [SchemaInit]: "json"
  },
  null: {
    [SchemaInit]: "json"
  },
  Date: {
    [SchemaInit]: { encoded: Encoders.OptionalDate }
  },
  literal(..._lit) {
    return { [SchemaInit]: "json" };
  }
};
var coField = {
  string: {
    [SchemaInit]: "json"
  },
  number: {
    [SchemaInit]: "json"
  },
  boolean: {
    [SchemaInit]: "json"
  },
  null: {
    [SchemaInit]: "json"
  },
  Date: {
    [SchemaInit]: { encoded: Encoders.Date }
  },
  literal(..._lit) {
    return { [SchemaInit]: "json" };
  },
  json() {
    return { [SchemaInit]: "json" };
  },
  encoded(arg) {
    return { [SchemaInit]: { encoded: arg } };
  },
  ref,
  items: ItemsSym,
  optional: optional2
};
function optionalRef(arg) {
  return ref(arg, { optional: true });
}
function ref(arg, options) {
  return {
    [SchemaInit]: {
      ref: arg,
      optional: options?.optional || false
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  };
}
function isRefEncoded(schema) {
  return typeof schema === "object" && "ref" in schema && "optional" in schema && typeof schema.ref === "function";
}
function instantiateRefEncoded(schema, raw) {
  return isCoValueClass(schema.ref) ? schema.ref.fromRaw(raw) : schema.ref(
    raw
  ).fromRaw(raw);
}

// src/lib/migration.ts
function applyCoValueMigrations(instance) {
  const node = instance._raw.core.node;
  const migratedCoValues = node._migratedCoValues ??= /* @__PURE__ */ new Set();
  if ("migrate" in instance && typeof instance.migrate === "function" && instance._type !== "Account" && !migratedCoValues.has(instance.id)) {
    migratedCoValues.add(instance.id);
    const result = instance.migrate?.(instance);
    if (result && "then" in result) {
      throw new Error("Migration function cannot be async");
    }
  }
}

// src/subscribe/CoValueCoreSubscription.ts
var CoValueCoreSubscription = class {
  constructor(node, id, listener) {
    this.node = node;
    this.id = id;
    this.listener = listener;
    this._unsubscribe = () => {
    };
    this.unsubscribed = false;
    const entry = this.node.getCoValue(this.id);
    if (entry?.isAvailable()) {
      this.subscribe(entry.getCurrentContent());
    } else {
      this.node.loadCoValueCore(this.id).then((value) => {
        if (this.unsubscribed) return;
        if (value.isAvailable()) {
          this.subscribe(value.getCurrentContent());
        } else {
          this.listener("unavailable");
          this.subscribeToState();
        }
      });
    }
  }
  subscribeToState() {
    const entry = this.node.getCoValue(this.id);
    const handleStateChange = (core, unsubFromStateChange2) => {
      if (this.unsubscribed) {
        unsubFromStateChange2();
        return;
      }
      if (core.isAvailable()) {
        this.subscribe(core.getCurrentContent());
        unsubFromStateChange2();
      }
    };
    const unsubFromStateChange = entry.subscribe(handleStateChange);
    this._unsubscribe = () => {
      unsubFromStateChange();
    };
  }
  subscribe(value) {
    if (this.unsubscribed) return;
    this._unsubscribe = value.subscribe((value2) => {
      this.listener(value2);
    });
    this.listener(value);
  }
  unsubscribe() {
    if (this.unsubscribed) return;
    this.unsubscribed = true;
    this._unsubscribe();
  }
};

// src/subscribe/JazzError.ts
var JazzError = class _JazzError {
  constructor(id, type, issues) {
    this.id = id;
    this.type = type;
    this.issues = issues;
  }
  toString() {
    return this.issues.map((issue) => {
      let message = `${issue.message}`;
      if (this.id) {
        message += ` from ${this.id}`;
      }
      if (issue.path.length > 0) {
        message += ` on path ${issue.path.join(".")}`;
      }
      return message;
    }).join("\n");
  }
  prependPath(item) {
    if (this.issues.length === 0) {
      return this;
    }
    const issues = this.issues.map((issue) => {
      return {
        ...issue,
        path: [item].concat(issue.path)
      };
    });
    return new _JazzError(this.id, this.type, issues);
  }
};

// src/subscribe/utils.ts
import { RawAccount as RawAccount6 } from "cojson";
function getOwnerFromRawValue(raw) {
  const owner = raw.group;
  return coValuesCache.get(
    owner,
    () => owner instanceof RawAccount6 ? anySchemaToCoSchema(RegisteredSchemas["Account"]).fromRaw(owner) : RegisteredSchemas["Group"].fromRaw(owner)
  );
}
function createCoValue(ref2, raw, subscriptionScope) {
  const freshValueInstance = instantiateRefEncoded(ref2, raw);
  Object.defineProperty(freshValueInstance, "_subscriptionScope", {
    value: subscriptionScope,
    writable: false,
    enumerable: false,
    configurable: false
  });
  return {
    type: "loaded",
    value: freshValueInstance,
    id: subscriptionScope.id
  };
}

// src/subscribe/SubscriptionScope.ts
var SubscriptionScope = class _SubscriptionScope {
  constructor(node, resolve, id, schema) {
    this.node = node;
    this.id = id;
    this.schema = schema;
    this.childNodes = /* @__PURE__ */ new Map();
    this.childValues = /* @__PURE__ */ new Map();
    this.childErrors = /* @__PURE__ */ new Map();
    this.validationErrors = /* @__PURE__ */ new Map();
    this.dirty = false;
    this.idsSubscribed = /* @__PURE__ */ new Set();
    this.autoloaded = /* @__PURE__ */ new Set();
    this.autoloadedKeys = /* @__PURE__ */ new Set();
    this.skipInvalidKeys = /* @__PURE__ */ new Set();
    this.totalValidTransactions = 0;
    this.migrated = false;
    this.migrating = false;
    this.silenceUpdates = false;
    this.handleChildUpdate = (id, value, key) => {
      if (value.type === "unloaded") {
        return;
      }
      this.childValues.set(id, value);
      if (value.type === "unavailable" || value.type === "unauthorized") {
        this.childErrors.set(id, value.prependPath(key ?? id));
        this.errorFromChildren = this.computeChildErrors();
      } else if (this.errorFromChildren && this.childErrors.has(id)) {
        this.childErrors.delete(id);
        this.errorFromChildren = this.computeChildErrors();
      }
      if (this.shouldSendUpdates()) {
        if (this.value.type === "loaded") {
          this.updateValue(
            createCoValue(this.schema, this.value.value._raw, this)
          );
        }
      }
      this.triggerUpdate();
    };
    this.subscribers = /* @__PURE__ */ new Set();
    this.resolve = resolve;
    this.value = { type: "unloaded", id };
    let lastUpdate;
    this.subscription = new CoValueCoreSubscription(node, id, (value) => {
      lastUpdate = value;
      if (!this.migrated && value !== "unavailable") {
        if (this.migrating) {
          return;
        }
        this.migrating = true;
        applyCoValueMigrations(instantiateRefEncoded(this.schema, value));
        this.migrated = true;
        this.handleUpdate(lastUpdate);
        return;
      }
      this.handleUpdate(value);
    });
  }
  updateValue(value) {
    this.value = value;
    this.dirty = true;
  }
  handleUpdate(update) {
    if (update === "unavailable") {
      if (this.value.type === "unloaded") {
        this.updateValue(
          new JazzError(this.id, "unavailable", [
            {
              code: "unavailable",
              message: "The value is unavailable",
              params: {
                id: this.id
              },
              path: []
            }
          ])
        );
      }
      this.triggerUpdate();
      return;
    }
    const ruleset = update.core.verified.header.ruleset;
    const hasAccess = ruleset.type !== "ownedByGroup" || getOwnerFromRawValue(update).myRole() !== void 0;
    if (!hasAccess) {
      if (this.value.type !== "unauthorized") {
        this.updateValue(
          new JazzError(this.id, "unauthorized", [
            {
              code: "unauthorized",
              message: "The current user is not authorized to access this value",
              params: {
                id: this.id
              },
              path: []
            }
          ])
        );
        this.triggerUpdate();
      }
      return;
    }
    this.silenceUpdates = true;
    if (this.value.type !== "loaded") {
      this.updateValue(createCoValue(this.schema, update, this));
      this.loadChildren();
    } else {
      const hasChanged = update.totalValidTransactions !== this.totalValidTransactions || // Checking the identity of the _raw value makes us cover the cases where the group
      // has been updated and the coValues that don't update the totalValidTransactions value (e.g. FileStream)
      this.value.value._raw !== update;
      if (this.loadChildren()) {
        this.updateValue(createCoValue(this.schema, update, this));
      } else if (hasChanged) {
        this.updateValue(createCoValue(this.schema, update, this));
      }
    }
    this.totalValidTransactions = update.totalValidTransactions;
    this.silenceUpdates = false;
    this.triggerUpdate();
  }
  computeChildErrors() {
    let issues = [];
    let errorType = "unavailable";
    if (this.childErrors.size === 0 && this.validationErrors.size === 0) {
      return void 0;
    }
    for (const [key, value] of this.childErrors.entries()) {
      if (this.autoloaded.has(key)) {
        continue;
      }
      if (this.skipInvalidKeys.has(key)) {
        continue;
      }
      errorType = value.type;
      if (value.issues) {
        issues.push(...value.issues);
      }
    }
    for (const [key, value] of this.validationErrors.entries()) {
      if (this.skipInvalidKeys.has(key)) {
        continue;
      }
      errorType = value.type;
      if (value.issues) {
        issues.push(...value.issues);
      }
    }
    if (issues.length) {
      return new JazzError(this.id, errorType, issues);
    }
    return void 0;
  }
  shouldSendUpdates() {
    if (this.value.type === "unloaded") return false;
    if (this.value.type !== "loaded") return true;
    for (const value of this.childValues.values()) {
      if (value.type === "unloaded" && !this.autoloaded.has(value.id)) {
        return false;
      }
    }
    return true;
  }
  getCurrentValue() {
    if (this.value.type === "unauthorized" || this.value.type === "unavailable") {
      console.error(this.value.toString());
      return null;
    }
    if (!this.shouldSendUpdates()) {
      return void 0;
    }
    if (this.errorFromChildren) {
      console.error(this.errorFromChildren.toString());
      return null;
    }
    if (this.value.type === "loaded") {
      return this.value.value;
    }
    return void 0;
  }
  triggerUpdate() {
    if (!this.shouldSendUpdates()) return;
    if (!this.dirty) return;
    if (this.subscribers.size === 0) return;
    if (this.silenceUpdates) return;
    const error = this.errorFromChildren;
    const value = this.value;
    if (error) {
      this.subscribers.forEach((listener) => listener(error));
    } else if (value.type !== "unloaded") {
      this.subscribers.forEach((listener) => listener(value));
    }
    this.dirty = false;
  }
  subscribe(listener) {
    this.subscribers.add(listener);
    return () => {
      this.subscribers.delete(listener);
    };
  }
  setListener(listener) {
    this.subscribers.add(listener);
    this.triggerUpdate();
  }
  subscribeToKey(key) {
    if (this.resolve === true || !this.resolve) {
      this.resolve = {};
    }
    if (this.resolve.$each || key in this.resolve) {
      return;
    }
    const resolve = this.resolve;
    resolve[key] = true;
    this.autoloadedKeys.add(key);
    if (this.value.type !== "loaded") {
      return;
    }
    const value = this.value.value;
    this.silenceUpdates = true;
    if (value._type === "CoMap" || value._type === "Account") {
      const map = value;
      this.loadCoMapKey(map, key, true);
    } else if (value._type === "CoList") {
      const list = value;
      this.loadCoListKey(list, key, true);
    }
    this.silenceUpdates = false;
  }
  subscribeToId(id, descriptor) {
    if (this.idsSubscribed.has(id) || this.childValues.has(id)) {
      return;
    }
    this.idsSubscribed.add(id);
    this.autoloaded.add(id);
    this.silenceUpdates = true;
    this.childValues.set(id, { type: "unloaded", id });
    const child = new _SubscriptionScope(
      this.node,
      true,
      id,
      descriptor
    );
    this.childNodes.set(id, child);
    child.setListener((value) => this.handleChildUpdate(id, value));
    this.silenceUpdates = false;
  }
  loadChildren() {
    const { resolve } = this;
    if (this.value.type !== "loaded") {
      return false;
    }
    const value = this.value.value;
    const depth = typeof resolve !== "object" || resolve === null ? {} : resolve;
    let hasChanged = false;
    const idsToLoad = new Set(this.idsSubscribed);
    const coValueType = value._type;
    if (Object.keys(depth).length > 0) {
      if (coValueType === "CoMap" || coValueType === "Account") {
        const map = value;
        const keys = "$each" in depth ? map._raw.keys() : Object.keys(depth);
        for (const key of keys) {
          const id = this.loadCoMapKey(map, key, depth[key] ?? depth.$each);
          if (id) {
            idsToLoad.add(id);
          }
        }
      } else if (value._type === "CoList") {
        const list = value;
        const descriptor = list.getItemsDescriptor();
        if (descriptor && isRefEncoded(descriptor)) {
          list._raw.processNewTransactions();
          const entries = list._raw.entries();
          const keys = "$each" in depth ? Object.keys(entries) : Object.keys(depth);
          for (const key of keys) {
            const id = this.loadCoListKey(list, key, depth[key] ?? depth.$each);
            if (id) {
              idsToLoad.add(id);
            }
          }
        }
      } else if (value._type === "CoStream") {
        const stream = value;
        const descriptor = stream.getItemsDescriptor();
        if (descriptor && isRefEncoded(descriptor)) {
          for (const session of stream._raw.sessions()) {
            const values = stream._raw.items[session] ?? [];
            for (const [i, item] of values.entries()) {
              const key = `${session}/${i}`;
              if (!depth.$each && !depth[key]) {
                continue;
              }
              const id = item.value;
              if (id) {
                idsToLoad.add(id);
                this.loadChildNode(id, depth[key] ?? depth.$each, descriptor);
                this.validationErrors.delete(key);
              } else if (!descriptor.optional) {
                this.validationErrors.set(
                  key,
                  new JazzError(void 0, "unavailable", [
                    {
                      code: "validationError",
                      message: `The ref on position ${key} requested on ${stream.constructor.name} is missing`,
                      params: {},
                      path: [key]
                    }
                  ])
                );
              }
            }
          }
        }
      }
    }
    this.errorFromChildren = this.computeChildErrors();
    for (const id of this.childNodes.keys()) {
      if (!idsToLoad.has(id)) {
        hasChanged = true;
        const childNode = this.childNodes.get(id);
        if (childNode) {
          childNode.destroy();
        }
        this.childNodes.delete(id);
        this.childValues.delete(id);
      }
    }
    return hasChanged;
  }
  loadCoMapKey(map, key, depth) {
    if (key === "$onError") {
      return void 0;
    }
    const id = map._raw.get(key);
    const descriptor = map.getDescriptor(key);
    if (!descriptor) {
      this.childErrors.set(
        key,
        new JazzError(void 0, "unavailable", [
          {
            code: "validationError",
            message: `The ref ${key} requested on ${map.constructor.name} is not defined in the schema`,
            params: {},
            path: [key]
          }
        ])
      );
      return void 0;
    }
    if (isRefEncoded(descriptor)) {
      if (id) {
        this.loadChildNode(id, depth, descriptor, key);
        this.validationErrors.delete(key);
        return id;
      } else if (!descriptor.optional) {
        this.validationErrors.set(
          key,
          new JazzError(void 0, "unavailable", [
            {
              code: "validationError",
              message: `The ref ${key} requested on ${map.constructor.name} is missing`,
              params: {},
              path: [key]
            }
          ])
        );
      }
    }
    return void 0;
  }
  loadCoListKey(list, key, depth) {
    const descriptor = list.getItemsDescriptor();
    if (!descriptor || !isRefEncoded(descriptor)) {
      return void 0;
    }
    const entries = list._raw.entries();
    const entry = entries[Number(key)];
    if (!entry) {
      return void 0;
    }
    const id = entry.value;
    if (id) {
      this.loadChildNode(id, depth, descriptor, key);
      this.validationErrors.delete(key);
      return id;
    } else if (!descriptor.optional) {
      this.validationErrors.set(
        key,
        new JazzError(void 0, "unavailable", [
          {
            code: "validationError",
            message: `The ref on position ${key} requested on ${list.constructor.name} is missing`,
            params: {},
            path: [key]
          }
        ])
      );
    }
    return void 0;
  }
  loadChildNode(id, query, descriptor, key) {
    if (this.childValues.has(id)) {
      return;
    }
    if (key && this.autoloadedKeys.has(key)) {
      this.autoloaded.add(id);
    }
    const skipInvalid = typeof query === "object" && query.$onError === null;
    if (skipInvalid) {
      if (key) {
        this.skipInvalidKeys.add(key);
      }
      this.skipInvalidKeys.add(id);
    }
    const resolve = typeof query === "object" && query !== null ? { ...query } : query;
    this.childValues.set(id, { type: "unloaded", id });
    const child = new _SubscriptionScope(
      this.node,
      resolve,
      id,
      descriptor
    );
    this.childNodes.set(id, child);
    child.setListener((value) => this.handleChildUpdate(id, value, key));
  }
  destroy() {
    this.subscription.unsubscribe();
    this.subscribers.clear();
    this.childNodes.forEach((child) => child.destroy());
  }
};

// src/subscribe/index.ts
function getSubscriptionScope(value) {
  const subscriptionScope = value._subscriptionScope;
  if (subscriptionScope) {
    return subscriptionScope;
  }
  const node = value._raw.core.node;
  const resolve = true;
  const id = value.id;
  const newSubscriptionScope = new SubscriptionScope(node, resolve, id, {
    ref: value.constructor,
    optional: false
  });
  Object.defineProperty(value, "_subscriptionScope", {
    value: subscriptionScope,
    writable: false,
    enumerable: false,
    configurable: false
  });
  return newSubscriptionScope;
}
function accessChildByKey(parent, childId, key) {
  const subscriptionScope = getSubscriptionScope(parent);
  if (!subscriptionScope.childValues.has(childId)) {
    subscriptionScope.subscribeToKey(key);
  }
  const value = subscriptionScope.childValues.get(childId);
  if (value?.type === "loaded") {
    return value.value;
  } else {
    return null;
  }
}
function accessChildById(parent, childId, schema) {
  const subscriptionScope = getSubscriptionScope(parent);
  subscriptionScope.subscribeToId(childId, schema);
  const value = subscriptionScope.childValues.get(childId);
  if (value?.type === "loaded") {
    return value.value;
  } else {
    return null;
  }
}

// src/implementation/createContext.ts
import {
  LocalNode as LocalNode2
} from "cojson";
async function randomSessionProvider(accountID, crypto) {
  return {
    sessionID: crypto.newRandomSessionID(accountID),
    sessionDone: () => {
    }
  };
}
async function createJazzContextFromExistingCredentials({
  credentials,
  peersToLoadFrom,
  crypto,
  AccountSchema: PropsAccountSchema,
  sessionProvider,
  onLogOut
}) {
  const { sessionID, sessionDone } = await sessionProvider(
    credentials.accountID,
    crypto
  );
  const CurrentAccountSchema = PropsAccountSchema ?? RegisteredSchemas["Account"];
  const AccountClass = anySchemaToCoSchema(CurrentAccountSchema);
  const node = await LocalNode2.withLoadedAccount({
    accountID: credentials.accountID,
    accountSecret: credentials.secret,
    sessionID,
    peersToLoadFrom,
    crypto,
    migration: async (rawAccount, _node, creationProps) => {
      const account2 = AccountClass.fromRaw(rawAccount);
      activeAccountContext.set(account2);
      await account2.applyMigration(creationProps);
    }
  });
  const account = AccountClass.fromNode(node);
  activeAccountContext.set(account);
  return {
    node,
    account,
    done: () => {
      node.gracefulShutdown();
      sessionDone();
    },
    logOut: async () => {
      node.gracefulShutdown();
      sessionDone();
      await onLogOut?.();
    }
  };
}
async function createJazzContextForNewAccount({
  creationProps,
  initialAgentSecret,
  peersToLoadFrom,
  crypto,
  AccountSchema: PropsAccountSchema,
  onLogOut
}) {
  const CurrentAccountSchema = PropsAccountSchema ?? RegisteredSchemas["Account"];
  const AccountClass = anySchemaToCoSchema(CurrentAccountSchema);
  const { node } = await LocalNode2.withNewlyCreatedAccount({
    creationProps,
    peersToLoadFrom,
    crypto,
    initialAgentSecret,
    migration: async (rawAccount, _node, creationProps2) => {
      const account2 = AccountClass.fromRaw(rawAccount);
      activeAccountContext.set(account2);
      await account2.applyMigration(creationProps2);
    }
  });
  const account = AccountClass.fromNode(node);
  activeAccountContext.set(account);
  return {
    node,
    account,
    done: () => {
      node.gracefulShutdown();
    },
    logOut: async () => {
      node.gracefulShutdown();
      await onLogOut?.();
    }
  };
}
async function createJazzContext(options) {
  const crypto = options.crypto;
  let context;
  const authSecretStorage = options.authSecretStorage;
  await authSecretStorage.migrate();
  const credentials = options.credentials ?? await authSecretStorage.get();
  if (credentials && !options.newAccountProps) {
    context = await createJazzContextFromExistingCredentials({
      credentials: {
        accountID: credentials.accountID,
        secret: credentials.accountSecret
      },
      peersToLoadFrom: options.peersToLoadFrom,
      crypto,
      AccountSchema: options.AccountSchema,
      sessionProvider: options.sessionProvider,
      onLogOut: () => {
        authSecretStorage.clearWithoutNotify();
      }
    });
  } else {
    const secretSeed = options.crypto.newRandomSecretSeed();
    const initialAgentSecret = options.newAccountProps?.secret ?? crypto.agentSecretFromSecretSeed(secretSeed);
    const creationProps = options.newAccountProps?.creationProps ?? {
      name: options.defaultProfileName ?? "Anonymous user"
    };
    context = await createJazzContextForNewAccount({
      creationProps,
      initialAgentSecret,
      peersToLoadFrom: options.peersToLoadFrom,
      crypto,
      AccountSchema: options.AccountSchema,
      onLogOut: async () => {
        await authSecretStorage.clearWithoutNotify();
      }
    });
    if (!options.newAccountProps) {
      await authSecretStorage.setWithoutNotify({
        accountID: context.account.id,
        secretSeed,
        accountSecret: context.node.getCurrentAgent().agentSecret,
        provider: "anonymous"
      });
    }
  }
  return {
    ...context,
    authSecretStorage
  };
}
function createAnonymousJazzContext({
  peersToLoadFrom,
  crypto
}) {
  const agentSecret = crypto.newRandomAgentSecret();
  const node = new LocalNode2(
    agentSecret,
    crypto.newRandomSessionID(crypto.getAgentID(agentSecret)),
    crypto
  );
  for (const peer of peersToLoadFrom) {
    node.syncManager.addPeer(peer);
  }
  activeAccountContext.setGuestMode();
  return {
    agent: new AnonymousJazzAgent(node),
    done: () => {
    },
    logOut: async () => {
    }
  };
}

// src/implementation/zodSchema/zodSchema.ts
function isZodObject(schema) {
  return schema.def?.type === "object";
}
function isZodArray(schema) {
  return schema.def?.type === "array";
}
function isZodCustom(schema) {
  return schema.def?.type === "custom";
}
function getDef(schema) {
  return schema.def;
}

// src/implementation/zodSchema/zodCo.ts
function enrichCoMapSchema(schema) {
  const baseCatchall = schema.catchall;
  const enrichedSchema = Object.assign(schema, {
    collaborative: true,
    create: (...args) => {
      return coSchema.create(...args);
    },
    load: (...args) => {
      return coSchema.load(...args);
    },
    subscribe: (...args) => {
      return coSchema.subscribe(...args);
    },
    findUnique: (...args) => {
      return coSchema.findUnique(...args);
    },
    catchall: (index) => {
      return enrichCoMapSchema(baseCatchall(index));
    },
    withHelpers: (helpers) => {
      return Object.assign(schema, helpers(schema));
    },
    withMigration: (migration) => {
      coSchema.prototype.migrate = migration;
      return enrichedSchema;
    },
    getCoSchema: () => {
      return coSchema;
    }
  });
  const coSchema = zodSchemaToCoSchema2(enrichedSchema);
  return enrichedSchema;
}
var coMapDefiner = (shape) => {
  const objectSchema = z.object(shape).meta({
    collaborative: true
  });
  return enrichCoMapSchema(objectSchema);
};
function enrichAccountSchema(schema) {
  const enrichedSchema = Object.assign(schema, {
    collaborative: true,
    builtin: "Account",
    create: (...args) => {
      return coSchema.create(...args);
    },
    createAs: (...args) => {
      return coSchema.createAs(...args);
    },
    getMe: (...args) => {
      return coSchema.getMe(...args);
    },
    load: (...args) => {
      return coSchema.load(...args);
    },
    subscribe: (...args) => {
      return coSchema.subscribe(...args);
    },
    withHelpers: (helpers) => {
      return Object.assign(schema, helpers(schema));
    },
    fromRaw: (...args) => {
      return coSchema.fromRaw(...args);
    },
    withMigration: (migration) => {
      coSchema.prototype.migrate = async function(creationProps) {
        await migration(this, creationProps);
      };
      return enrichedSchema;
    },
    getCoSchema: () => {
      return coSchema;
    }
  });
  const coSchema = zodSchemaToCoSchema2(enrichedSchema);
  return enrichedSchema;
}
var coAccountDefiner = (shape = {
  profile: coMapDefiner({
    name: z.string(),
    inbox: z.optional(z.string()),
    inboxInvite: z.optional(z.string())
  }),
  root: coMapDefiner({})
}) => {
  const objectSchema = z.object(shape).meta({
    collaborative: true
  });
  return enrichAccountSchema(objectSchema);
};
var coRecordDefiner = (_keyType, valueType) => {
  return coMapDefiner({}).catchall(valueType);
};
function enrichCoListSchema(schema) {
  const enrichedSchema = Object.assign(schema, {
    collaborative: true,
    create: (...args) => {
      return coSchema.create(...args);
    },
    load: (...args) => {
      return coSchema.load(...args);
    },
    subscribe: (...args) => {
      return coSchema.subscribe(...args);
    },
    withHelpers: (helpers) => {
      return Object.assign(schema, helpers(schema));
    },
    getCoSchema: () => {
      return coSchema;
    }
  });
  const coSchema = zodSchemaToCoSchema2(enrichedSchema);
  return enrichedSchema;
}
var coListDefiner = (element) => {
  const arraySchema = z.array(element).meta({
    collaborative: true
  });
  return enrichCoListSchema(arraySchema);
};
var coProfileDefiner = (shape = {}) => {
  const ehnancedShape = Object.assign(shape ?? {}, {
    name: z.string(),
    inbox: z.optional(z.string()),
    inboxInvite: z.optional(z.string())
  });
  return coMapDefiner(ehnancedShape);
};
function enrichCoFeedSchema(schema, element) {
  const enrichedSchema = Object.assign(schema, {
    collaborative: true,
    builtin: "CoFeed",
    element,
    create: (...args) => {
      return coSchema.create(...args);
    },
    load: (...args) => {
      return coSchema.load(...args);
    },
    subscribe: (...args) => {
      return coSchema.subscribe(...args);
    },
    withHelpers: (helpers) => {
      return Object.assign(schema, helpers(schema));
    },
    getCoSchema: () => {
      return coSchema;
    }
  });
  const coSchema = zodSchemaToCoSchema2(enrichedSchema);
  return enrichedSchema;
}
var coFeedDefiner = (element) => {
  return enrichCoFeedSchema(z.instanceof(CoFeed), element);
};
function enrichFileStreamSchema(schema) {
  const enrichedSchema = Object.assign(schema, {
    collaborative: true,
    builtin: "FileStream",
    create: (...args) => {
      return coSchema.create(...args);
    },
    createFromBlob: (...args) => {
      return coSchema.createFromBlob(...args);
    },
    load: (...args) => {
      return coSchema.load(...args);
    },
    loadAsBlob: (...args) => {
      return coSchema.loadAsBlob(...args);
    },
    subscribe: (...args) => {
      return coSchema.subscribe(...args);
    },
    getCoSchema: () => {
      return coSchema;
    }
  });
  const coSchema = zodSchemaToCoSchema2(enrichedSchema);
  return enrichedSchema;
}
var coFileStreamDefiner = () => {
  return enrichFileStreamSchema(z.instanceof(FileStream));
};
function enrichPlainTextSchema(schema) {
  const enrichedSchema = Object.assign(schema, {
    collaborative: true,
    builtin: "CoPlainText",
    create: (...args) => {
      return coSchema.create(...args);
    },
    load: (...args) => {
      return coSchema.load(...args);
    },
    subscribe: (...args) => {
      return coSchema.subscribe(...args);
    },
    fromRaw: (...args) => {
      return coSchema.fromRaw(...args);
    },
    getCoSchema: () => {
      return coSchema;
    }
  });
  const coSchema = zodSchemaToCoSchema2(enrichedSchema);
  return enrichedSchema;
}
var coPlainTextDefiner = () => {
  return enrichPlainTextSchema(z.instanceof(CoPlainText));
};
function enrichRichTextSchema(schema) {
  const enrichedSchema = Object.assign(schema, {
    collaborative: true,
    builtin: "CoRichText",
    create: (...args) => {
      return coSchema.create(...args);
    },
    load: (...args) => {
      return coSchema.load(...args);
    },
    subscribe: (...args) => {
      return coSchema.subscribe(...args);
    },
    getCoSchema: () => {
      return coSchema;
    }
  });
  const coSchema = zodSchemaToCoSchema2(enrichedSchema);
  return enrichedSchema;
}
var coRichTextDefiner = () => {
  return enrichRichTextSchema(z.instanceof(CoRichText));
};
var coImageDefiner = () => {
  return ImageDefinition;
};

// src/implementation/zodSchema/coExport.ts
var coExport_exports = {};
__export(coExport_exports, {
  account: () => coAccountDefiner,
  feed: () => coFeedDefiner,
  fileStream: () => coFileStreamDefiner,
  image: () => coImageDefiner,
  list: () => coListDefiner,
  map: () => coMapDefiner,
  plainText: () => coPlainTextDefiner,
  profile: () => coProfileDefiner,
  record: () => coRecordDefiner,
  richText: () => coRichTextDefiner
});

// src/implementation/zodSchema/unionUtils.ts
import { RawCoList } from "cojson";
function schemaUnionDiscriminatorFor(schema) {
  if (isUnionOfCoMapsDeeply(schema)) {
    if (!schema._zod.disc || schema._zod.disc.size == 0) {
      throw new Error(
        "z.union() of collaborative types is not supported, use z.discriminatedUnion() instead"
      );
    }
    const discriminator = schema._zod.def.discriminator;
    const field = schema._zod.disc.get(discriminator);
    if (!field) {
      throw new Error(
        "z.discriminatedUnion() of collaborative types with non-existent discriminator key is not supported"
      );
    }
    for (const value of field.values) {
      if (typeof value !== "string" && typeof value !== "number") {
        throw new Error(
          "z.discriminatedUnion() of collaborative types with non-string or non-number discriminator value is not supported"
        );
      }
    }
    const availableOptions = [];
    for (const option of schema._zod.def.options) {
      if (option._zod.def.type === "object") {
        availableOptions.push(option);
      } else if (option._zod.def.type === "union") {
        for (const subOption of option._zod.def.options) {
          if (subOption._zod.def.type === "object") {
            availableOptions.push(subOption);
          }
        }
      } else {
        throw new Error(
          "Unsupported zod type in z.discriminatedUnion() of collaborative types"
        );
      }
    }
    const determineSchema = (_raw) => {
      if (_raw instanceof RawCoList) {
        throw new Error(
          "z.discriminatedUnion() of collaborative types is not supported for CoLists"
        );
      }
      for (const option of availableOptions) {
        let match = true;
        for (const key of schema._zod.disc.keys()) {
          const discriminatorDef = option._zod.def.shape[key];
          const discriminatorValue = _raw.get(key);
          if (discriminatorValue && typeof discriminatorValue === "object") {
            throw new Error("Discriminator must be a primitive value");
          }
          if (!discriminatorDef) {
            if (key === discriminator) {
              match = false;
              break;
            } else {
              continue;
            }
          }
          if (discriminatorDef._zod.def.type !== "literal") {
            break;
          }
          const literalDef = discriminatorDef._zod.def;
          if (!Array.from(literalDef.values).includes(discriminatorValue)) {
            match = false;
            break;
          }
        }
        if (match) {
          return zodSchemaToCoSchema2(option);
        }
      }
      throw new Error(
        "z.discriminatedUnion() of collaborative types with no matching discriminator value found"
      );
    };
    return determineSchema;
  } else {
    throw new Error(
      "z.discriminatedUnion() of non-collaborative types is not supported"
    );
  }
}
function isUnionOfCoMapsDeeply(schema) {
  if (schema instanceof z.core.$ZodUnion) {
    return schema._zod.def.options.every(isCoMapOrUnionOfCoMapsDeeply);
  } else {
    return false;
  }
}
function isCoMapOrUnionOfCoMapsDeeply(schema) {
  if (schema instanceof z.core.$ZodObject && "collaborative" in schema && schema.collaborative) {
    return true;
  } else if (schema instanceof z.core.$ZodUnion) {
    return schema._zod.def.options.every(isCoMapOrUnionOfCoMapsDeeply);
  } else {
    return false;
  }
}
function isUnionOfPrimitivesDeeply(schema) {
  if (schema instanceof z.core.$ZodUnion) {
    return schema._zod.def.options.every(isUnionOfPrimitivesDeeply);
  } else {
    return !("collaborative" in schema);
  }
}

// src/implementation/zodSchema/runtimeConverters/zodFieldToCoFieldDef.ts
function zodFieldToCoFieldDef(schema) {
  if (isCoValueClass(schema)) {
    return coField.ref(schema);
  } else {
    if ("_zod" in schema) {
      if (schema._zod.def.type === "optional") {
        const inner = zodSchemaToCoSchemaOrKeepPrimitive(
          schema._zod.def.innerType
        );
        if (isCoValueClass(inner)) {
          return coField.ref(inner, { optional: true });
        } else {
          return zodFieldToCoFieldDef(inner);
        }
      } else if (schema._zod.def.type === "string") {
        return coField.string;
      } else if (schema._zod.def.type === "number") {
        return coField.number;
      } else if (schema._zod.def.type === "boolean") {
        return coField.boolean;
      } else if (schema._zod.def.type === "null") {
        return coField.null;
      } else if (schema._zod.def.type === "enum") {
        return coField.string;
      } else if (schema._zod.def.type === "readonly") {
        return zodFieldToCoFieldDef(
          schema.def.innerType
        );
      } else if (schema._zod.def.type === "date") {
        return coField.optional.Date;
      } else if (schema._zod.def.type === "template_literal") {
        return coField.string;
      } else if (schema._zod.def.type === "lazy") {
        return zodFieldToCoFieldDef(
          schema.unwrap()
        );
      } else if (schema._zod.def.type === "default" || schema._zod.def.type === "catch") {
        console.warn(
          "z.default()/z.catch() are not supported in collaborative schemas. They will be ignored."
        );
        return zodFieldToCoFieldDef(
          schema.def.innerType
        );
      } else if (schema._zod.def.type === "literal") {
        if (schema._zod.def.values.some(
          (literal2) => typeof literal2 === "undefined"
        )) {
          throw new Error("z.literal() with undefined is not supported");
        }
        if (schema._zod.def.values.some((literal2) => literal2 === null)) {
          throw new Error("z.literal() with null is not supported");
        }
        if (schema._zod.def.values.some((literal2) => typeof literal2 === "bigint")) {
          throw new Error("z.literal() with bigint is not supported");
        }
        return coField.literal(
          ...schema._zod.def.values
        );
      } else if (schema._zod.def.type === "object" || schema._zod.def.type === "array" || schema._zod.def.type === "tuple") {
        return coField.json();
      } else if (schema._zod.def.type === "custom") {
        if ("builtin" in schema) {
          return zodFieldToCoFieldDef(schema.builtin);
        } else {
          throw new Error(`Unsupported custom zod type`);
        }
      } else if (schema._zod.def.type === "union") {
        if (isUnionOfPrimitivesDeeply(schema)) {
          return coField.json();
        } else if (isUnionOfCoMapsDeeply(schema)) {
          return coField.ref(
            schemaUnionDiscriminatorFor(schema)
          );
        } else {
          throw new Error(
            "z.union()/z.discriminatedUnion() of mixed collaborative and non-collaborative types is not supported"
          );
        }
      } else {
        throw new Error(
          `Unsupported zod type: ${schema._zod?.def?.type || JSON.stringify(schema)}`
        );
      }
    } else {
      throw new Error(`Unsupported zod type: ${schema}`);
    }
  }
}

// src/implementation/zodSchema/runtimeConverters/zodSchemaToCoSchema.ts
var coSchemasForZodSchemas = /* @__PURE__ */ new Map();
function tryZodSchemaToCoSchema(schema) {
  if ("collaborative" in schema && schema.collaborative) {
    if (coSchemasForZodSchemas.has(schema)) {
      return coSchemasForZodSchemas.get(schema);
    }
    if (isZodObject(schema)) {
      const def = getDef(schema);
      const ClassToExtend = "builtin" in schema && schema.builtin === "Account" ? Account : CoMap;
      const coSchema = class ZCoMap extends ClassToExtend {
        constructor(options) {
          super(options);
          for (const [field, fieldType] of Object.entries(
            def.shape
          )) {
            this[field] = zodFieldToCoFieldDef(
              zodSchemaToCoSchemaOrKeepPrimitive(fieldType)
            );
          }
          if (def.catchall) {
            this[coField.items] = zodFieldToCoFieldDef(
              zodSchemaToCoSchemaOrKeepPrimitive(def.catchall)
            );
          }
        }
      };
      coSchemasForZodSchemas.set(schema, coSchema);
      return coSchema;
    } else if (isZodArray(schema)) {
      const def = getDef(schema);
      const coSchema = class ZCoList extends CoList {
        constructor(options) {
          super(options);
          this[coField.items] = zodFieldToCoFieldDef(
            zodSchemaToCoSchemaOrKeepPrimitive(def.element)
          );
        }
      };
      coSchemasForZodSchemas.set(schema, coSchema);
      return coSchema;
    } else if (isZodCustom(schema)) {
      if ("builtin" in schema) {
        if (schema.builtin === "CoFeed" && "element" in schema) {
          return CoFeed.Of(
            zodFieldToCoFieldDef(
              zodSchemaToCoSchemaOrKeepPrimitive(
                schema.element
              )
            )
          );
        } else if (schema.builtin === "FileStream") {
          return FileStream;
        } else if (schema.builtin === "CoPlainText") {
          return CoPlainText;
        } else if (schema.builtin === "CoRichText") {
          return CoRichText;
        } else {
          throw new Error(`Unsupported builtin type: ${schema.builtin}`);
        }
      } else {
        throw new Error(`Unsupported custom zod type`);
      }
    } else {
      throw new Error(
        `Unsupported zod CoValue type for top-level schema: ${schema._zod?.def?.type || JSON.stringify(schema, void 0, 2)}`
      );
    }
  } else if (schema instanceof z.core.$ZodDiscriminatedUnion) {
    if (isUnionOfCoMapsDeeply(schema)) {
      return SchemaUnion.Of(
        schemaUnionDiscriminatorFor(schema)
      );
    } else {
      throw new Error(
        "z.discriminatedUnion() of non-collaborative types is not supported as a top-level schema"
      );
    }
  } else {
    return null;
  }
}
function zodSchemaToCoSchema2(schema) {
  const coSchema = tryZodSchemaToCoSchema(schema);
  if (!coSchema) {
    throw new Error(
      `Unsupported zod type: ${schema._zod?.def?.type || JSON.stringify(schema)}`
    );
  }
  return coSchema;
}
function anySchemaToCoSchema(schema) {
  if (isCoValueClass(schema)) {
    return schema;
  } else if ("getCoSchema" in schema) {
    return schema.getCoSchema();
  } else if ("def" in schema) {
    const coSchema = tryZodSchemaToCoSchema(schema);
    if (!coSchema) {
      throw new Error(
        `Unsupported zod type: ${schema.def?.type || JSON.stringify(schema)}`
      );
    }
    return coSchema;
  }
  throw new Error(`Unsupported schema: ${JSON.stringify(schema)}`);
}
function zodSchemaToCoSchemaOrKeepPrimitive(schema) {
  const coSchema = tryZodSchemaToCoSchema(schema);
  if (!coSchema) {
    return schema;
  }
  return coSchema;
}

// src/coValues/extensions/imageDef.ts
var ImageDefinitionBase = coMapDefiner({
  originalSize: z.tuple([z.number(), z.number()]),
  placeholderDataURL: z.string().optional()
}).catchall(coFileStreamDefiner());
var ImageDefinition = ImageDefinitionBase.withHelpers((Self) => ({
  highestResAvailable(imageDef, options) {
    const resolutions = Object.keys(imageDef).filter(
      (key) => key.match(/^\d+x\d+$/)
    );
    let maxWidth = options?.maxWidth;
    if (options?.targetWidth) {
      const targetWidth = options.targetWidth;
      const widths = resolutions.map((res) => Number(res.split("x")[0]));
      maxWidth = Math.min(...widths.filter((w) => w >= targetWidth));
    }
    const validResolutions = resolutions.filter(
      (key) => maxWidth === void 0 || Number(key.split("x")[0]) <= maxWidth
    );
    validResolutions.sort((a, b) => {
      const aWidth = Number(a.split("x")[0]);
      const bWidth = Number(b.split("x")[0]);
      return aWidth - bWidth;
    });
    let highestAvailableResolution;
    for (const resolution of validResolutions) {
      if (imageDef[resolution] && imageDef[resolution]?.getChunks()) {
        highestAvailableResolution = resolution;
      }
    }
    return highestAvailableResolution && {
      res: highestAvailableResolution,
      stream: imageDef[highestAvailableResolution]
    };
  }
}));

// src/implementation/ContextManager.ts
import { cojsonInternals as cojsonInternals4 } from "cojson";
import { PureJSCrypto } from "cojson/dist/crypto/PureJSCrypto";

// src/auth/KvStoreContext.ts
var KvStoreContext = class _KvStoreContext {
  constructor() {
    this.storageInstance = null;
  }
  static getInstance() {
    if (!_KvStoreContext.instance) {
      _KvStoreContext.instance = new _KvStoreContext();
    }
    return _KvStoreContext.instance;
  }
  isInitialized() {
    return this.storageInstance !== null;
  }
  initialize(store) {
    if (!this.storageInstance) {
      this.storageInstance = store;
    }
  }
  getStorage() {
    if (!this.storageInstance) {
      throw new Error("Storage instance is not initialized.");
    }
    return this.storageInstance;
  }
};
var KvStoreContext_default = KvStoreContext;

// src/auth/AuthSecretStorage.ts
var STORAGE_KEY = "jazz-logged-in-secret";
var AuthSecretStorage = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.isAuthenticated = false;
  }
  async migrate() {
    const kvStore = KvStoreContext_default.getInstance().getStorage();
    if (!await kvStore.get(STORAGE_KEY)) {
      const demoAuthSecret = await kvStore.get("demo-auth-logged-in-secret");
      if (demoAuthSecret) {
        const parsed = JSON.parse(demoAuthSecret);
        await kvStore.set(
          STORAGE_KEY,
          JSON.stringify({
            accountID: parsed.accountID,
            accountSecret: parsed.accountSecret,
            provider: "demo"
          })
        );
        await kvStore.delete("demo-auth-logged-in-secret");
      }
      const clerkAuthSecret = await kvStore.get("jazz-clerk-auth");
      if (clerkAuthSecret) {
        const parsed = JSON.parse(clerkAuthSecret);
        await kvStore.set(
          STORAGE_KEY,
          JSON.stringify({
            accountID: parsed.accountID,
            accountSecret: parsed.secret,
            provider: "clerk"
          })
        );
        await kvStore.delete("jazz-clerk-auth");
      }
    }
    const value = await kvStore.get(STORAGE_KEY);
    if (value) {
      const parsed = JSON.parse(value);
      if ("secret" in parsed) {
        await kvStore.set(
          STORAGE_KEY,
          JSON.stringify({
            accountID: parsed.accountID,
            secretSeed: parsed.secretSeed,
            accountSecret: parsed.secret,
            provider: parsed.provider
          })
        );
      }
    }
  }
  async get() {
    const kvStore = KvStoreContext_default.getInstance().getStorage();
    const data = await kvStore.get(STORAGE_KEY);
    if (!data) return null;
    const parsed = JSON.parse(data);
    if (!parsed.accountID || !parsed.accountSecret) {
      throw new Error("Invalid auth secret storage data");
    }
    return {
      accountID: parsed.accountID,
      secretSeed: parsed.secretSeed ? new Uint8Array(parsed.secretSeed) : void 0,
      accountSecret: parsed.accountSecret,
      provider: parsed.provider
    };
  }
  async setWithoutNotify(payload) {
    const kvStore = KvStoreContext_default.getInstance().getStorage();
    await kvStore.set(
      STORAGE_KEY,
      JSON.stringify({
        accountID: payload.accountID,
        secretSeed: payload.secretSeed ? Array.from(payload.secretSeed) : void 0,
        accountSecret: payload.accountSecret,
        provider: payload.provider
      })
    );
  }
  async set(payload) {
    this.setWithoutNotify(payload);
    this.emitUpdate(payload);
  }
  getIsAuthenticated(data) {
    if (!data) return false;
    return data.provider !== "anonymous";
  }
  onUpdate(handler) {
    this.listeners.add(handler);
    return () => {
      this.listeners.delete(handler);
    };
  }
  emitUpdate(data) {
    const isAuthenticated = this.getIsAuthenticated(data);
    if (this.isAuthenticated === isAuthenticated) return;
    this.isAuthenticated = isAuthenticated;
    for (const listener of this.listeners) {
      listener(this.isAuthenticated);
    }
  }
  async clearWithoutNotify() {
    const kvStore = KvStoreContext_default.getInstance().getStorage();
    await kvStore.delete(STORAGE_KEY);
  }
  async clear() {
    await this.clearWithoutNotify();
    this.emitUpdate(null);
  }
};

// src/auth/InMemoryKVStore.ts
var InMemoryKVStore = class {
  constructor() {
    this.store = {};
  }
  async get(key) {
    const data = this.store[key];
    if (!data) return null;
    return data;
  }
  async set(key, value) {
    this.store[key] = value;
  }
  async delete(key) {
    delete this.store[key];
  }
  async clearAll() {
    this.store = {};
  }
};

// src/implementation/ContextManager.ts
function getAnonymousFallback() {
  const context = createAnonymousJazzContext({
    peersToLoadFrom: [],
    crypto: new PureJSCrypto()
  });
  return {
    guest: context.agent,
    node: context.agent.node,
    done: () => {
    },
    logOut: async () => {
    },
    isAuthenticated: false,
    authenticate: async () => {
    },
    register: async () => {
      throw new Error("Not implemented");
    }
  };
}
var JazzContextManager = class {
  constructor(opts) {
    this.authSecretStorage = new AuthSecretStorage();
    this.keepContextOpen = false;
    this.logOut = async () => {
      if (!this.context || !this.props) {
        return;
      }
      await this.props.onLogOut?.();
      if (this.props.logOutReplacement) {
        await this.props.logOutReplacement();
      } else {
        await this.context.logOut();
        return this.createContext(this.props);
      }
    };
    this.done = () => {
      if (!this.context) {
        return;
      }
      this.context.done();
    };
    this.shouldMigrateAnonymousAccount = async () => {
      if (!this.props?.onAnonymousAccountDiscarded) {
        return false;
      }
      const prevCredentials = await this.authSecretStorage.get();
      const wasAnonymous = this.authSecretStorage.getIsAuthenticated(prevCredentials) === false;
      return wasAnonymous;
    };
    /**
     * Authenticates the user with the given credentials
     */
    this.authenticate = async (credentials) => {
      if (!this.props) {
        throw new Error("Props required");
      }
      const prevContext = this.context;
      const migratingAnonymousAccount = await this.shouldMigrateAnonymousAccount();
      this.keepContextOpen = migratingAnonymousAccount;
      await this.createContext(this.props, { credentials }).finally(() => {
        this.keepContextOpen = false;
      });
      if (migratingAnonymousAccount) {
        await this.handleAnonymousAccountMigration(prevContext);
      }
    };
    this.register = async (accountSecret, creationProps) => {
      if (!this.props) {
        throw new Error("Props required");
      }
      const prevContext = this.context;
      const migratingAnonymousAccount = await this.shouldMigrateAnonymousAccount();
      this.keepContextOpen = migratingAnonymousAccount;
      await this.createContext(this.props, {
        newAccountProps: {
          secret: accountSecret,
          creationProps
        }
      }).finally(() => {
        this.keepContextOpen = false;
      });
      if (migratingAnonymousAccount) {
        await this.handleAnonymousAccountMigration(prevContext);
      }
      if (this.context && "me" in this.context) {
        return this.context.me.id;
      }
      throw new Error("The registration hasn't created a new account");
    };
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = (callback) => {
      this.listeners.add(callback);
      return () => {
        this.listeners.delete(callback);
      };
    };
    KvStoreContext.getInstance().initialize(this.getKvStore());
    if (opts?.useAnonymousFallback) {
      this.value = getAnonymousFallback();
    }
  }
  getKvStore() {
    return new InMemoryKVStore();
  }
  async createContext(props, authProps) {
    this.props = props;
    const { promise, resolve } = createResolvablePromise();
    const prevPromise = this.contextPromise;
    this.contextPromise = promise;
    await prevPromise;
    try {
      const result = await this.getNewContext(props, authProps);
      await this.updateContext(props, result, authProps);
      resolve();
    } catch (error) {
      resolve();
      throw error;
    }
  }
  async getNewContext(props, authProps) {
    props;
    authProps;
    throw new Error("Not implemented");
  }
  async updateContext(props, context, authProps) {
    if (!this.keepContextOpen) {
      this.context?.done();
    }
    this.context = context;
    this.props = props;
    this.value = {
      ...context,
      node: context.node,
      authenticate: this.authenticate,
      register: this.register,
      logOut: this.logOut
    };
    if (authProps?.credentials) {
      this.authSecretStorage.emitUpdate(authProps.credentials);
    } else {
      this.authSecretStorage.emitUpdate(await this.authSecretStorage.get());
    }
    this.notify();
  }
  propsChanged(props) {
    props;
    throw new Error("Not implemented");
  }
  getCurrentValue() {
    return this.value;
  }
  setCurrentValue(value) {
    this.value = value;
  }
  getAuthSecretStorage() {
    return this.authSecretStorage;
  }
  async handleAnonymousAccountMigration(prevContext) {
    if (!this.props) {
      throw new Error("Props required");
    }
    const currentContext = this.context;
    if (prevContext && currentContext && "me" in prevContext && "me" in currentContext) {
      const [prevAccountAsPeer, currentAccountAsPeer] = cojsonInternals4.connectedPeers(
        prevContext.me.id,
        currentContext.me.id,
        {
          peer1role: "client",
          peer2role: "server"
        }
      );
      prevContext.node.syncManager.addPeer(currentAccountAsPeer);
      currentContext.node.syncManager.addPeer(prevAccountAsPeer);
      try {
        await this.props.onAnonymousAccountDiscarded?.(prevContext.me);
        await prevContext.me.waitForAllCoValuesSync();
      } catch (error) {
        console.error("Error onAnonymousAccountDiscarded", error);
      }
      prevAccountAsPeer.outgoing.close();
      currentAccountAsPeer.outgoing.close();
    }
    prevContext?.done();
  }
  notify() {
    for (const listener of this.listeners) {
      listener();
    }
  }
};
function createResolvablePromise() {
  let resolve;
  const promise = new Promise((res) => {
    resolve = res;
  });
  return { promise, resolve };
}

// src/implementation/devtoolsFormatters.ts
globalThis.devtoolsFormatters = [
  {
    header: (object2) => {
      if (object2._type === "CoMap") {
        return ["div", {}, ["span", {}, object2.constructor.name]];
      } else if (object2._type === "CoList") {
        return [
          "div",
          {},
          ["span", {}, object2.constructor.name + "(" + object2.length + ") "]
        ];
      } else if (object2._type === "Account") {
        return [
          "div",
          {},
          [
            "span",
            {},
            object2.constructor.name + "(" + object2._refs.profile.value?.name + (object2.isMe ? " ME" : "") + ")"
          ]
        ];
      } else {
        return null;
      }
    },
    hasBody: function() {
      return true;
    },
    body: function(object2) {
      if (object2._type === "CoMap" || object2._type === "Account") {
        return [
          "div",
          { style: "margin-left: 15px" },
          ["div", "id: ", ["object", { object: object2.id }]],
          ...Object.entries(object2).map(([k, v]) => [
            "div",
            { style: "white-space: nowrap;" },
            ["span", { style: "font-weight: bold; opacity: 0.6" }, k, ": "],
            ["object", { object: v }],
            ...typeof object2._schema[k] === "function" ? v === null ? [
              [
                "span",
                { style: "opacity: 0.5" },
                ` (pending ${object2._schema[k].name} `,
                ["object", { object: object2._refs[k] }],
                ")"
              ]
            ] : [] : []
          ])
        ];
      } else if (object2._type === "CoList") {
        return [
          "div",
          { style: "margin-left: 15px" },
          ["div", "id: ", ["object", { object: object2.id }]],
          ...object2.map((v, i) => [
            "div",
            { style: "white-space: nowrap;" },
            ["span", { style: "font-weight: bold; opacity: 0.6" }, i, ": "],
            ["object", { object: v }],
            ...typeof object2._schema[ItemsSym] === "function" ? v === null ? [
              [
                "span",
                { style: "opacity: 0.5" },
                ` (pending ${object2._schema[ItemsSym].name} `,
                ["object", { object: object2._refs[i] }],
                ")"
              ]
            ] : [] : []
          ])
        ];
      }
    }
  }
];

// src/coValues/interfaces.ts
function isCoValueClass(value) {
  return typeof value === "function" && value.fromRaw !== void 0;
}
function loadCoValueWithoutMe(cls, id, options) {
  return loadCoValue(cls, id, {
    ...options,
    loadAs: options?.loadAs ?? activeAccountContext.get()
  });
}
function loadCoValue(cls, id, options) {
  return new Promise((resolve) => {
    subscribeToCoValue(
      cls,
      id,
      {
        resolve: options.resolve,
        loadAs: options.loadAs,
        syncResolution: true,
        onUnavailable: () => {
          resolve(null);
        },
        onUnauthorized: () => {
          resolve(null);
        }
      },
      (value, unsubscribe) => {
        resolve(value);
        unsubscribe();
      }
    );
  });
}
async function ensureCoValueLoaded(existing, options) {
  const response = await loadCoValue(
    existing.constructor,
    existing.id,
    {
      loadAs: existing._loadedAs,
      resolve: options?.resolve
    }
  );
  if (!response) {
    throw new Error("Failed to deeply load CoValue " + existing.id);
  }
  return response;
}
function parseSubscribeRestArgs(args) {
  if (args.length === 2) {
    if (typeof args[0] === "object" && args[0] && typeof args[1] === "function") {
      return {
        options: {
          resolve: args[0].resolve,
          loadAs: args[0].loadAs,
          onUnauthorized: args[0].onUnauthorized,
          onUnavailable: args[0].onUnavailable
        },
        listener: args[1]
      };
    } else {
      throw new Error("Invalid arguments");
    }
  } else {
    if (typeof args[0] === "function") {
      return { options: {}, listener: args[0] };
    } else {
      throw new Error("Invalid arguments");
    }
  }
}
function subscribeToCoValueWithoutMe(cls, id, options, listener) {
  return subscribeToCoValue(
    cls,
    id,
    {
      ...options,
      loadAs: options.loadAs ?? activeAccountContext.get()
    },
    listener
  );
}
function subscribeToCoValue(cls, id, options, listener) {
  const loadAs = options.loadAs ?? activeAccountContext.get();
  const node = "node" in loadAs ? loadAs.node : loadAs._raw.core.node;
  const resolve = options.resolve ?? true;
  let unsubscribed = false;
  const rootNode = new SubscriptionScope(node, resolve, id, {
    ref: cls,
    optional: false
  });
  const handleUpdate = (value) => {
    if (unsubscribed) return;
    if (value.type === "unavailable") {
      options.onUnavailable?.();
      console.error(value.toString());
    } else if (value.type === "unauthorized") {
      options.onUnauthorized?.();
      console.error(value.toString());
    } else if (value.type === "loaded") {
      listener(value.value, unsubscribe);
    }
  };
  let shouldDefer = !options.syncResolution;
  rootNode.setListener((value) => {
    if (shouldDefer) {
      shouldDefer = false;
      Promise.resolve().then(() => {
        handleUpdate(value);
      });
    } else {
      handleUpdate(value);
    }
  });
  function unsubscribe() {
    unsubscribed = true;
    rootNode.destroy();
  }
  return unsubscribe;
}
function createCoValueObservable(initialValue = void 0) {
  let currentValue = initialValue;
  let subscriberCount = 0;
  function subscribe(cls, id, options, listener) {
    subscriberCount++;
    const unsubscribe = subscribeToCoValue(
      anySchemaToCoSchema(cls),
      id,
      {
        loadAs: options.loadAs,
        resolve: options.resolve,
        onUnavailable: () => {
          currentValue = null;
          options.onUnavailable?.();
        },
        onUnauthorized: () => {
          currentValue = null;
          options.onUnauthorized?.();
        },
        syncResolution: options.syncResolution
      },
      (value) => {
        currentValue = value;
        listener();
      }
    );
    return () => {
      unsubscribe();
      subscriberCount--;
      if (subscriberCount === 0) {
        currentValue = void 0;
      }
    };
  }
  const observable = {
    getCurrentValue: () => currentValue,
    subscribe
  };
  return observable;
}
function subscribeToExistingCoValue(existing, options, listener) {
  return subscribeToCoValue(
    existing.constructor,
    existing.id,
    {
      loadAs: existing._loadedAs,
      resolve: options?.resolve,
      onUnavailable: options?.onUnavailable,
      onUnauthorized: options?.onUnauthorized
    },
    listener
  );
}
function isAccountInstance(instance) {
  if (typeof instance !== "object" || instance === null) {
    return false;
  }
  return "_type" in instance && instance._type === "Account";
}
function parseCoValueCreateOptions(options) {
  const Group3 = RegisteredSchemas["Group"];
  if (!options) {
    return { owner: Group3.create(), uniqueness: void 0 };
  }
  if ("_type" in options) {
    if (options._type === "Account" || options._type === "Group") {
      return { owner: options, uniqueness: void 0 };
    }
  }
  const uniqueness = options.unique ? { uniqueness: options.unique } : void 0;
  return {
    owner: options.owner ?? Group3.create(),
    uniqueness
  };
}
function parseGroupCreateOptions(options) {
  if (!options) {
    return { owner: activeAccountContext.get() };
  }
  return "_type" in options && isAccountInstance(options) ? { owner: options } : { owner: options.owner ?? activeAccountContext.get() };
}

export {
  zodReExport_exports,
  loadCoValue,
  subscribeToCoValue,
  createCoValueObservable,
  CoValueBase,
  CoMap,
  CoList,
  CoFeed,
  FileStream,
  Account,
  isControlledAccount,
  Group,
  Profile,
  Inbox,
  InboxSender,
  CoPlainText,
  CoRichText,
  SchemaUnion,
  AnonymousJazzAgent,
  activeAccountContext,
  Encoders,
  coField,
  SubscriptionScope,
  randomSessionProvider,
  createJazzContextFromExistingCredentials,
  createJazzContextForNewAccount,
  createJazzContext,
  createAnonymousJazzContext,
  coExport_exports,
  zodSchemaToCoSchema2 as zodSchemaToCoSchema,
  anySchemaToCoSchema,
  ImageDefinition,
  KvStoreContext,
  AuthSecretStorage,
  InMemoryKVStore,
  JazzContextManager
};
/* istanbul ignore file -- @preserve */
//# sourceMappingURL=chunk-AUQIX4E7.js.map