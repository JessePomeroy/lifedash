import { logger } from "cojson";
export function getErrorMessage(error) {
    return error instanceof Error ? error.message : "Unknown error";
}
export class SQLiteClientAsync {
    constructor(db) {
        this.db = db;
    }
    async getCoValue(coValueId) {
        const coValueRow = await this.db.get("SELECT * FROM coValues WHERE id = ?", [coValueId]);
        if (!coValueRow)
            return;
        try {
            const parsedHeader = (coValueRow?.header &&
                JSON.parse(coValueRow.header));
            return {
                ...coValueRow,
                header: parsedHeader,
            };
        }
        catch (e) {
            const headerValue = coValueRow?.header ?? "";
            logger.warn(`Invalid JSON in header: ${headerValue}`, {
                id: coValueId,
                err: e,
            });
            return;
        }
    }
    async getCoValueSessions(coValueRowId) {
        return this.db.query("SELECT * FROM sessions WHERE coValue = ?", [coValueRowId]);
    }
    async getSingleCoValueSession(coValueRowId, sessionID) {
        return this.db.get("SELECT * FROM sessions WHERE coValue = ? AND sessionID = ?", [coValueRowId, sessionID]);
    }
    async getNewTransactionInSession(sessionRowId, fromIdx, toIdx) {
        const txs = await this.db.query("SELECT * FROM transactions WHERE ses = ? AND idx >= ? AND idx <= ?", [sessionRowId, fromIdx, toIdx]);
        try {
            return txs.map((transactionRow) => ({
                ...transactionRow,
                tx: JSON.parse(transactionRow.tx),
            }));
        }
        catch (e) {
            logger.warn("Invalid JSON in transaction", { err: e });
            return [];
        }
    }
    async getSignatures(sessionRowId, firstNewTxIdx) {
        return this.db.query("SELECT * FROM signatureAfter WHERE ses = ? AND idx >= ?", [sessionRowId, firstNewTxIdx]);
    }
    async addCoValue(msg) {
        const result = await this.db.get("INSERT INTO coValues (id, header) VALUES (?, ?) RETURNING rowID", [msg.id, JSON.stringify(msg.header)]);
        if (!result) {
            throw new Error("Failed to add coValue");
        }
        return result.rowID;
    }
    async addSessionUpdate({ sessionUpdate, }) {
        const result = await this.db.get(`INSERT INTO sessions (coValue, sessionID, lastIdx, lastSignature, bytesSinceLastSignature) VALUES (?, ?, ?, ?, ?)
                            ON CONFLICT(coValue, sessionID) DO UPDATE SET lastIdx=excluded.lastIdx, lastSignature=excluded.lastSignature, bytesSinceLastSignature=excluded.bytesSinceLastSignature
                            RETURNING rowID`, [
            sessionUpdate.coValue,
            sessionUpdate.sessionID,
            sessionUpdate.lastIdx,
            sessionUpdate.lastSignature,
            sessionUpdate.bytesSinceLastSignature,
        ]);
        if (!result) {
            throw new Error("Failed to add session update");
        }
        return result.rowID;
    }
    addTransaction(sessionRowID, nextIdx, newTransaction) {
        this.db.run("INSERT INTO transactions (ses, idx, tx) VALUES (?, ?, ?)", [
            sessionRowID,
            nextIdx,
            JSON.stringify(newTransaction),
        ]);
    }
    async addSignatureAfter({ sessionRowID, idx, signature, }) {
        this.db.run("INSERT INTO signatureAfter (ses, idx, signature) VALUES (?, ?, ?)", [sessionRowID, idx, signature]);
    }
    async transaction(operationsCallback) {
        return this.db.transaction(operationsCallback);
    }
}
//# sourceMappingURL=client.js.map