import { describe, expect, it } from "vitest";
import { getDependedOnCoValues } from "../syncUtils.js";
function getMockedSessionID(accountId) {
    return `${accountId ?? getMockedCoValueId()}_session_z${Math.random().toString(36).substring(2, 15)}`;
}
function getMockedCoValueId() {
    return `co_z${Math.random().toString(36).substring(2, 15)}`;
}
function generateNewContentMessage(privacy, changes, accountId) {
    return {
        action: "content",
        id: getMockedCoValueId(),
        new: {
            [getMockedSessionID(accountId)]: {
                after: 0,
                lastSignature: "signature_z123",
                newTransactions: [
                    {
                        privacy,
                        madeAt: 0,
                        changes: JSON.stringify(changes),
                    },
                ],
            },
        },
        priority: 0,
    };
}
describe("getDependedOnCoValues", () => {
    it("should return dependencies for group ruleset", () => {
        const coValueRow = {
            id: "co_test",
            header: {
                ruleset: {
                    type: "group",
                },
            },
        };
        const accountId = getMockedCoValueId();
        const result = getDependedOnCoValues(coValueRow.header, generateNewContentMessage("trusting", [
            { op: "set", key: "co_zabc123", value: "test" },
            { op: "set", key: "parent_co_zdef456", value: "test" },
            { op: "set", key: "normal_key", value: "test" },
        ], accountId));
        expect(result).toEqual(new Set([accountId, "co_zabc123", "co_zdef456"]));
    });
    it("should not throw on malformed JSON", () => {
        const coValueRow = {
            id: "co_test",
            header: {
                ruleset: {
                    type: "group",
                },
            },
        };
        const accountId = getMockedCoValueId();
        const message = generateNewContentMessage("trusting", [{ op: "set", key: "co_zabc123", value: "test" }], accountId);
        message.new["invalid_session"] = {
            after: 0,
            lastSignature: "signature_z123",
            newTransactions: [
                {
                    privacy: "trusting",
                    madeAt: 0,
                    changes: "}{-:)",
                },
            ],
        };
        const result = getDependedOnCoValues(coValueRow.header, message);
        expect(result).toEqual(new Set([accountId, "co_zabc123"]));
    });
    it("should return dependencies for ownedByGroup ruleset", () => {
        const groupId = getMockedCoValueId();
        const coValueRow = {
            id: "co_owner",
            header: {
                ruleset: {
                    type: "ownedByGroup",
                    group: groupId,
                },
            },
        };
        const accountId = getMockedCoValueId();
        const message = generateNewContentMessage("trusting", [
            { op: "set", key: "co_zabc123", value: "test" },
            { op: "set", key: "parent_co_zdef456", value: "test" },
            { op: "set", key: "normal_key", value: "test" },
        ], accountId);
        message.new["invalid_session"] = {
            after: 0,
            lastSignature: "signature_z123",
            newTransactions: [],
        };
        const result = getDependedOnCoValues(coValueRow.header, message);
        expect(result).toEqual(new Set([groupId, accountId]));
    });
    it("should return empty array for other ruleset types", () => {
        const coValueRow = {
            id: "co_test",
            header: {
                ruleset: {
                    type: "other",
                },
            },
        };
        const accountId = getMockedCoValueId();
        const result = getDependedOnCoValues(coValueRow.header, generateNewContentMessage("trusting", [
            { op: "set", key: "co_zabc123", value: "test" },
            { op: "set", key: "parent_co_zdef456", value: "test" },
            { op: "set", key: "normal_key", value: "test" },
        ], accountId));
        expect(result).toEqual(new Set([accountId]));
    });
    it("should ignore non-trusting transactions in group ruleset", () => {
        const coValueRow = {
            id: "co_test",
            header: {
                ruleset: {
                    type: "group",
                },
            },
        };
        const accountId = getMockedCoValueId();
        const result = getDependedOnCoValues(coValueRow.header, generateNewContentMessage("private", [{ op: "set", key: "co_zabc123", value: "test" }], accountId));
        expect(result).toEqual(new Set([accountId]));
    });
});
//# sourceMappingURL=getDependedOnCoValues.test.js.map