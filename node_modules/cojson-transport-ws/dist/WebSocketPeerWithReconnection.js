import { logger } from "cojson";
import { createWebSocketPeer } from "./createWebSocketPeer.js";
export class WebSocketPeerWithReconnection {
    constructor(opts) {
        this.enabled = false;
        this.closed = true;
        this.currentPeer = undefined;
        this.unsubscribeNetworkChange = undefined;
        this.reconnectionAttempts = 0;
        this.onConnectionChangeListeners = new Set();
        this.waitUntilConnected = async () => {
            if (this.closed) {
                return new Promise((resolve) => {
                    const listener = (connected) => {
                        if (connected) {
                            resolve();
                            this.onConnectionChangeListeners.delete(listener);
                        }
                    };
                    this.onConnectionChangeListeners.add(listener);
                });
            }
        };
        this.subscribe = (listener) => {
            this.onConnectionChangeListeners.add(listener);
            listener(!this.closed);
        };
        this.unsubscribe = (listener) => {
            this.onConnectionChangeListeners.delete(listener);
        };
        this.startConnection = async () => {
            if (!this.enabled)
                return;
            if (this.currentPeer) {
                this.removePeer(this.currentPeer);
                this.currentPeer.outgoing.close();
                this.reconnectionAttempts++;
                const timeout = this.reconnectionTimeout * this.reconnectionAttempts;
                logger.debug(`Websocket disconnected, trying to reconnect in ${timeout}ms`);
                await this.waitForOnline(timeout);
            }
            if (!this.enabled)
                return;
            this.currentPeer = createWebSocketPeer({
                websocket: new this.WebSocketConstructor(this.peer),
                pingTimeout: this.pingTimeout,
                id: this.peer,
                role: "server",
                onClose: () => {
                    this.closed = true;
                    for (const listener of this.onConnectionChangeListeners) {
                        listener(false);
                    }
                    this.startConnection();
                },
                onSuccess: () => {
                    this.closed = false;
                    for (const listener of this.onConnectionChangeListeners) {
                        listener(true);
                    }
                    logger.debug("Websocket connection successful");
                    this.reconnectionAttempts = 0;
                },
            });
            this.addPeer(this.currentPeer);
        };
        this.enable = () => {
            if (this.enabled)
                return;
            this.enabled = true;
            this.startConnection();
        };
        this.disable = () => {
            if (!this.enabled)
                return;
            this.enabled = false;
            this.reconnectionAttempts = 0;
            this.unsubscribeNetworkChange?.();
            this.unsubscribeNetworkChange = undefined;
            if (this.currentPeer) {
                this.removePeer(this.currentPeer);
                this.currentPeer.outgoing.close();
                this.currentPeer = undefined;
            }
        };
        this.peer = opts.peer;
        this.reconnectionTimeout = opts.reconnectionTimeout || 500;
        this.addPeer = opts.addPeer;
        this.removePeer = opts.removePeer;
        this.WebSocketConstructor = opts.WebSocketConstructor || WebSocket;
        this.pingTimeout = opts.pingTimeout || 10000;
    }
    // Basic implementation for environments that don't support network change events (e.g. Node.js)
    // Needs to be extended to handle platform specific APIs
    onNetworkChange(callback) {
        callback;
        return () => { };
    }
    waitForOnline(timeout) {
        return new Promise((resolve) => {
            const unsubscribeNetworkChange = this.onNetworkChange((connected) => {
                if (connected) {
                    handleTimeoutOrOnline();
                }
            });
            function handleTimeoutOrOnline() {
                clearTimeout(timer);
                unsubscribeNetworkChange?.();
                resolve();
            }
            const timer = setTimeout(handleTimeoutOrOnline, timeout);
        });
    }
}
//# sourceMappingURL=WebSocketPeerWithReconnection.js.map