import { err, ok } from "neverthrow";
import { StreamingHash, } from "../crypto/crypto.js";
import { getPriorityFromHeader } from "../priority.js";
import { MAX_RECOMMENDED_TX_SIZE, } from "./coValueCore.js";
export class VerifiedState {
    constructor(id, crypto, header, sessions) {
        this.id = id;
        this.crypto = crypto;
        this.header = header;
        this.sessions = sessions;
    }
    clone() {
        // do a deep clone, including the sessions
        const clonedSessions = new Map();
        for (let [sessionID, sessionLog] of this.sessions) {
            clonedSessions.set(sessionID, {
                lastSignature: sessionLog.lastSignature,
                lastHash: sessionLog.lastHash,
                streamingHash: sessionLog.streamingHash.clone(),
                signatureAfter: { ...sessionLog.signatureAfter },
                transactions: sessionLog.transactions.slice(),
            });
        }
        return new VerifiedState(this.id, this.crypto, this.header, clonedSessions);
    }
    tryAddTransactions(sessionID, signerID, newTransactions, givenExpectedNewHash, newSignature, skipVerify = false, givenNewStreamingHash) {
        if (skipVerify === true && givenNewStreamingHash && givenExpectedNewHash) {
            this.doAddTransactions(sessionID, newTransactions, newSignature, givenExpectedNewHash, givenNewStreamingHash);
        }
        else {
            const { expectedNewHash, newStreamingHash } = this.expectedNewHashAfter(sessionID, newTransactions);
            if (givenExpectedNewHash && givenExpectedNewHash !== expectedNewHash) {
                return err({
                    type: "InvalidHash",
                    id: this.id,
                    expectedNewHash,
                    givenExpectedNewHash,
                });
            }
            if (!this.crypto.verify(newSignature, expectedNewHash, signerID)) {
                return err({
                    type: "InvalidSignature",
                    id: this.id,
                    newSignature,
                    sessionID,
                    signerID,
                });
            }
            this.doAddTransactions(sessionID, newTransactions, newSignature, expectedNewHash, newStreamingHash);
        }
        return ok(true);
    }
    doAddTransactions(sessionID, newTransactions, newSignature, expectedNewHash, newStreamingHash) {
        const transactions = this.sessions.get(sessionID)?.transactions ?? [];
        for (const tx of newTransactions) {
            transactions.push(tx);
        }
        const signatureAfter = this.sessions.get(sessionID)?.signatureAfter ?? {};
        const lastInbetweenSignatureIdx = Object.keys(signatureAfter).reduce((max, idx) => (parseInt(idx) > max ? parseInt(idx) : max), -1);
        const sizeOfTxsSinceLastInbetweenSignature = transactions
            .slice(lastInbetweenSignatureIdx + 1)
            .reduce((sum, tx) => sum +
            (tx.privacy === "private"
                ? tx.encryptedChanges.length
                : tx.changes.length), 0);
        if (sizeOfTxsSinceLastInbetweenSignature > MAX_RECOMMENDED_TX_SIZE) {
            signatureAfter[transactions.length - 1] = newSignature;
        }
        this.sessions.set(sessionID, {
            transactions,
            lastHash: expectedNewHash,
            streamingHash: newStreamingHash,
            lastSignature: newSignature,
            signatureAfter: signatureAfter,
        });
        this._cachedNewContentSinceEmpty = undefined;
        this._cachedKnownState = undefined;
    }
    expectedNewHashAfter(sessionID, newTransactions) {
        const streamingHash = this.sessions.get(sessionID)?.streamingHash.clone() ??
            new StreamingHash(this.crypto);
        for (const transaction of newTransactions) {
            streamingHash.update(transaction);
        }
        return {
            expectedNewHash: streamingHash.digest(),
            newStreamingHash: streamingHash,
        };
    }
    newContentSince(knownState) {
        const isKnownStateEmpty = !knownState?.header && !knownState?.sessions;
        if (isKnownStateEmpty && this._cachedNewContentSinceEmpty) {
            return this._cachedNewContentSinceEmpty;
        }
        let currentPiece = {
            action: "content",
            id: this.id,
            header: knownState?.header ? undefined : this.header,
            priority: getPriorityFromHeader(this.header),
            new: {},
        };
        const pieces = [currentPiece];
        const sentState = {};
        let pieceSize = 0;
        let sessionsTodoAgain = "first";
        while (sessionsTodoAgain === "first" || sessionsTodoAgain?.size || 0 > 0) {
            if (sessionsTodoAgain === "first") {
                sessionsTodoAgain = undefined;
            }
            const sessionsTodo = sessionsTodoAgain ?? this.sessions.keys();
            for (const sessionIDKey of sessionsTodo) {
                const sessionID = sessionIDKey;
                const log = this.sessions.get(sessionID);
                const knownStateForSessionID = knownState?.sessions[sessionID];
                const sentStateForSessionID = sentState[sessionID];
                const nextKnownSignatureIdx = getNextKnownSignatureIdx(log, knownStateForSessionID, sentStateForSessionID);
                const firstNewTxIdx = sentStateForSessionID ?? knownStateForSessionID ?? 0;
                const afterLastNewTxIdx = nextKnownSignatureIdx === undefined
                    ? log.transactions.length
                    : nextKnownSignatureIdx + 1;
                const nNewTx = Math.max(0, afterLastNewTxIdx - firstNewTxIdx);
                if (nNewTx === 0) {
                    sessionsTodoAgain?.delete(sessionID);
                    continue;
                }
                if (afterLastNewTxIdx < log.transactions.length) {
                    if (!sessionsTodoAgain) {
                        sessionsTodoAgain = new Set();
                    }
                    sessionsTodoAgain.add(sessionID);
                }
                const oldPieceSize = pieceSize;
                for (let txIdx = firstNewTxIdx; txIdx < afterLastNewTxIdx; txIdx++) {
                    const tx = log.transactions[txIdx];
                    pieceSize +=
                        tx.privacy === "private"
                            ? tx.encryptedChanges.length
                            : tx.changes.length;
                }
                if (pieceSize >= MAX_RECOMMENDED_TX_SIZE) {
                    currentPiece = {
                        action: "content",
                        id: this.id,
                        header: undefined,
                        new: {},
                        priority: getPriorityFromHeader(this.header),
                    };
                    pieces.push(currentPiece);
                    pieceSize = pieceSize - oldPieceSize;
                }
                let sessionEntry = currentPiece.new[sessionID];
                if (!sessionEntry) {
                    sessionEntry = {
                        after: sentStateForSessionID ?? knownStateForSessionID ?? 0,
                        newTransactions: [],
                        lastSignature: "WILL_BE_REPLACED",
                    };
                    currentPiece.new[sessionID] = sessionEntry;
                }
                for (let txIdx = firstNewTxIdx; txIdx < afterLastNewTxIdx; txIdx++) {
                    const tx = log.transactions[txIdx];
                    sessionEntry.newTransactions.push(tx);
                }
                sessionEntry.lastSignature =
                    nextKnownSignatureIdx === undefined
                        ? log.lastSignature
                        : log.signatureAfter[nextKnownSignatureIdx];
                sentState[sessionID] =
                    (sentStateForSessionID ?? knownStateForSessionID ?? 0) + nNewTx;
            }
        }
        const piecesWithContent = pieces.filter((piece) => Object.keys(piece.new).length > 0 || piece.header);
        if (piecesWithContent.length === 0) {
            return undefined;
        }
        if (isKnownStateEmpty) {
            this._cachedNewContentSinceEmpty = piecesWithContent;
        }
        return piecesWithContent;
    }
    knownState() {
        if (this._cachedKnownState) {
            return this._cachedKnownState;
        }
        else {
            const knownState = this.knownStateUncached();
            this._cachedKnownState = knownState;
            return knownState;
        }
    }
    /** @internal */
    knownStateUncached() {
        const sessions = {};
        for (const [sessionID, sessionLog] of this.sessions.entries()) {
            sessions[sessionID] = sessionLog.transactions.length;
        }
        return {
            id: this.id,
            header: true,
            sessions,
        };
    }
}
function getNextKnownSignatureIdx(log, knownStateForSessionID, sentStateForSessionID) {
    return Object.keys(log.signatureAfter)
        .map(Number)
        .sort((a, b) => a - b)
        .find((idx) => idx >= (sentStateForSessionID ?? knownStateForSessionID ?? -1));
}
//# sourceMappingURL=verifiedState.js.map