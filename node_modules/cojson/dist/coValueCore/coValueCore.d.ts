import { Result } from "neverthrow";
import { PeerState } from "../PeerState.js";
import { RawCoValue } from "../coValue.js";
import { ControlledAccountOrAgent } from "../coValues/account.js";
import { RawGroup } from "../coValues/group.js";
import { CryptoProvider, Hash, KeyID, KeySecret, Signature, SignerID, StreamingHash } from "../crypto/crypto.js";
import { RawCoID, SessionID, TransactionID } from "../ids.js";
import { JsonValue } from "../jsonValue.js";
import { LocalNode, ResolveAccountAgentError } from "../localNode.js";
import { CoValueKnownState, PeerID } from "../sync.js";
import { CoValueHeader, Transaction, VerifiedState } from "./verifiedState.js";
/**
    In order to not block other concurrently syncing CoValues we introduce a maximum size of transactions,
    since they are the smallest unit of progress that can be synced within a CoValue.
    This is particularly important for storing binary data in CoValues, since they are likely to be at least on the order of megabytes.
    This also means that we want to keep signatures roughly after each MAX_RECOMMENDED_TX size chunk,
    to be able to verify partially loaded CoValues or CoValues that are still being created (like a video live stream).
**/
export declare const MAX_RECOMMENDED_TX_SIZE: number;
export declare function idforHeader(header: CoValueHeader, crypto: CryptoProvider): RawCoID;
export type DecryptedTransaction = {
    txID: TransactionID;
    changes: JsonValue[];
    madeAt: number;
};
export type AvailableCoValueCore = CoValueCore & {
    verified: VerifiedState;
};
export declare const CO_VALUE_LOADING_CONFIG: {
    MAX_RETRIES: number;
    TIMEOUT: number;
    RETRY_DELAY: number;
};
export declare class CoValueCore {
    readonly node: LocalNode;
    private readonly crypto;
    id: RawCoID;
    private _verified;
    /** Holds the fundamental syncable content of a CoValue,
     * consisting of the header (verified by hash -> RawCoID)
     * and the sessions (verified by signature).
     *
     * It does not do any *validation* or *decryption* and as such doesn't
     * depend on other CoValues or the LocalNode.
     *
     * `CoValueCore.verified` may be null when a CoValue is requested to be
     * loaded but no content has been received from storage or peers yet.
     * In this case, it acts as a centralised entry to keep track of peer loading
     * state and to subscribe to its content when it does become available. */
    get verified(): VerifiedState | null;
    private readonly peers;
    private _cachedContent?;
    private readonly listeners;
    private readonly _decryptionCache;
    private _cachedDependentOn?;
    private counter;
    private constructor();
    static fromID(id: RawCoID, node: LocalNode): CoValueCore;
    static fromHeader(header: CoValueHeader, node: LocalNode): AvailableCoValueCore;
    get loadingState(): "unknown" | "available" | "unavailable" | "loading";
    isAvailable(): this is AvailableCoValueCore;
    isErroredInPeer(peerId: PeerID): boolean;
    waitForAvailableOrUnavailable(): Promise<CoValueCore>;
    waitForAvailable(): Promise<CoValueCore>;
    getStateForPeer(peerId: PeerID): {
        type: "unknown" | "pending" | "available" | "unavailable";
    } | {
        type: "errored";
        error: TryAddTransactionsError;
    } | undefined;
    private updateCounter;
    markNotFoundInPeer(peerId: PeerID): void;
    missingDependencies: Set<`co_z${string}`>;
    markMissingDependency(dependency: RawCoID): void;
    provideHeader(header: CoValueHeader, fromPeerId: PeerID): void;
    internalMarkMagicallyAvailable(verified: VerifiedState, { forceOverwrite }?: {
        forceOverwrite?: boolean;
    }): void;
    markErrored(peerId: PeerID, error: TryAddTransactionsError): void;
    private markPending;
    internalShamefullyCloneVerifiedStateFrom(state: VerifiedState, { forceOverwrite }?: {
        forceOverwrite?: boolean;
    }): void;
    internalShamefullyResetCachedContent(): void;
    groupInvalidationSubscription?: () => void;
    subscribeToGroupInvalidation(): void;
    contentInClonedNodeWithDifferentAccount(account: ControlledAccountOrAgent): RawCoValue;
    knownState(): CoValueKnownState;
    get meta(): JsonValue;
    nextTransactionID(): TransactionID;
    tryAddTransactions(sessionID: SessionID, newTransactions: Transaction[], givenExpectedNewHash: Hash | undefined, newSignature: Signature, notifyMode: "immediate" | "deferred", skipVerify?: boolean, givenNewStreamingHash?: StreamingHash): Result<true, TryAddTransactionsError>;
    deferredUpdates: number;
    nextDeferredNotify: Promise<void> | undefined;
    notifyUpdate(notifyMode: "immediate" | "deferred"): void;
    subscribe(listener: (core: CoValueCore, unsub: () => void) => void, immediateInvoke?: boolean): () => void;
    makeTransaction(changes: JsonValue[], privacy: "private" | "trusting"): boolean;
    getCurrentContent(options?: {
        ignorePrivateTransactions: true;
    }): RawCoValue;
    getValidTransactions(options?: {
        ignorePrivateTransactions: boolean;
        knownTransactions?: CoValueKnownState["sessions"];
    }): DecryptedTransaction[];
    getValidSortedTransactions(options?: {
        ignorePrivateTransactions: boolean;
        knownTransactions: CoValueKnownState["sessions"];
    }): DecryptedTransaction[];
    compareTransactions(a: Pick<DecryptedTransaction, "madeAt" | "txID">, b: Pick<DecryptedTransaction, "madeAt" | "txID">): number;
    getCurrentReadKey(): {
        secret: KeySecret | undefined;
        id: KeyID;
    };
    getReadKey(keyID: KeyID): KeySecret | undefined;
    getUncachedReadKey(keyID: KeyID): KeySecret | undefined;
    findValidParentKeys(keyID: KeyID, group: RawGroup, parentGroup: CoValueCore): {
        id: KeyID;
        secret: KeySecret;
    }[];
    getGroup(): RawGroup;
    getTx(txID: TransactionID): Transaction | undefined;
    getDependedOnCoValues(): Set<RawCoID>;
    waitForSync(options?: {
        timeout?: number;
    }): Promise<unknown[]>;
    loadFromPeers(peers: PeerState[]): Promise<void>;
    internalLoadFromPeer(peer: PeerState): Promise<void> | undefined;
}
export type InvalidHashError = {
    type: "InvalidHash";
    id: RawCoID;
    expectedNewHash: Hash;
    givenExpectedNewHash: Hash;
};
export type InvalidSignatureError = {
    type: "InvalidSignature";
    id: RawCoID;
    newSignature: Signature;
    sessionID: SessionID;
    signerID: SignerID;
};
export type TriedToAddTransactionsWithoutVerifiedStateErrpr = {
    type: "TriedToAddTransactionsWithoutVerifiedState";
    id: RawCoID;
};
export type TryAddTransactionsError = TriedToAddTransactionsWithoutVerifiedStateErrpr | ResolveAccountAgentError | InvalidHashError | InvalidSignatureError;
//# sourceMappingURL=coValueCore.d.ts.map