import { Result } from "neverthrow";
import { AnyRawCoValue } from "../coValue.js";
import { CryptoProvider, Encrypted, Hash, KeyID, Signature, SignerID, StreamingHash } from "../crypto/crypto.js";
import { RawCoID, SessionID, TransactionID } from "../ids.js";
import { Stringified } from "../jsonStringify.js";
import { JsonObject, JsonValue } from "../jsonValue.js";
import { PermissionsDef as RulesetDef } from "../permissions.js";
import { CoValueKnownState, NewContentMessage } from "../sync.js";
import { TryAddTransactionsError } from "./coValueCore.js";
export type CoValueHeader = {
    type: AnyRawCoValue["type"];
    ruleset: RulesetDef;
    meta: JsonObject | null;
} & CoValueUniqueness;
export type CoValueUniqueness = {
    uniqueness: JsonValue;
    createdAt?: `2${string}` | null;
};
export type PrivateTransaction = {
    privacy: "private";
    madeAt: number;
    keyUsed: KeyID;
    encryptedChanges: Encrypted<JsonValue[], {
        in: RawCoID;
        tx: TransactionID;
    }>;
};
export type TrustingTransaction = {
    privacy: "trusting";
    madeAt: number;
    changes: Stringified<JsonValue[]>;
};
export type Transaction = PrivateTransaction | TrustingTransaction;
type SessionLog = {
    readonly transactions: Transaction[];
    lastHash?: Hash;
    streamingHash: StreamingHash;
    readonly signatureAfter: {
        [txIdx: number]: Signature | undefined;
    };
    lastSignature: Signature;
};
export type ValidatedSessions = Map<SessionID, SessionLog>;
export declare class VerifiedState {
    readonly id: RawCoID;
    readonly crypto: CryptoProvider;
    readonly header: CoValueHeader;
    readonly sessions: ValidatedSessions;
    private _cachedKnownState?;
    private _cachedNewContentSinceEmpty;
    constructor(id: RawCoID, crypto: CryptoProvider, header: CoValueHeader, sessions: ValidatedSessions);
    clone(): VerifiedState;
    tryAddTransactions(sessionID: SessionID, signerID: SignerID, newTransactions: Transaction[], givenExpectedNewHash: Hash | undefined, newSignature: Signature, skipVerify?: boolean, givenNewStreamingHash?: StreamingHash): Result<true, TryAddTransactionsError>;
    private doAddTransactions;
    expectedNewHashAfter(sessionID: SessionID, newTransactions: Transaction[]): {
        expectedNewHash: Hash;
        newStreamingHash: StreamingHash;
    };
    newContentSince(knownState: CoValueKnownState | undefined): NewContentMessage[] | undefined;
    knownState(): CoValueKnownState;
    /** @internal */
    knownStateUncached(): CoValueKnownState;
}
export {};
//# sourceMappingURL=verifiedState.d.ts.map