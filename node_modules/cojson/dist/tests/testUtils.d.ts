import { MetricReader } from "@opentelemetry/sdk-metrics";
import { ControlledAccount, ControlledAgent } from "../coValues/account.js";
import { type AgentSecret, type CoID, type CoValueCore, type RawCoValue } from "../exports.js";
import type { SessionID } from "../ids.js";
import { LocalNode } from "../localNode.js";
import type { Peer, SyncMessage } from "../sync.js";
export declare function randomAgentAndSessionID(): [ControlledAgent, SessionID];
export declare function nodeWithRandomAgentAndSessionID(): LocalNode;
export declare function createTestNode(): LocalNode;
export declare function createTwoConnectedNodes(node1Role: Peer["role"], node2Role: Peer["role"]): Promise<{
    node1: {
        node: LocalNode;
        accountID: import("../exports.js").RawAccountID;
        accountSecret: AgentSecret;
        sessionID: SessionID;
    };
    node2: {
        node: LocalNode;
        accountID: import("../exports.js").RawAccountID;
        accountSecret: AgentSecret;
        sessionID: SessionID;
    };
    node1ToNode2Peer: Peer;
    node2ToNode1Peer: Peer;
}>;
export declare function createThreeConnectedNodes(node1Role: Peer["role"], node2Role: Peer["role"], node3Role: Peer["role"]): Promise<{
    node1: {
        node: LocalNode;
        accountID: import("../exports.js").RawAccountID;
        accountSecret: AgentSecret;
        sessionID: SessionID;
    };
    node2: {
        node: LocalNode;
        accountID: import("../exports.js").RawAccountID;
        accountSecret: AgentSecret;
        sessionID: SessionID;
    };
    node3: {
        node: LocalNode;
        accountID: import("../exports.js").RawAccountID;
        accountSecret: AgentSecret;
        sessionID: SessionID;
    };
    node1ToNode2Peer: Peer;
    node2ToNode1Peer: Peer;
    node1ToNode3Peer: Peer;
    node3ToNode1Peer: Peer;
    node2ToNode3Peer: Peer;
    node3ToNode2Peer: Peer;
}>;
export declare function connectTwoPeers(a: LocalNode, b: LocalNode, aRole: "client" | "server", bRole: "client" | "server"): void;
export declare function newGroup(): {
    node: LocalNode;
    groupCore: import("../coValueCore/coValueCore.js").AvailableCoValueCore;
    admin: ControlledAgent;
};
export declare function groupWithTwoAdmins(): {
    group: import("../exports.js").RawGroup<import("../jsonValue.js").JsonObject | null>;
    groupCore: import("../coValueCore/coValueCore.js").AvailableCoValueCore;
    admin: ControlledAgent;
    otherAdmin: ControlledAccount;
    node: LocalNode;
};
export declare function newGroupHighLevel(): {
    admin: ControlledAgent;
    node: LocalNode;
    group: import("../exports.js").RawGroup<import("../jsonValue.js").JsonObject | null>;
};
export declare function groupWithTwoAdminsHighLevel(): {
    admin: ControlledAgent;
    node: LocalNode;
    group: import("../exports.js").RawGroup<import("../jsonValue.js").JsonObject | null>;
    otherAdmin: ControlledAccount;
};
export declare function shouldNotResolve<T>(promise: Promise<T>, ops: {
    timeout: number;
}): Promise<void>;
export declare function waitFor(callback: () => boolean | void | Promise<boolean | void>): Promise<void>;
export declare function loadCoValueOrFail<V extends RawCoValue>(node: LocalNode, id: CoID<V>): Promise<V>;
export declare function blockMessageTypeOnOutgoingPeer(peer: Peer, messageType: SyncMessage["action"], opts: {
    id?: string;
    once?: boolean;
}): {
    blockedMessages: SyncMessage[];
    sendBlockedMessages: () => Promise<void>;
    unblock: () => void;
};
export declare function hotSleep(ms: number): number;
/**
 * This is a test metric reader that uses an in-memory metric exporter and exposes a method to get the value of a metric given its name and attributes.
 *
 * This is useful for testing the values of metrics that are collected by the SDK.
 *
 * TODO: We may want to rethink how we access metrics (see `getMetricValue` method) to make it more flexible.
 */
declare class TestMetricReader extends MetricReader {
    private _exporter;
    protected onShutdown(): Promise<void>;
    protected onForceFlush(): Promise<void>;
    getMetricValue(name: string, attributes?: {
        [key: string]: string | number;
    }): Promise<number | import("@opentelemetry/sdk-metrics").Histogram | import("@opentelemetry/sdk-metrics").ExponentialHistogram | undefined>;
    collectAndExport(): Promise<void>;
}
export declare function createTestMetricReader(): TestMetricReader;
export declare function tearDownTestMetricReader(): void;
export declare class SyncMessagesLog {
    static messages: SyncTestMessage[];
    static add(message: SyncTestMessage): void;
    static clear(): void;
    static getMessages(coValueMapping: {
        [key: string]: CoValueCore;
    }): string[];
    static debugMessages(coValueMapping: {
        [key: string]: CoValueCore;
    }): void;
}
export declare function getSyncServerConnectedPeer(opts: {
    syncServerName?: string;
    ourName?: string;
    syncServer?: LocalNode;
    peerId: string;
}): {
    peer: Peer;
    peerStateOnServer: import("../PeerState.js").PeerState;
    peerOnServer: Peer;
};
export declare function createMockStoragePeer(opts: {
    ourName?: string;
    peerId: string;
}): {
    storage: LocalNode;
    peer: Peer;
};
export declare function setupTestNode(opts?: {
    isSyncServer?: boolean;
    connected?: boolean;
}): {
    node: LocalNode;
    connectToSyncServer: (opts?: {
        syncServerName?: string;
        ourName?: string;
        syncServer?: LocalNode;
    }) => {
        peerState: import("../PeerState.js").PeerState;
        peer: Peer;
        peerStateOnServer: import("../PeerState.js").PeerState;
        peerOnServer: Peer;
    };
    addStoragePeer: (opts?: {
        ourName?: string;
    }) => {
        peer: Peer;
        peerState: import("../PeerState.js").PeerState;
        storage: LocalNode;
    };
    restart: () => LocalNode;
};
export declare function setupTestAccount(opts?: {
    isSyncServer?: boolean;
    connected?: boolean;
}): Promise<{
    node: LocalNode;
    accountID: import("../exports.js").RawAccountID;
    connectToSyncServer: (opts?: {
        syncServerName?: string;
        ourName?: string;
        syncServer?: LocalNode;
    }) => {
        peerState: import("../PeerState.js").PeerState;
        peer: Peer;
        peerStateOnServer: import("../PeerState.js").PeerState;
        peerOnServer: Peer;
        getCurrentPeerState: () => import("../PeerState.js").PeerState;
    };
    addStoragePeer: (opts?: {
        ourName?: string;
    }) => {
        peer: Peer;
        peerState: import("../PeerState.js").PeerState;
        storage: LocalNode;
    };
}>;
export type SyncTestMessage = {
    from: string;
    to: string;
    msg: SyncMessage;
};
export declare function connectedPeersWithMessagesTracking(opts: {
    peer1: {
        id: string;
        role: Peer["role"];
        name?: string;
    };
    peer2: {
        id: string;
        role: Peer["role"];
        name?: string;
    };
}): {
    peer1: Peer;
    peer2: Peer;
};
export declare function createAccountInNode(node: LocalNode): ControlledAccount;
export {};
//# sourceMappingURL=testUtils.d.ts.map