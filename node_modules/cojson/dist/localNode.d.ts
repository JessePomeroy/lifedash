import { Result } from "neverthrow";
import { CoID } from "./coValue.js";
import { RawCoValue } from "./coValue.js";
import { AvailableCoValueCore, CoValueCore } from "./coValueCore/coValueCore.js";
import { CoValueHeader, CoValueUniqueness } from "./coValueCore/verifiedState.js";
import { AccountMeta, ControlledAccountOrAgent, InvalidAccountAgentIDError, RawAccount, RawAccountID, RawAccountMigration, RawProfile } from "./coValues/account.js";
import { InviteSecret, RawGroup } from "./coValues/group.js";
import { AgentSecret, CryptoProvider } from "./crypto/crypto.js";
import { AgentID, RawCoID, SessionID } from "./ids.js";
import { Peer, PeerID, SyncManager } from "./sync.js";
/** A `LocalNode` represents a local view of a set of loaded `CoValue`s, from the perspective of a particular account (or primitive cryptographic agent).

A `LocalNode` can have peers that it syncs to, for example some form of local persistence, or a sync server, such as `cloud.jazz.tools` (Jazz Cloud).

@example
You typically get hold of a `LocalNode` using `jazz-react`'s `useJazz()`:

```typescript
const { localNode } = useJazz();
```
*/
export declare class LocalNode {
    /** @internal */
    crypto: CryptoProvider;
    /** @internal */
    private readonly coValues;
    /** @category 3. Low-level */
    readonly currentSessionID: SessionID;
    readonly agentSecret: AgentSecret;
    /** @category 3. Low-level */
    syncManager: SyncManager;
    crashed: Error | undefined;
    /** @category 3. Low-level */
    constructor(agentSecret: AgentSecret, currentSessionID: SessionID, crypto: CryptoProvider);
    getCoValue(id: RawCoID): CoValueCore;
    allCoValues(): MapIterator<CoValueCore>;
    private putCoValue;
    internalDeleteCoValue(id: RawCoID): void;
    getCurrentAccountOrAgentID(): RawAccountID | AgentID;
    getCurrentAgent(): ControlledAccountOrAgent;
    expectCurrentAccountID(reason: string): RawAccountID;
    expectCurrentAccount(reason: string): RawAccount;
    static internalCreateAccount(opts: {
        crypto: CryptoProvider;
        initialAgentSecret?: AgentSecret;
        peersToLoadFrom?: Peer[];
    }): RawAccount;
    /** @category 2. Node Creation */
    static withNewlyCreatedAccount({ creationProps, peersToLoadFrom, migration, crypto, initialAgentSecret, }: {
        creationProps: {
            name: string;
        };
        peersToLoadFrom?: Peer[];
        migration?: RawAccountMigration<AccountMeta>;
        crypto: CryptoProvider;
        initialAgentSecret?: AgentSecret;
    }): Promise<{
        node: LocalNode;
        accountID: RawAccountID;
        accountSecret: AgentSecret;
        sessionID: SessionID;
    }>;
    /** @category 2. Node Creation */
    static withLoadedAccount({ accountID, accountSecret, sessionID, peersToLoadFrom, crypto, migration, }: {
        accountID: RawAccountID;
        accountSecret: AgentSecret;
        sessionID: SessionID | undefined;
        peersToLoadFrom: Peer[];
        crypto: CryptoProvider;
        migration?: RawAccountMigration<AccountMeta>;
    }): Promise<LocalNode>;
    /** @internal */
    createCoValue(header: CoValueHeader): AvailableCoValueCore;
    /** @internal */
    loadCoValueCore(id: RawCoID, skipLoadingFromPeer?: PeerID): Promise<CoValueCore>;
    /**
     * Loads a CoValue's content, syncing from peers as necessary and resolving the returned
     * promise once a first version has been loaded. See `coValue.subscribe()` and `node.useTelepathicData()`
     * for listening to subsequent updates to the CoValue.
     *
     * @category 3. Low-level
     */
    load<T extends RawCoValue>(id: CoID<T>): Promise<T | "unavailable">;
    getLoaded<T extends RawCoValue>(id: CoID<T>): T | undefined;
    /** @category 3. Low-level */
    subscribe<T extends RawCoValue>(id: CoID<T>, callback: (update: T | "unavailable") => void): () => void;
    acceptInvite<T extends RawCoValue>(groupOrOwnedValueID: CoID<T>, inviteSecret: InviteSecret): Promise<void>;
    /** @internal */
    expectCoValueLoaded(id: RawCoID, expectation?: string): AvailableCoValueCore;
    /** @internal */
    expectProfileLoaded(id: RawAccountID, expectation?: string): RawProfile;
    /** @internal */
    resolveAccountAgent(id: RawAccountID | AgentID, expectation?: string): Result<AgentID, ResolveAccountAgentError>;
    createGroup(uniqueness?: CoValueUniqueness): RawGroup;
    loadCoValueAsDifferentAgent(id: RawCoID, secret: AgentSecret, accountId?: RawAccountID | AgentID): AvailableCoValueCore;
    /** @internal */
    cloneVerifiedStateFrom(otherNode: LocalNode, id: RawCoID): void;
    gracefulShutdown(): void;
}
export type LoadCoValueCoreError = {
    type: "ErrorLoadingCoValueCore";
    error: unknown;
    expectation?: string;
    id: RawAccountID;
};
export type AccountUnavailableFromAllPeersError = {
    type: "AccountUnavailableFromAllPeers";
    expectation?: string;
    id: RawAccountID;
};
export type UnexpectedlyNotAccountError = {
    type: "UnexpectedlyNotAccount";
    expectation?: string;
    id: RawAccountID;
};
export type ResolveAccountAgentError = InvalidAccountAgentIDError | LoadCoValueCoreError | AccountUnavailableFromAllPeersError | UnexpectedlyNotAccountError;
//# sourceMappingURL=localNode.d.ts.map